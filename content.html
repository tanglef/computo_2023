<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.235">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tanguy Lefort">
<meta name="author" content="Benjamin Charlier">
<meta name="author" content="Alexis Joly">
<meta name="author" content="Joseph Salmon">
<meta name="dcterms.date" content="2023-07-18">
<meta name="keywords" content="crowdsourcing, label noise, task difficulty, worker ability">
<meta name="description" content="Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, it is common for workers to disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We introduce peerannot, a Python library for managing and learning from crowdsourced labels.">

<title>Peerannot: learning from crowdsourced image datasets with Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="content_files/libs/clipboard/clipboard.min.js"></script>
<script src="content_files/libs/quarto-html/quarto.js"></script>
<script src="content_files/libs/quarto-html/popper.min.js"></script>
<script src="content_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="content_files/libs/quarto-html/anchor.min.js"></script>
<link href="content_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="content_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="content_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="content_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="content_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script type="text/javascript">
window.PlotlyConfig = {MathJaxConfig: 'local'};
if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: "STIX-Web"}});}
if (typeof require !== 'undefined') {
require.undef("plotly");
requirejs.config({
    paths: {
        'plotly': ['https://cdn.plot.ly/plotly-2.24.1.min']
    }
});
require(['plotly'], function(Plotly) {
    window._Plotly = Plotly;
});
}
</script>


  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Peerannot: learning from crowdsourced image datasets with Python</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, it is common for workers to disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We introduce <code>peerannot</code>, a Python library for managing and learning from crowdsourced labels.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://tanglef.github.io">Tanguy Lefort</a> <a href="https://orcid.org/0009-0000-6710-3221" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  IMAG, Univ Montpellier, CNRS, Inria, LIRMM
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://imag.umontpellier.fr/~charlier/index.php?page=index&amp;lang=en">Benjamin Charlier</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  IMAG, Univ Montpellier, CNRS
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://www-sop.inria.fr/members/Alexis.Joly/wiki/pmwiki.php">Alexis Joly</a> <a href="https://orcid.org/0000-0002-2161-9940" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  Inria, LIRMM, Univ Montpellier, CNRS
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://josephsalmon.eu/">Joseph Salmon</a> <a href="https://orcid.org/0000-0002-3181-0634" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  IMAG, Univ Montpellier, CNRS, IUF
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 18, 2023</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">July 18, 2023</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">crowdsourcing, label noise, task difficulty, worker ability</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, workers often disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We present <code>peerannot</code>: a <code>Python</code> library for managing and learning from crowdsourced labels. Our library allows users to aggregate labels from common noise models or train a deep learning-based classifier directly from crowdsourced labels. In addition, we provide an identification module to easily explore the task difficulty of datasets and worker capabilities.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction-crowdsourcing-in-image-classification" id="toc-introduction-crowdsourcing-in-image-classification" class="nav-link active" data-scroll-target="#introduction-crowdsourcing-in-image-classification"><span class="header-section-number">1</span> Introduction: crowdsourcing in image classification</a></li>
  <li><a href="#notation-and-package-structure" id="toc-notation-and-package-structure" class="nav-link" data-scroll-target="#notation-and-package-structure"><span class="header-section-number">2</span> Notation and package structure</a>
  <ul class="collapse">
  <li><a href="#crowdsourcing-notation" id="toc-crowdsourcing-notation" class="nav-link" data-scroll-target="#crowdsourcing-notation"><span class="header-section-number">2.1</span> Crowdsourcing notation</a></li>
  <li><a href="#storing-crowdsourced-datasets-in-peerannot" id="toc-storing-crowdsourced-datasets-in-peerannot" class="nav-link" data-scroll-target="#storing-crowdsourced-datasets-in-peerannot"><span class="header-section-number">2.2</span> Storing crowdsourced datasets in <code>peerannot</code></a></li>
  </ul></li>
  <li><a href="#sec-introaggregation" id="toc-sec-introaggregation" class="nav-link" data-scroll-target="#sec-introaggregation"><span class="header-section-number">3</span> Aggregation strategies in crowdsourcing</a>
  <ul class="collapse">
  <li><a href="#classical-models" id="toc-classical-models" class="nav-link" data-scroll-target="#classical-models"><span class="header-section-number">3.1</span> Classical models</a>
  <ul class="collapse">
  <li><a href="#majority-vote-mv" id="toc-majority-vote-mv" class="nav-link" data-scroll-target="#majority-vote-mv"><span class="header-section-number">3.1.1</span> Majority vote (MV)</a></li>
  <li><a href="#naive-soft-ns" id="toc-naive-soft-ns" class="nav-link" data-scroll-target="#naive-soft-ns"><span class="header-section-number">3.1.2</span> Naive soft (NS)</a></li>
  <li><a href="#dawid-and-skene-ds" id="toc-dawid-and-skene-ds" class="nav-link" data-scroll-target="#dawid-and-skene-ds"><span class="header-section-number">3.1.3</span> Dawid and Skene (DS)</a></li>
  <li><a href="#variations-around-the-ds-model" id="toc-variations-around-the-ds-model" class="nav-link" data-scroll-target="#variations-around-the-ds-model"><span class="header-section-number">3.1.4</span> Variations around the DS model</a></li>
  <li><a href="#generative-model-of-labels-abilities-and-difficulties-glad" id="toc-generative-model-of-labels-abilities-and-difficulties-glad" class="nav-link" data-scroll-target="#generative-model-of-labels-abilities-and-difficulties-glad"><span class="header-section-number">3.1.5</span> Generative model of Labels, Abilities, and Difficulties (GLAD)</a></li>
  <li><a href="#aggregation-strategies-in-peerannot" id="toc-aggregation-strategies-in-peerannot" class="nav-link" data-scroll-target="#aggregation-strategies-in-peerannot"><span class="header-section-number">3.1.6</span> Aggregation strategies in <code>peerannot</code></a></li>
  </ul></li>
  <li><a href="#sec-evaluation-aggregation" id="toc-sec-evaluation-aggregation" class="nav-link" data-scroll-target="#sec-evaluation-aggregation"><span class="header-section-number">3.2</span> Experiments and evaluation of label aggregation strategies</a>
  <ul class="collapse">
  <li><a href="#sec-simu-independent" id="toc-sec-simu-independent" class="nav-link" data-scroll-target="#sec-simu-independent"><span class="header-section-number">3.2.1</span> Simulated independent mistakes simu-independent</a></li>
  <li><a href="#simulated-correlated-mistakes" id="toc-simulated-correlated-mistakes" class="nav-link" data-scroll-target="#simulated-correlated-mistakes"><span class="header-section-number">3.2.2</span> Simulated correlated mistakes</a></li>
  <li><a href="#simulated-mistakes-with-discrete-difficulty-levels-on-tasks" id="toc-simulated-mistakes-with-discrete-difficulty-levels-on-tasks" class="nav-link" data-scroll-target="#simulated-mistakes-with-discrete-difficulty-levels-on-tasks"><span class="header-section-number">3.2.3</span> Simulated mistakes with discrete difficulty levels on tasks</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#learning-from-crowdsourced-tasks" id="toc-learning-from-crowdsourced-tasks" class="nav-link" data-scroll-target="#learning-from-crowdsourced-tasks"><span class="header-section-number">4</span> Learning from crowdsourced tasks</a>
  <ul class="collapse">
  <li><a href="#popular-models" id="toc-popular-models" class="nav-link" data-scroll-target="#popular-models"><span class="header-section-number">4.1</span> Popular models</a>
  <ul class="collapse">
  <li><a href="#crowdlayer" id="toc-crowdlayer" class="nav-link" data-scroll-target="#crowdlayer"><span class="header-section-number">4.1.1</span> CrowdLayer</a></li>
  <li><a href="#conal" id="toc-conal" class="nav-link" data-scroll-target="#conal"><span class="header-section-number">4.1.2</span> CoNAL</a></li>
  </ul></li>
  <li><a href="#prediction-error-when-learning-from-crowdsourced-tasks" id="toc-prediction-error-when-learning-from-crowdsourced-tasks" class="nav-link" data-scroll-target="#prediction-error-when-learning-from-crowdsourced-tasks"><span class="header-section-number">4.2</span> Prediction error when learning from crowdsourced tasks</a></li>
  <li><a href="#sec-real-datasets" id="toc-sec-real-datasets" class="nav-link" data-scroll-target="#sec-real-datasets"><span class="header-section-number">4.3</span> Use case with <code>peerannot</code> on real datasets</a></li>
  </ul></li>
  <li><a href="#exploring-crowdsourced-datasets" id="toc-exploring-crowdsourced-datasets" class="nav-link" data-scroll-target="#exploring-crowdsourced-datasets"><span class="header-section-number">5</span> Exploring crowdsourced datasets</a>
  <ul class="collapse">
  <li><a href="#exploring-tasks-difficulty" id="toc-exploring-tasks-difficulty" class="nav-link" data-scroll-target="#exploring-tasks-difficulty"><span class="header-section-number">5.1</span> Exploring tasks’ difficulty</a>
  <ul class="collapse">
  <li><a href="#cifar-1oh-dataset" id="toc-cifar-1oh-dataset" class="nav-link" data-scroll-target="#cifar-1oh-dataset"><span class="header-section-number">5.1.1</span> CIFAR-1OH dataset</a></li>
  <li><a href="#labelme-dataset" id="toc-labelme-dataset" class="nav-link" data-scroll-target="#labelme-dataset"><span class="header-section-number">5.1.2</span> LabelMe dataset</a></li>
  </ul></li>
  <li><a href="#exploring-workers-reliability" id="toc-exploring-workers-reliability" class="nav-link" data-scroll-target="#exploring-workers-reliability"><span class="header-section-number">5.2</span> Exploring workers’ reliability</a>
  <ul class="collapse">
  <li><a href="#cifar-10h" id="toc-cifar-10h" class="nav-link" data-scroll-target="#cifar-10h"><span class="header-section-number">5.2.1</span> CIFAR-10H</a></li>
  <li><a href="#labelme" id="toc-labelme" class="nav-link" data-scroll-target="#labelme"><span class="header-section-number">5.2.2</span> LabelMe</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">6</span> Conclusion</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliography</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="content.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<section id="introduction-crowdsourcing-in-image-classification" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction: crowdsourcing in image classification</h1>
<p>Image datasets widely use crowdsourcing to collect labels, involving many workers that can annotate images for a small cost (or even free for instance in citizen science) and faster than using expert labeling. Many classical datasets considered in machine learning have been created with human intervention to create labels, such as CIFAR-<span class="math inline">10</span>, <span class="citation" data-cites="krizhevsky2009learning">(<a href="#ref-krizhevsky2009learning" role="doc-biblioref">Krizhevsky and Hinton 2009</a>)</span>, ImageNet <span class="citation" data-cites="imagenet_cvpr09">(<a href="#ref-imagenet_cvpr09" role="doc-biblioref">Deng et al. 2009</a>)</span> or Pl@ntnet <span class="citation" data-cites="Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021">(<a href="#ref-Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021" role="doc-biblioref">Garcin et al. 2021</a>)</span> in image classification, but also COCO <span class="citation" data-cites="cocodataset">(<a href="#ref-cocodataset" role="doc-biblioref">Lin et al. 2014</a>)</span>, solar photovoltaic arrays <span class="citation" data-cites="kasmi2023crowdsourced">(<a href="#ref-kasmi2023crowdsourced" role="doc-biblioref">Kasmi et al. 2023</a>)</span> or even macro litter <span class="citation" data-cites="chagneux2023">(<a href="#ref-chagneux2023" role="doc-biblioref">Chagneux et al. 2023</a>)</span> in image segmentation and object counting.</p>
<p>Crowdsourced datasets induce at least three major challenges to which we contribute with <code>peerannot</code>:</p>
<ol type="1">
<li><em>How to identify good workers in the crowd?</em> When multiple answers are given to a single task, looking for who to trust for which type of task becomes necessary to estimate the ground truth or later train a model with as few noise sources as possible. The module <code>identify</code> uses different scoring metrics to create a worker and/or task evaluation. This is particularly relevant considering the gamification of crowdsourcing experiments <span class="citation" data-cites="plantgame2016">(<a href="#ref-plantgame2016" role="doc-biblioref">Servajean et al. 2016</a>)</span></li>
<li><em>How to aggregate multiple labels into a single label from crowdsourced tasks?</em> This occurs for example when dealing with a single dataset that has been labeled by multiple workers with disagreements. This is also encountered with other scoring issues such as polls, reviews, peer-grading, <em>etc.</em> In our framework this is treated with the <code>aggregate</code> command, that given multiple labels, infers a ground truth label. From aggregated labels, a classifier can then be trained using the <code>train</code> command.</li>
<li><em>How to learn a classifier from crowdsourced datasets?</em> Where the first question is bound by aggregating multiple labels into a single one, this considers the case where we do not need a single label to train on, but instead train a classifier on the crowdsourced data, with the motivation to perform well on a testing set. This end-to-end vision, is common in machine learning, however, it requires the actual tasks (the images, texts, videos, <em>etc.</em>) to train on – and in crowdsourced datasets publicly available, they are not always available. This is treated with the <code>aggregate-deep</code> command.</li>
</ol>
<p>The library <code>peerannot</code> addresses these practical questions within a reproducible setting. Indeed, the complexity of experiments often leads to a lack of transparency and reproducible results for simulations and real datasets. We propose standard simulation settings with explicit implementation parameters that can be shared. For real datasets, <code>peerannot</code> is compatible with standard neural networks architectures from the <code>Torchvision</code> <span class="citation" data-cites="torchvision">(<a href="#ref-torchvision" role="doc-biblioref">Marcel and Rodriguez 2010</a>)</span> library and <code>Pytorch</code> <span class="citation" data-cites="pytorch">(<a href="#ref-pytorch" role="doc-biblioref">Paszke et al. 2019</a>)</span>, allowing a flexible framework with easy-to-share scripts to reproduce experiments.</p>
<div id="fig-pipeline" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./figures/strategiesbis.png" class="img-fluid figure-img" width="550"></p>
<figcaption class="figure-caption">Figure&nbsp;1: From crowdsourced labels to training a classifier neural network, the learning pipeline using the <code>peerannot</code> library. An optional preprocessing step using the <code>identify</code> command allows us to remove worse performing workers or images that can not be classified correctly (very bad quality for example). Then, from the cleaned dataset, the <code>aggregate</code> command may generate a single label per task from a prescribed strategy. From the aggregated labels we can train a neural network classifier with the <code>train</code> command. Otherwise, we can directly train a neural network classifier that takes into account the crowdsourcing setting in its architecture using <code>aggregate-deep</code>.</figcaption>
</figure>
</div>
</section>
<section id="notation-and-package-structure" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Notation and package structure</h1>
<section id="crowdsourcing-notation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="crowdsourcing-notation"><span class="header-section-number">2.1</span> Crowdsourcing notation</h2>
<p>Let us consider the classical supervised learning classification framework. A training set <span class="math inline">\mathcal{D}=\{(x_i, y_i^\star)\}_{i=1}^{n_{\text{task}}}</span> is composed of <span class="math inline">n_{\text{task}}</span> tasks <span class="math inline">x_i\in\mathcal{X}</span> (the feature space) with (unobserved) ground truth label <span class="math inline">y_i^\star \in [K]=\{1,\dots,K\}</span> one of the <span class="math inline">K</span> possible classes. In the following, the tasks considered are generally RGB images. We use the notation <span class="math inline">\sigma(\cdot)</span> for the softmax function. In praticular, given a classifier <span class="math inline">\mathcal{C}</span> with logits outputs, <span class="math inline">\sigma(\mathcal{C}(x_i))_{[1]}</span> represents the largest probability and we can sort the probabilities as <span class="math inline">\sigma(\mathcal{C}(x_i))_{[1]}\geq \sigma(\mathcal{C}(x_i))_{[2]}\geq \dots\geq \sigma(\mathcal{C}(x_i))_{[K]}</span>. We use the <span class="math inline">i</span> index notation to range over the different tasks and the <span class="math inline">j</span> index notation for the workers in the crowdsourcing experiment. Note that indices start at position <span class="math inline">1</span> in the equation to follow mathematical standard notation such as <span class="math inline">[K]=\{1,\dots,K\}</span> but it should be addressed that, as this is a <code>Python</code> library, in the code indices start at the <span class="math inline">0</span> position.</p>
<p>With crowdsourced data the ground truth of a task <span class="math inline">x_i</span>, denoted <span class="math inline">y_i^\star</span> is unknown, and there is no single label that can be trusted as in standard supervised learning (even on the train set!). Instead, there is a crowd of <span class="math inline">n_{\text{worker}}</span> workers from which multiple workers <span class="math inline">(w_j)_j</span> propose a label <span class="math inline">(y_i^{(j)})_j</span>. The set of workers answering the task <span class="math inline">x_i</span> is denoted by <span id="eq-workerset"><span class="math display">
\mathcal{A}(x_i)=\{j\in[n_\text{worker}]: w_j \text{ answered }x_i\}.
\tag{1}</span></span></p>
<p>The cardinal <span class="math inline">\vert \mathcal{A}(x_i)\vert</span> is called the feedback effort on the task <span class="math inline">x_i</span>. Note that the feedback effort can not exceed the total number of workers <span class="math inline">n_{\text{worker}}</span>. Similarly, one can adopt a worker point of view: the set of tasks answered by a worker <span class="math inline">w_j</span> is denoted <span id="eq-taskset"><span class="math display">
\mathcal{T}(w_j)=\{i\in[n_\text{task}]: w_j \text{ answered } x_i\}.
\tag{2}</span></span></p>
<p>The cardinal <span class="math inline">\vert \mathcal{T}(w_j)\vert</span> is called the workerload of <span class="math inline">w_j</span>. The final dataset can then be decomposed as: <span class="math display">
\mathcal{D}_{\text{train}} := \bigcup_{i\in[n_\text{task}]} \{(x_i, (y_i^{(j)})) \text{ for }j\in\mathcal{A}(x_i)\} = \bigcup_{j\in[n_\text{worker}]} \{(x_i, (y_i^{(j)})) \text{ for }i \in\mathcal{T}(w_j)\} \enspace.
</span></p>
<p>In this article, we do not address the setting where workers report their self-confidence <span class="citation" data-cites="YasminRomena2022ICIC">(<a href="#ref-YasminRomena2022ICIC" role="doc-biblioref">Yasmin et al. 2022</a>)</span>, nor settings where workers are presented a trapping set – <em>i.e</em> a subset of tasks where the ground truth is known to evaluate them with known labels <span class="citation" data-cites="khattak_toward_2017">(<a href="#ref-khattak_toward_2017" role="doc-biblioref">Khattak 2017</a>)</span>.</p>
</section>
<section id="storing-crowdsourced-datasets-in-peerannot" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="storing-crowdsourced-datasets-in-peerannot"><span class="header-section-number">2.2</span> Storing crowdsourced datasets in <code>peerannot</code></h2>
<p>Crowdsourced datasets come in various forms. To store crowdsourcing datasets efficiently and in a standardized way, <code>peerannot</code> proposes the following structure, where each dataset corresponds to a folder. Let us set up a toy dataset example to understand the data structure and how to store it.</p>
<p><code>{#lst-datasetconvention bash lst-cap="Dataset storage template"} datasetname       ├── train       │     ├── class1       │     │     ├─ imagename-&lt;key&gt;.png       │     │     ├─ ...       │     │     └─ anotherimagename-&lt;anotherkey&gt;.png       │     ├── ...       │     └── classK       ├── val       ├── test       ├── metadata.json       └── answers.json</code></p>
<p>The <code>answers.json</code> file stores the different votes for each task as described in <a href="#fig-answers" class="quarto-xref">Figure&nbsp;2</a>. Thus, for example for an image named <code>smiley_face-1</code>, the associated labels are stored in the <code>answers.json</code> at the key numbered <code>1</code>. This key identification system allows us to track directly from the filename the crowdsourced labels without having to rely on multiple indexing files as can be traditionally proposed. Furthermore, storing labels in a dictionary is more memory-friendly than having an array of size <code>(n_task,n_worker)</code> and writing <span class="math inline">y_i^{(j)}=-1</span> when the worker <span class="math inline">w_j</span> did not see the task <span class="math inline">x_i</span> and <span class="math inline">y_i^{(j)}\in[K]</span> otherwise.</p>
<div id="fig-answers" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./figures/json_answers.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Data storage for a crowdsourced dataset for a binary classification problem (<span class="math inline">K=2</span>, smiling/smiling) on recognizing smiling faces. (left: how data is stored in <code>peerannot</code> in a file <code>answers.json</code>, right: data collected)</figcaption>
</figure>
</div>
<p>In <a href="#fig-answers" class="quarto-xref">Figure&nbsp;2</a>, there are three tasks, <span class="math inline">n_{\text{worker}}=4</span> workers and <span class="math inline">K=2</span> classes. Any available task should be stored in a single file whose name follows the convention described in <strong>?@lst-datasetconvention</strong>. These files are spread into a <code>train</code>, <code>val</code> and <code>test</code> subdir as in <a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html"><code>ImageFolder</code> datasets</a> from <code>torchvision</code></p>
<p>Finally, a <code>metadata.json</code> file includes relevant information related to the crowdsourcing experiment such as the number of workers, the number of tasks, <em>etc.</em> For example, a minimal <code>metadata.json</code> file for the toy dataset presented in <a href="#fig-answers" class="quarto-xref">Figure&nbsp;2</a> is:</p>
<pre class="{json}"><code>{
    "name": "toy-data",
    "n_classes": 2,
    "n_workers": 4,
    "n_tasks": 3
}</code></pre>
<p>The <code>toy-data</code> example dataset is available as an example <a href="https://github.com/peerannot/peerannot/tree/main/datasets/toy-data">in the <code>peerannot</code> repository</a>. Classical datasets in crowdsourcing such as <span class="math inline">\texttt{CIFAR-10H}</span> <span class="citation" data-cites="peterson_human_2019">(<a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>)</span> and <span class="math inline">\texttt{LabelMe}</span> <span class="citation" data-cites="rodrigues2014gaussian">(<a href="#ref-rodrigues2014gaussian" role="doc-biblioref">Rodrigues, Pereira, and Ribeiro 2014</a>)</span> can be installed directly using <code>peerannot</code>. To install them, run the <code>install</code> command from <code>peerannot</code>:</p>
<div id="650ea208" class="cell" data-execution_count="1">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>labelme.py</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>cifar10h.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>For both <span class="math inline">\texttt{CIFAR-10H}</span> and <span class="math inline">\texttt{LabelMe}</span>, the dataset was originally released in classical supervised learning form (without crowdsourcing). These labels are used as ground truth in evaluations and visualizations. However, we emphasize that crowdsourcing strategies do not rely on the ground truth (only on the workers’ answers).</p>
<div id="cell-fig-cifarh" class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"bird"</span>, <span class="dv">1</span>: <span class="st">"car"</span>, <span class="dv">2</span>: <span class="st">"cat"</span>, <span class="dv">3</span>: <span class="st">"deer"</span>, <span class="dv">4</span>: <span class="st">"dog"</span>, <span class="dv">5</span>: <span class="st">"frog"</span>, <span class="dv">6</span>: <span class="st">"horse"</span>, <span class="dv">7</span>: <span class="st">"plane"</span>, <span class="dv">8</span>: <span class="st">"ship"</span>, <span class="dv">9</span>: <span class="st">"truck"</span>}</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(wspace<span class="op">=-</span><span class="fl">0.8</span>, hspace<span class="op">=</span><span class="fl">0.25</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-cifarh" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-cifarh-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Example of images from CIFAR-10H. We display images rowise according to the ground truth label.</figcaption>
</figure>
</div>
</div>
</div>
<p>Examples of <span class="math inline">\texttt{CIFAR-10H}</span> images are available in <a href="#fig-cifarh" class="quarto-xref">Figure&nbsp;3</a>, and <span class="math inline">\texttt{LabelMe}</span> examples in <a href="#fig-labelme" class="quarto-xref">Figure&nbsp;4</a> here below.</p>
<div id="cell-fig-labelme" class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"coast"</span>, <span class="dv">1</span>: <span class="st">"forest"</span>, <span class="dv">2</span>: <span class="st">"highway"</span>, <span class="dv">3</span>: <span class="st">"insidecity"</span>, <span class="dv">4</span>: <span class="st">"mountain"</span>, <span class="dv">5</span>: <span class="st">"opencountry"</span>, <span class="dv">6</span>: <span class="st">"street"</span>, <span class="dv">7</span>: <span class="st">"tallbuilding"</span>}</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(wspace<span class="op">=-</span><span class="fl">0.8</span>, hspace<span class="op">=</span><span class="fl">0.25</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-labelme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-labelme-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Example of images from LabelMe. We display images rowise according to the ground truth label.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-introaggregation" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Aggregation strategies in crowdsourcing</h1>
<p>The first question we address with <code>peerannot</code> is: <em>How to aggregate multiple labels into a single label from crowdsourced tasks?</em> The aggregation step can lead to two types of learnable labels <span class="math inline">\hat y_i\in\Delta_{K}</span> (where <span class="math inline">\Delta_{K}</span> is the simplex of dimension <span class="math inline">K-1</span> : $_{K}={p # cmap = cm.get_cmap(“Blues”)</p>
<p>: _{k=1}^K p_k = 1, p_k }$ ) depending on the use case for each task <span class="math inline">x_i</span>, <span class="math inline">i=1,\dots,n_{\text{task}}</span>:</p>
<ul>
<li>a <strong>hard</strong> label: <span class="math inline">\hat y_i</span> is a Dirac distribution, this can be encoded as a classical label in <span class="math inline">[K]</span>,</li>
<li>a <strong>soft</strong> label: <span class="math inline">\hat y_i\in\Delta_{K}</span> can represent any probability distribution on <span class="math inline">[K]</span>. In that case, each coordinate of the <span class="math inline">K-</span> dimensional vector <span class="math inline">\hat y_i</span> represents the probability to belong to the given class.</li>
</ul>
<p>Learning from soft labels has been shown to improve learning performance and make the classifier learn the task ambiguity <span class="citation" data-cites="zhang2017mixup peterson_human_2019 park2022calibration">(<a href="#ref-zhang2017mixup" role="doc-biblioref">Zhang et al. 2018</a>; <a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>; <a href="#ref-park2022calibration" role="doc-biblioref">Park and Caragea 2022</a>)</span>. However, crowdsourcing is often used as a stepping stone to create a new dataset. We usually expect a classification dataset to associate a task <span class="math inline">x_i</span> to a single label and not a full probability distribution. In this case, we recommend to release the anonymous answered labels and the aggregation strategy used to reach a consensus on a single label. With <code>peerannot</code>, both soft and hard labels can be produced.</p>
<p>Note that when a strategy produces a soft label, a hard label can be easily induced by taking the mode, <em>i.e.</em>, the class achieving the maximum probability.</p>
<p>Moreover, the concept of confusion matrices has been commonly used to represent worker abilities. A confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span> of a worker <span class="math inline">w_j</span> is defined such that <span class="math inline">\pi^{(j)}_{k,\ell} = \mathbb{P}(y_i^{(j)}=\ell\vert y_i^\star=k)</span>.</p>
<div id="cell-fig-confusionmatrix" class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.cm <span class="im">as</span> cm</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">0</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> rng.uniform(<span class="dv">0</span>, <span class="dv">1</span>, (<span class="dv">1</span>, <span class="dv">4</span>))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">/=</span> mat_spammer.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> np.vstack((mat_spammer, mat_spammer))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> np.vstack((mat_spammer, mat_spammer))</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>mat_nearperfect <span class="op">=</span> np.clip(np.eye(<span class="dv">4</span>) <span class="op">+</span> rng.normal(<span class="dv">0</span>, <span class="fl">0.1</span>, (<span class="dv">4</span>,<span class="dv">4</span>)), <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>mat_nearperfect <span class="op">/=</span> np.<span class="bu">sum</span>(mat_nearperfect, axis<span class="op">=</span><span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>mat_common <span class="op">=</span> np.copy(mat_nearperfect)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>mat_common[:, [<span class="dv">0</span>, <span class="dv">1</span>]] <span class="op">=</span> mat_common[:, [<span class="dv">1</span>,<span class="dv">0</span>]]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hinton(matrix, max_weight<span class="op">=</span><span class="va">None</span>, ax<span class="op">=</span><span class="va">None</span>, classes<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>           my_title<span class="op">=</span>{}):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Draw Hinton diagram for visualizing a weight matrix."""</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="cf">if</span> ax <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> plt.gca()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> max_weight:</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        max_weight <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> np.ceil(np.log2(np.<span class="bu">abs</span>(matrix).<span class="bu">max</span>()))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    ax.set_title(my_title, y<span class="op">=</span><span class="fl">1.02</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    ax.patch.set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">"equal"</span>, <span class="st">"box"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    ax.xaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    ax.yaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">"True label"</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"Proposed label"</span>)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(classes))</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(classes))</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    ax.set_xticklabels(classes, rotation<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    ax.set_yticklabels(classes)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    blues <span class="op">=</span> cm.Blues</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    newcolors <span class="op">=</span> blues(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">256</span>))</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x, y), w <span class="kw">in</span> np.ndenumerate(matrix[classes, :][:, classes]):</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> np.searchsorted(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">256</span>), w)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> newcolors[idx]</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        size <span class="op">=</span> (</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>            np.sqrt(<span class="bu">abs</span>(w) <span class="op">/</span> max_weight)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> np.sqrt(<span class="bu">abs</span>(<span class="fl">1e-8</span>) <span class="op">/</span> max_weight)</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> y, x</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle(</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>            [x <span class="op">-</span> size <span class="op">/</span> <span class="fl">2.1</span>, y <span class="op">-</span> size <span class="op">/</span> <span class="fl">2.1</span>],</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>            size,</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>            size,</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>            facecolor<span class="op">=</span>color,</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span><span class="st">'black'</span>,</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>        ax.add_patch(rect)</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    ax.margins(y<span class="op">=</span><span class="fl">0.05</span>, x<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    ax.invert_yaxis()</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>hinton(mat_spammer, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Spammer worker"</span>, ax<span class="op">=</span>axs[<span class="dv">0</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>hinton(mat_common, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Confused worker"</span>, ax<span class="op">=</span>axs[<span class="dv">1</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>hinton(mat_nearperfect, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Expert worker"</span>, ax<span class="op">=</span>axs[<span class="dv">2</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylabel(<span class="st">""</span>)</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].set_ylabel(<span class="st">""</span>)</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-confusionmatrix" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-confusionmatrix-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Three profiles of confusion matrices. The spammer answers independent from the ground truth label. Common workers are good for some classes but might confuse two (ore more) labels. Expert workers are good overall.</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#fig-confusionmatrix" class="quarto-xref">Figure&nbsp;5</a>, we illustrat multiple profiles of workers. In particular, one type of worker that can hurt data quality is the spammer. <span class="citation" data-cites="raykar_ranking_2011">Raykar and Yu (<a href="#ref-raykar_ranking_2011" role="doc-biblioref">2011</a>)</span> defined a spammer as a worker that answers randomly as: <span id="eq-spammer"><span class="math display">
\forall k\in[K],\ \mathbb{P}(y_i^{(j)}=k|y_i^\star) = \mathbb{P}(y_i^{(j)}=k)\enspace.
\tag{3}</span></span></p>
<p>As the probability distribution by row represent the confusion given a ground truth label, the spammer has a confusion matrix with near-identical rows. Apart from the spammer, common mistakes often involve workers ming-up one or several classes. Expert workers have a confusion matrix near the identity matrix.</p>
<section id="classical-models" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="classical-models"><span class="header-section-number">3.1</span> Classical models</h2>
<p>We list below the most classical aggregation strategies used in crowdsourcing.</p>
<section id="majority-vote-mv" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="majority-vote-mv"><span class="header-section-number">3.1.1</span> Majority vote (MV)</h3>
<p>The most intuitive way to create a label from multiple answers for any type of crowdsourced task is to take the majority vote (MV). Yet, this strategy has many shortcomings <span class="citation" data-cites="james1998majority">(<a href="#ref-james1998majority" role="doc-biblioref">James 1998</a>)</span> – there is no noise model, no worker reliability estimated, no task difficulty involved and especially no way to remove poorly performing workers. This standard choice can be expressed as:</p>
<p><span class="math display">
\hat y_i^{\text{MV}} = \operatornamewithlimits{argmax}_{k\in[K]} \sum_{j\in\mathcal{A}(x_i)} \mathbf{1}_{\{y_i^{(j)}=k\}} \enspace.
</span></p>
</section>
<section id="naive-soft-ns" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="naive-soft-ns"><span class="header-section-number">3.1.2</span> Naive soft (NS)</h3>
<p>One pitfall with MV is that the label produced is hard, hence the ambiguity is discarded by construction. To remedy this, the Naive Soft (NS) labeling consists in using the empirical distribution as the task label:</p>
<p><span class="math display">
\hat y_i^{\text{NS}} = \bigg(\frac{1}{\vert\mathcal{A}(x_i)\vert}\sum_{j\in\mathcal{A}(x_i)} \mathbf{1}_{\{y_i^{(j)}=k\}} \bigg)_{j\in[K]} \enspace.
</span> With the NS label, we keep the ambiguity, but all workers and all tasks are put on the same level. In practice, it is known that each worker comes with their abilities, thus modeling this knowledge can produce better results.</p>
</section>
<section id="dawid-and-skene-ds" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="dawid-and-skene-ds"><span class="header-section-number">3.1.3</span> Dawid and Skene (DS)</h3>
<p>Refining the aggregation, researchers began creating a noise model to take into account the workers’ abilities. These types of models are most often optimized using EM-based procedures and one of the most studied <span class="citation" data-cites="gao2013minimax">(<a href="#ref-gao2013minimax" role="doc-biblioref">Gao and Zhou 2013</a>)</span> and applied <span class="citation" data-cites="servajean2017crowdsourcing rodrigues2018deep">(<a href="#ref-servajean2017crowdsourcing" role="doc-biblioref">Servajean et al. 2017</a>; <a href="#ref-rodrigues2018deep" role="doc-biblioref">Rodrigues and Pereira 2018</a>)</span> is the Dawid and Skene’s (DS) model <span class="citation" data-cites="dawid_maximum_1979">(<a href="#ref-dawid_maximum_1979" role="doc-biblioref">Dawid and Skene 1979</a>)</span>. Assuming the workers are answering tasks independently, this model boils down to model pairwise confusions between each possible class. Each worker <span class="math inline">w_j</span> is assigned a confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span> as described in <a href="#sec-introaggregation" class="quarto-xref">Section&nbsp;3</a>. The model assumes that for a task <span class="math inline">x_i</span>, conditionally on the true label <span class="math inline">y_i^\star=k</span> the label distribution of the worker’s answer follows a multinomial distribution with probabilities <span class="math inline">\pi^{(j)}_{k,\cdot}</span> for each worker. Each class has a prevalence <span class="math inline">\rho_k=\mathbb{P}(y_i^\star=k)</span> to appear in the dataset. Using the independence between workers, we obtain the following likelihood to maximize (with latent variables <span class="math inline">\rho</span>, <span class="math inline">\{\pi^{(j)}\}_{j}</span> and <span class="math inline">T</span> and observed variables <span class="math inline">\{y_i^{(j)}\}_{i,j}</span>):</p>
<p><span class="math display">
\displaystyle\prod_{i\in [n_{\texttt{task}}]}\prod_{k \in [K]}\bigg[\rho_k\prod_{j\in [n_{\texttt{worker}}]}
    \prod_{k\in [K]}\big(\pi^{(j)}_{k, k}\big)^{\mathbf{1}_{\{y_i^{(j)}=k\}}}
    \bigg]^{T_{i,k}},
</span></p>
<p>with <span class="math inline">T_{i,k}=\mathbf{1}_{\{y_i^{\star}=k \}}</span>. The final aggregated soft label is <span class="math inline">\hat y_i^{\text{DS}} = T_{i,\cdot}</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figures/bayesien_plaque_ds.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Bayesian <a href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a> for the DS model</figcaption>
</figure>
</div>
</section>
<section id="variations-around-the-ds-model" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="variations-around-the-ds-model"><span class="header-section-number">3.1.4</span> Variations around the DS model</h3>
<p>Many variants of the DS model have been proposed in the literature, using Dirichlet priors on the confusion matrices <span class="citation" data-cites="passonneau-carpenter-2014-benefits">(<a href="#ref-passonneau-carpenter-2014-benefits" role="doc-biblioref">Passonneau and Carpenter 2014</a>)</span>, using <span class="math inline">1\leq L\leq n_{\text{worker}}</span> clusters of workers <span class="citation" data-cites="imamura2018analysis">(<a href="#ref-imamura2018analysis" role="doc-biblioref">Imamura, Sato, and Sugiyama 2018</a>)</span> (DSWC) or even faster implementation that produces only hard labels <span class="citation" data-cites="sinha2018fast">(<a href="#ref-sinha2018fast" role="doc-biblioref">Sinha, Rao, and Balasubramanian 2018</a>)</span>.</p>
<p>In particular, the DSWC strategy (Dawid and Skene with Worker Clustering) highly reduces the dimension of the parameters in the DS model. In the original model, there are <span class="math inline">K^2\times n_{\text{worker}}</span> parameters to be estimated for the confusion matrices only. The DSWC model reduces them to <span class="math inline">K^2\times L + L</span> parameters. Indeed, there are <span class="math inline">L</span> confusion matrices <span class="math inline">\{\Lambda_1,\dots,\Lambda_L\}</span> and the confusion matrix of a cluster is assumed drawn from a multinomial distribution with weights <span class="math inline">(\tau_1,\dots,\tau_L)</span>, such that <span class="math inline">\mathbb{P}(\pi^{(j)}=\Lambda_\ell)=\tau_\ell</span>.</p>
</section>
<section id="generative-model-of-labels-abilities-and-difficulties-glad" class="level3" data-number="3.1.5">
<h3 data-number="3.1.5" class="anchored" data-anchor-id="generative-model-of-labels-abilities-and-difficulties-glad"><span class="header-section-number">3.1.5</span> Generative model of Labels, Abilities, and Difficulties (GLAD)</h3>
<p>Finally, we present the GLAD model <span class="citation" data-cites="whitehill_whose_2009">(<a href="#ref-whitehill_whose_2009" role="doc-biblioref">Whitehill et al. 2009</a>)</span> that not only takes into account the worker’s ability, but also the task difficulty in the noise model. The likelihood is optimized using an EM algorithm to recover the soft label <span class="math inline">\hat y_i^{\text{GLAD}}</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figures/schema_bayesien_glad.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Bayesian <a href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a> for the GLAD model</figcaption>
</figure>
</div>
<p>Denoting <span class="math inline">\alpha_j\in\mathbb{R}</span> the worker ability (the higher the better) and <span class="math inline">\beta_i\in\mathbb{R}^+_\star</span> the task’s difficulty (the higher the easier), the model noise is:</p>
<p><span class="math display">
\mathbb{P}(y_i^{(j)}=y_i^\star\vert \alpha_j,\beta_i) = \frac{1}{1+\exp(-\alpha_j\beta_i)} \enspace.
</span> GLAD’s model also assumes that the errors are uniform across wrong labels, thus: <span class="math display">
\forall k \in [K],\ \mathbb{P}(y_i^{(j)}=k\vert y_i^\star\neq k,\alpha_j,\beta_i) = \frac{1}{K-1}\left(1-\frac{1}{1+\exp(-\alpha_j\beta_i)}\right)\enspace.
</span></p>
</section>
<section id="aggregation-strategies-in-peerannot" class="level3" data-number="3.1.6">
<h3 data-number="3.1.6" class="anchored" data-anchor-id="aggregation-strategies-in-peerannot"><span class="header-section-number">3.1.6</span> Aggregation strategies in <code>peerannot</code></h3>
<p>All of these aggregation strategies – and more – are available in the <code>peerannot</code> library from the <code>peerannot.models</code> module. Each model is a class object in its own <code>Python</code> file. It inherits from the <code>CrowdModel</code> template class and is defined with at least two methods:</p>
<ul>
<li><code>run</code>: includes the optimization procedure to obtain needed weights (<em>e.g.</em> the EM algorithm for the DS model),</li>
<li><code>get_probas</code>: returns the soft labels output for each task.</li>
</ul>
</section>
</section>
<section id="sec-evaluation-aggregation" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-evaluation-aggregation"><span class="header-section-number">3.2</span> Experiments and evaluation of label aggregation strategies</h2>
<p>One way to evaluate the label aggregation strategies is to measure their accuracy. This means that the underlying ground truth must be known – or at least for a representative subset. As the set of <span class="math inline">n_{\text{task}}</span> can be seen as a training set for a future classifier, we denote this metric <span class="math inline">\operatornamewithlimits{AccTrain}</span> on a dataset <span class="math inline">\mathcal{D}</span> for some given aggregated label <span class="math inline">(\hat y_i)_i</span> as:</p>
<p><span class="math display">
\operatornamewithlimits{AccTrain}(\mathcal{D}) = \frac{1}{\vert \mathcal{D}\vert}\sum_{i=1}^{\vert\mathcal{D}\vert} \mathbf{1}_{\{y_i^\star=\operatornamewithlimits{argmax}_{k\in[K]}\hat y_i\}} \enspace.
</span></p>
<p>In the following, we write <span class="math inline">\operatornamewithlimits{AccTrain}</span> for <span class="math inline">\operatornamewithlimits{AccTrain}(\mathcal{D}_{\text{train}})</span> as we only consider the full training set so there is no ambiguity. While this metric is useful, in practice there are a few arguable issues:</p>
<ul>
<li>the <span class="math inline">\operatornamewithlimits{AccTrain}</span> metric does not consider the ambiguity of the soft label, only the most probable class, whereas in some contexts ambiguity can be informative,</li>
<li>in supervised learning one objective is to identify difficult or mislabeled tasks <span class="citation" data-cites="pleiss_identifying_2020 lefort2022improve">(<a href="#ref-pleiss_identifying_2020" role="doc-biblioref">Pleiss et al. 2020</a>; <a href="#ref-lefort2022improve" role="doc-biblioref">Lefort et al. 2022</a>)</span>, pruning those tasks can easily artificially improve the <span class="math inline">\operatornamewithlimits{AccTrain}</span>, but there is no guarantee over the predictive performance of a model based on the newly pruned dataset,</li>
<li>in practice, ground truth labels are unknown, thus this metric would not be computable.</li>
</ul>
<p>We first consider classical simulation settings in the literature that can easily be created and reproduced using <code>peerannot</code>. For each dataset, we present the distribution of the number of workers per task <span class="math inline">(|\mathcal{A}(x_i)|)_i</span> <a href="#eq-workerset" class="quarto-xref">Equation&nbsp;1</a> on the right and the distribution of the number of tasks per worker <span class="math inline">(|\mathcal{T}(w_j)|)_j</span> <a href="#eq-taskset" class="quarto-xref">Equation&nbsp;2</a> on the left.</p>
<section id="sec-simu-independent" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="sec-simu-independent"><span class="header-section-number">3.2.1</span> Simulated independent mistakes simu-independent</h3>
<p>The independent mistakes consider that each worker <span class="math inline">w_j</span> answers follows a multinomial distribution with weights given at the row <span class="math inline">y_i^\star</span> of their confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span>. Each confusion row in the confusion matrix is generated uniformly in the simplex. Then, we make the matrix diagonally dominant (to represent non-adversarial workers) by switching the diagonal term with the maximum value by row. Answers are independent of one another as each matrix is generated independently and each worker answers independently of other workers. In this setting, the DS model is expected to perform better with enough data as we are simulating data from its assumed noise model.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=200</span> tasks and <span class="math inline">n_{\text{worker}}=30</span> workers with <span class="math inline">K=5</span> possible classes. Each task <span class="math inline">x_i</span> receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels. With <span class="math inline">200</span> tasks and <span class="math inline">30</span> workers, asking for <span class="math inline">10</span> leads to around <span class="math inline">\frac{200\times 10}{30}\simeq 67</span> tasks per worker (with variations due to randomness in the affectations).</p>
<div id="1b313a28" class="cell" data-execution_count="5">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c71cab98" class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> peerannot.helpers.helpers_visu <span class="im">import</span> feedback_effort, working_load</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> MaxNLocator</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-7-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div id="0ef59a56" class="cell" data-execution_count="7">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent"</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_3b92a th {
  text-align: center;
}
#T_3b92a_row0_col0, #T_3b92a_row0_col1, #T_3b92a_row0_col2, #T_3b92a_row0_col3, #T_3b92a_row0_col4, #T_3b92a_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-independent" class="anchored">
<table id="T_3b92a" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;1: AccTrain metric on simulated independent mistakes considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_3b92a_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_3b92a_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_3b92a_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_3b92a_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_3b92a_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=5]</th>
<th id="T_3b92a_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=10]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_3b92a_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_3b92a_row0_col0" class="data row0 col0">0.785</td>
<td id="T_3b92a_row0_col1" class="data row0 col1">0.760</td>
<td id="T_3b92a_row0_col2" class="data row0 col2">0.780</td>
<td id="T_3b92a_row0_col3" class="data row0 col3">0.890</td>
<td id="T_3b92a_row0_col4" class="data row0 col4">0.775</td>
<td id="T_3b92a_row0_col5" class="data row0 col5">0.770</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>As expected by the simulation framework, <a href="#tbl-simu-independent" class="quarto-xref">Table&nbsp;1</a> fits the DS model, thus leading to better accuracy to retrieve the simulated labels for the DS model. The MV aggregation does not consider any worker-ability scoring or the task’s difficulty and performs the worse.</p>
<p><strong>Remark.</strong> <code>peerannot</code> can also simulate datasets with an imbalanced number of votes chosen uniformly at random between <span class="math inline">1</span> and the number of workers available). For example:</p>
<div id="0ac10d9d" class="cell" data-execution_count="9">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>imbalance<span class="op">-</span>votes <span class="op">\</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">-</span>imbalanced<span class="op">/</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="14df5735" class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-11-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div id="b724d6b0" class="cell" data-execution_count="11">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">-</span>imbalanced<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_1db36 th {
  text-align: center;
}
#T_1db36_row0_col0, #T_1db36_row0_col1, #T_1db36_row0_col2, #T_1db36_row0_col3, #T_1db36_row0_col4, #T_1db36_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-independent-imb" class="anchored">
<table id="T_1db36" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;2: AccTrain metric on simulated independent mistakes with an imbalanced number of votes per task considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_1db36_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_1db36_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_1db36_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_1db36_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_1db36_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=5]</th>
<th id="T_1db36_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=10]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_1db36_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_1db36_row0_col0" class="data row0 col0">0.795</td>
<td id="T_1db36_row0_col1" class="data row0 col1">0.830</td>
<td id="T_1db36_row0_col2" class="data row0 col2">0.810</td>
<td id="T_1db36_row0_col3" class="data row0 col3">0.895</td>
<td id="T_1db36_row0_col4" class="data row0 col4">0.845</td>
<td id="T_1db36_row0_col5" class="data row0 col5">0.840</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>While more realistic, working with an imbalanced number of votes per task can lead to disrupting orders of performance for some strategies (here GLAD is downgraded).</p>
</section>
<section id="simulated-correlated-mistakes" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="simulated-correlated-mistakes"><span class="header-section-number">3.2.2</span> Simulated correlated mistakes</h3>
<p>The correlated mistakes are also known as the student-teacher setting. Consider that the crowd of workers is divided into two categories: teachers and students (with <span class="math inline">n_{\text{teacher}} + n_{\text{student}}=n_{\text{worker}}</span>). Each student is randomly assigned to one teacher at the beginning of the experiment. We generate the (diagonally dominant as in <a href="#sec-simu-independent" class="quarto-xref">Section&nbsp;3.2.1</a>) confusion matrices of each teacher and the the student share the same confusion matrix as their associated teacher. Hence, clustering strategies are expected to perform best in this context. Then, they all answer independently, following a multinomial distribution with weights given at the row <span class="math inline">y_i^\star</span> of their confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span>.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=200</span> tasks and <span class="math inline">n_{\text{worker}}=30</span> with <span class="math inline">80\%</span> of students in the crowd. There are <span class="math inline">K=5</span> possible classes. Each task receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels.</p>
<div id="0f500855" class="cell" data-execution_count="13">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy student<span class="op">-</span>teacher <span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.8</span> <span class="op">\</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>student_teacher</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a7d78cfe" class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-15-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div id="91d24369" class="cell" data-execution_count="15">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>student_teacher<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"student_teacher"</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_student-teacher_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_437a3 th {
  text-align: center;
}
#T_437a3_row0_col0, #T_437a3_row0_col1, #T_437a3_row0_col2, #T_437a3_row0_col3, #T_437a3_row0_col4, #T_437a3_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-corr" class="anchored">
<table id="T_437a3" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;3: AccTrain metric on simulated correlated mistakes considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_437a3_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_437a3_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_437a3_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_437a3_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_437a3_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=5]</th>
<th id="T_437a3_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=10]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_437a3_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_437a3_row0_col0" class="data row0 col0">0.720</td>
<td id="T_437a3_row0_col1" class="data row0 col1">0.690</td>
<td id="T_437a3_row0_col2" class="data row0 col2">0.645</td>
<td id="T_437a3_row0_col3" class="data row0 col3">0.755</td>
<td id="T_437a3_row0_col4" class="data row0 col4">0.795</td>
<td id="T_437a3_row0_col5" class="data row0 col5">0.815</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>With <a href="#tbl-simu-corr" class="quarto-xref">Table&nbsp;3</a>, we see that with correlated data (<span class="math inline">24</span> students and <span class="math inline">6</span> teachers), using <span class="math inline">5</span> confusion matrices with DSWC[L=5] outperforms the vanilla DS strategy that does not consider the correlations. And the best-performing method here estimates only <span class="math inline">10</span> confusion matrices (instead of <span class="math inline">30</span> for the vanilla DS model).</p>
</section>
<section id="simulated-mistakes-with-discrete-difficulty-levels-on-tasks" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="simulated-mistakes-with-discrete-difficulty-levels-on-tasks"><span class="header-section-number">3.2.3</span> Simulated mistakes with discrete difficulty levels on tasks</h3>
<p>For the final simulation setting, we consider the so called discrete difficulty presented in <span class="citation" data-cites="whitehill_whose_2009">Whitehill et al. (<a href="#ref-whitehill_whose_2009" role="doc-biblioref">2009</a>)</span>. Contrary to other simulations, we here consider that workers belong to two levels of abilities: or , and tasks have two levels of difficulty: or . The keyword <code>ratio-diff</code> indicates the prevalence of each level of difficulty, it is defined as the ratio of tasks over tasks:</p>
<p><span class="math display">
\texttt{ratio-diff} = \frac{\mathbb{P}(\texttt{easy})}{\mathbb{P}(\texttt{hard})} \text{ with } \mathbb{P}(\texttt{easy}) +\mathbb{P}(\texttt{hard}) = 1 \enspace.
</span></p>
<p>Difficulties are then drawn <a href="https://peerannot.github.io/datasets/simulate_discrete_difficulty/">at random</a>. Tasks that are are answered correctly by every worker. Tasks that are are answered following the confusion matrix assigned to each worker. Each worker then answers independently to the presented tasks.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=500</span> tasks and <span class="math inline">n_{\text{worker}}=100</span> with <span class="math inline">35\%</span> of good workers in the crowd and <span class="math inline">50\%</span> of easy tasks. There are <span class="math inline">K=5</span> possible classes. Each task receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels.</p>
<div id="647edbb1" class="cell" data-execution_count="17">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy discrete<span class="op">-</span>difficulty <span class="op">\</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.35</span> <span class="op">--</span>ratio<span class="op">-</span>diff <span class="dv">1</span> <span class="op">\</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback <span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="36c9be49" class="cell" data-execution_count="18">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-19-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div id="dc059a2c" class="cell" data-execution_count="19">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=2]"</span>, <span class="st">"DSWC[L=5]"</span>]:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="20">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=2]"</span>: [], <span class="st">"dswc[l=5]"</span>: []}</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_discrete-difficulty_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_33d84 th {
  text-align: center;
}
#T_33d84_row0_col0, #T_33d84_row0_col1, #T_33d84_row0_col2, #T_33d84_row0_col3, #T_33d84_row0_col4, #T_33d84_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-discrete-diff" class="anchored">
<table id="T_33d84" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;4: AccTrain metric on simulated mistakes when tasks are associated a difficulty level considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_33d84_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_33d84_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_33d84_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_33d84_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_33d84_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=2]</th>
<th id="T_33d84_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=5]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_33d84_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_33d84_row0_col0" class="data row0 col0">0.820</td>
<td id="T_33d84_row0_col1" class="data row0 col1">0.790</td>
<td id="T_33d84_row0_col2" class="data row0 col2">0.845</td>
<td id="T_33d84_row0_col3" class="data row0 col3">0.810</td>
<td id="T_33d84_row0_col4" class="data row0 col4">0.600</td>
<td id="T_33d84_row0_col5" class="data row0 col5">0.660</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Finally, in this setting involving task difficulty coefficients, the only strategy that involves a latent variable for the task difficulty, knowing GLAD, outperforms the other strategies (see <a href="#tbl-simu-discrete-diff" class="quarto-xref">Table&nbsp;4</a>). Note that in this case, creating clusters of answers leads to worse decisions than an MV aggregation.</p>
<p>To summarize our simulations, we see that depending on workers answering strategies, different latent variable models perform best. However, these are unknown outside of a simulation framework, thus if we want to obtain labels from multiple responses, we need to investigate multiple models. This can be done easily with <code>peerannot</code> as we demonstrated using the <code>aggregate</code> module. However, one might not want to generate a label, simply learn a classifier to predict labels on unseen data. This leads us to another module part of <code>peerannot</code>.</p>
</section>
</section>
</section>
<section id="learning-from-crowdsourced-tasks" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Learning from crowdsourced tasks</h1>
<p>Most often, tasks are crowdsourced to create a large training set as modern machine learning models require more and more data. The aggregation step then simply becomes the first step in the complete learning pipeline. However, instead of aggregating labels, modern neural networks are directly trained end-to-end from multiple noisy labels.</p>
<section id="popular-models" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="popular-models"><span class="header-section-number">4.1</span> Popular models</h2>
<p>In recent years, directly learning a classifier from noisy labels was introduced. Two of the most used models: CrowdLayer <span class="citation" data-cites="rodrigues2018deep">(<a href="#ref-rodrigues2018deep" role="doc-biblioref">Rodrigues and Pereira 2018</a>)</span> and CoNAL <span class="citation" data-cites="chu2021learning">(<a href="#ref-chu2021learning" role="doc-biblioref">Chu, Ma, and Wang 2021</a>)</span>, are directly available in <code>peerannot</code>. These two learning strategies directly incorporate a DS-based noise model in the neural network’s architecture.</p>
<section id="crowdlayer" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="crowdlayer"><span class="header-section-number">4.1.1</span> CrowdLayer</h3>
<p><a href="https://github.com/peerannot/peerannot/blob/main/peerannot/models/agg_deep/Crowdlayer.py">CrowdLayer</a> trains a classifier with noisy labels as follows. Let the scores (logits) output by a given classifier neural network <span class="math inline">\mathcal{C}</span> be <span class="math inline">z_i=\mathcal{C}(x_i)</span>. Then CrowdLayer adds as a last layer <span class="math inline">\pi\in\mathbb{R}^{n_{\text{worker}}\times K\times K}</span>, the tensor of all <span class="math inline">\pi^{(j)}</span>’s such that the crossentropy loss <span class="math inline">(\mathrm{CE})</span> is adapted to the crowdsourcing setting into <span class="math inline">\mathcal{L}_{CE}^{\text{CrowdLayer}}</span> and computed as:</p>
<p><span class="math display">
\mathcal{L}_{CE}^{\text{CrowdLayer}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(\sigma\left(\pi^{(j)}\sigma\big(z_i\big)\right), y_i^{(j)}) \enspace,
</span></p>
<p>where the crossentropy loss for two distribution <span class="math inline">u,v \in\Delta_{K}</span> is defined as <span class="math inline">\mathrm{CE}(u, v) = \sum_{k\in[K]} u_k\log(v_k)</span>.</p>
<p>The confusion matrices are taken into the network architecture as a new layer to transform the output probabilities. The backbone classifier predicts a distribution that is then corrupted through the added layer to learn the worker-specific confusion.</p>
</section>
<section id="conal" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="conal"><span class="header-section-number">4.1.2</span> CoNAL</h3>
<p>For some datasets, it was noticed that global confusion occurs between the proposed classes. It is the case for example in the <span class="math inline">\texttt{LabelMe}</span> dataset <span class="citation" data-cites="rodrigues2017learning">(<a href="#ref-rodrigues2017learning" role="doc-biblioref">Rodrigues et al. 2017</a>)</span> where classes overlap. In this case, <span class="citation" data-cites="chu2021learning">Chu, Ma, and Wang (<a href="#ref-chu2021learning" role="doc-biblioref">2021</a>)</span> proposed to extend the CrowdLayer model by adding global confusion matrix <span class="math inline">\pi^g\in\mathbb{R}^{K\times K}</span> to the model on top of each worker’s confusion.</p>
<!-- ![Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for CoNAL model. Each worker is assigned a confusion matrix $\pi^{(j)}$. A global confusion matrix $\pi^g$ is shared between workers. A tradeoff between the global confusion and the local one is applied.](./figures/schema_bayesien_conal.png){#fig-conal fig-align="center"} -->
<p>Given the output <span class="math inline">z_i=\mathcal{C}(x_i)\in\mathbb{R}^K</span> of a given classifier and task, <a href="https://github.com/peerannot/peerannot/blob/main/peerannot/models/agg_deep/CoNAL.py">CoNAL</a> interpolates between the local confusion <span class="math inline">\pi^{(j)}z_i</span> and the global one <span class="math inline">\pi^gz_i</span>. The loss function is computed as follows: <span class="math display">
\begin{aligned}
&amp;\mathcal{L}_{CE}^{\text{CoNAL}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(h_i^{(j)}, y_i^{(j)}) \enspace, \\
&amp;\text{with } h_i^{(j)} = \sigma\left(\big(\omega_i^{(j)} \pi^g + (1-\omega_i^{(j)})\pi^{(j)}\big)z_i\right) \enspace.
\end{aligned} \
</span></p>
<p>The interpolation weight <span class="math inline">\omega_i^{(j)}</span> is unobservable in practice. So, to compute <span class="math inline">h_i^{(j)}</span>, the weight is obtained through an auxiliary network. This network takes in input the image and worker information and outputs a task-related vector <span class="math inline">v_i</span> and a worker-related vector <span class="math inline">u_j</span> of the same dimension. Finally, <span class="math inline">w_i^{(j)}=(1+\exp(- u_j^\top v_i))^{-1}</span>.</p>
<p>Both CrowdLayer and CoNAL model worker confusions directly in the classifier’s weights to learn from the noisy collected labels and are available in <code>peerannot</code> as we will see in the following.</p>
</section>
</section>
<section id="prediction-error-when-learning-from-crowdsourced-tasks" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="prediction-error-when-learning-from-crowdsourced-tasks"><span class="header-section-number">4.2</span> Prediction error when learning from crowdsourced tasks</h2>
<p>The <span class="math inline">\mathrm{AccTrain}</span> metric presented in <a href="#sec-evaluation-aggregation" class="quarto-xref">Section&nbsp;3.2</a> might no longer be of interest when training a classifier. Classical error measurements involve a test dataset to estimate the generalization error. To do so, we present hereafter two error metrics. Assuming we trained our classifier <span class="math inline">f_\theta</span> on a training set:</p>
<ul>
<li>the test accuracy is computed as <span class="math inline">\frac{1}{n_{\text{test}}}\sum_{i=1}^{n_{\text{test}}}\mathbf{1}_{\{y_i^\star = \widehat{f_\theta(x_i)}\}}</span></li>
<li>the expected calibration error <span class="citation" data-cites="guo_calibration_2017">(<a href="#ref-guo_calibration_2017" role="doc-biblioref">Guo et al. 2017</a>)</span> over <span class="math inline">M</span> equally spaced bins <span class="math inline">I_1,\dots,I_M</span> partitionning the interval <span class="math inline">[0,1]</span>, is computed as: <span class="math display">
\mathrm{ECE} = \sum_{m=1}^M \frac{|B_m|}{n_{\text{task}}}|\mathrm{acc}(B_m) - \mathrm{conf}(B_m)|\enspace,
</span> with <span class="math inline">B_m=\{x_i| \mathcal{C}(x_i)_{[1]}\in I_m\}</span> the tasks with predicted probability in the <span class="math inline">m</span>-th bin, <span class="math inline">\mathrm{acc}(B_m)</span> the accuracy of the network for the samples in <span class="math inline">B_m</span> and <span class="math inline">\mathrm{conf}(B_m)</span> the associated empirical confidence. More precisely: <span class="math display">
\mathrm{acc}(B_m) = \frac{1}{|B_m|}\sum_{i\in B_m} \mathbf{1}(\hat y_i=y_i^\star)\quad \text{and} \quad \mathrm{conf}(B_m) = \frac{1}{|B_m|}\sum_{i\in B_m} \sigma(\mathcal{C}(x_i)_{[1]})\enspace.
</span></li>
</ul>
<p>The accuracy represents how well the classifier generalizes, and the expected calibration error (ECE) quantifies the deviation between the accuracy and the confidence of the classifier. Modern neural networks are known to often be overconfident in their predictions <span class="citation" data-cites="guo_calibration_2017">(<a href="#ref-guo_calibration_2017" role="doc-biblioref">Guo et al. 2017</a>)</span>. However, it has also been remarked that training on crowdsourced data, depending on the strategy, mitigates this confidence issue. That is why we propose to compare them both in our coming experiments. Note that the ECE error estimator is known to be biased <span class="citation" data-cites="gruber2022better">(<a href="#ref-gruber2022better" role="doc-biblioref">Gruber and Buettner 2022</a>)</span>. Smaller training sets are known to have a higher ECE estimation error. And in the crowdsourcing setting, openly available datasets are often quite small.</p>
</section>
<section id="sec-real-datasets" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-real-datasets"><span class="header-section-number">4.3</span> Use case with <code>peerannot</code> on real datasets</h2>
<p>Few real crowdsourcing experiments have been released publicly. Among the available ones, <span class="math inline">\texttt{CIFAR-10H}</span> <span class="citation" data-cites="peterson_human_2019">(<a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>)</span> is one of the largest with <span class="math inline">10 000</span> tasks labeled by workers (the testing set of CIFAR-10). The main limitation of <span class="math inline">\texttt{CIFAR-10H}</span> is that there are few disagreements between workers and a simple majority voting already leads to a near-perfect <span class="math inline">\mathrm{AccTrain}</span> error. Hence, comparing the impact of aggregation and end-to-end strategies might not be relevant <span class="citation" data-cites="peterson_human_2019 aitchison2020statistical">(<a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>; <a href="#ref-aitchison2020statistical" role="doc-biblioref">Aitchison 2021</a>)</span>, it is however a good benchmark for task difficulty identification and worker evaluation scoring</p>
<p>The <span class="math inline">\texttt{LabelMe}</span> dataset was extracted from crowdsourcing segmentation experiments and a subset of <span class="math inline">K=8</span> classes was released in <span class="citation" data-cites="rodrigues2017learning">Rodrigues et al. (<a href="#ref-rodrigues2017learning" role="doc-biblioref">2017</a>)</span>.</p>
<p>Let us use <code>peerannot</code> to train a VGG-16 with two dense layers on the <span class="math inline">\texttt{LabelMe}</span> dataset. Note that this modification was introduced to reach state-of-the-art performance in <span class="citation" data-cites="chu2021learning">(<a href="#ref-chu2021learning" role="doc-biblioref">Chu, Ma, and Wang 2021</a>)</span>. Other models from the <code>torchvision</code> library can be used, such as Resnets, Alexnet <em>etc.</em></p>
<div id="7a35c798" class="cell" data-execution_count="21">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>]:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>labalme<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot train .<span class="op">/</span>labelme <span class="op">-</span>o labelme_${strat} <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>labels<span class="op">=</span>.<span class="op">/</span>labelme<span class="op">/</span>labels<span class="op">/</span>labels_labelme_${strat}.npy <span class="op">--</span>model modellabelme <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">500</span> <span class="op">-</span>m <span class="dv">50</span> <span class="op">-</span>m <span class="dv">150</span> <span class="op">-</span>m <span class="dv">250</span> <span class="op">--</span>scheduler<span class="op">=</span>multistep <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>num<span class="op">-</span>workers<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>pretrained <span class="op">--</span>data<span class="op">-</span>augmentation <span class="op">--</span>optimizer<span class="op">=</span>adam <span class="op">--</span>batch<span class="op">-</span>size<span class="op">=</span><span class="dv">32</span> <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">224</span> <span class="op">--</span>seed<span class="op">=</span><span class="dv">1</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"CrowdLayer"</span>, <span class="st">"CoNAL[scale=0]"</span>, <span class="st">"CoNAL[scale=1e-4]"</span>]:</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate<span class="op">-</span>deep .<span class="op">/</span> <span class="op">-</span>o labelme_${strat} <span class="op">--</span>answers .<span class="op">/</span>labelme<span class="op">/</span>answers.json <span class="op">-</span>s ${strat} <span class="op">--</span>model modellabelme <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">224</span> <span class="op">--</span>pretrained <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>n<span class="op">-</span>epochs<span class="op">=</span><span class="dv">500</span> <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.001</span> <span class="op">-</span>m <span class="dv">300</span> <span class="op">-</span>m <span class="dv">400</span> <span class="op">--</span>scheduler<span class="op">=</span>multistep <span class="op">--</span>batch<span class="op">-</span>size<span class="op">=</span><span class="dv">228</span> <span class="op">--</span>optimizer<span class="op">=</span>adam <span class="op">--</span>num<span class="op">-</span>workers<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>data<span class="op">-</span>augmentation <span class="op">--</span>seed<span class="op">=</span><span class="dv">1</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># command to save separately a specific part of conal model (memory intensive otherwise)</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>best_conal <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4].pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>torch.save(best_conal[<span class="st">"noise_adaptation"</span>][<span class="st">"local_confusion_matrices"</span>], path_ <span class="op">/</span> <span class="st">"best_models"</span><span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4]_local_confusion.pth"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="22">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highlight_max(s, props<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(s <span class="op">==</span> np.nanmax(s.values), props, <span class="st">''</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highlight_min(s, props<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(s <span class="op">==</span> np.nanmin(s.values), props, <span class="st">''</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>dir_results <span class="op">=</span> Path().cwd() <span class="op">/</span> <span class="st">'datasets'</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"results"</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>meth, accuracy, ece <span class="op">=</span> [], [], []</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> res <span class="kw">in</span> dir_results.glob(<span class="st">"modellabelme/*"</span>):</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  filename <span class="op">=</span> res.stem</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  _, mm <span class="op">=</span> filename.split(<span class="st">"_"</span>)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  meth.append(mm)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> <span class="bu">open</span>(res, <span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    dd <span class="op">=</span> json.load(f)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    accuracy.append(dd[<span class="st">"test_accuracy"</span>])</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    ece.append(dd[<span class="st">"test_ece"</span>])</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(<span class="bu">zip</span>(meth, accuracy, ece)), columns<span class="op">=</span>[<span class="st">"method"</span>, <span class="st">"AccTest"</span>, <span class="st">"ECE"</span>])</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"method"</span>] <span class="op">=</span> results[<span class="st">"method"</span>].<span class="bu">str</span>.upper()</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.sort_values(by<span class="op">=</span><span class="st">"AccTest"</span>, ascending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>results.reset_index(drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>results.<span class="bu">apply</span>(highlight_max, props<span class="op">=</span><span class="st">'background-color:#e6ffe6;'</span>, axis<span class="op">=</span><span class="dv">0</span>, subset<span class="op">=</span>[<span class="st">"AccTest"</span>])</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>results.<span class="bu">apply</span>(highlight_min, props<span class="op">=</span><span class="st">'background-color:#e6ffe6;'</span>, axis<span class="op">=</span><span class="dv">0</span>, subset<span class="op">=</span>[<span class="st">"ECE"</span>])</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_8c357 th {
  text-align: center;
}
#T_8c357_row0_col0, #T_8c357_row0_col1, #T_8c357_row0_col2, #T_8c357_row1_col0, #T_8c357_row1_col1, #T_8c357_row1_col2, #T_8c357_row2_col0, #T_8c357_row2_col1, #T_8c357_row2_col2, #T_8c357_row3_col0, #T_8c357_row3_col1, #T_8c357_row3_col2, #T_8c357_row4_col0, #T_8c357_row4_col1, #T_8c357_row4_col2, #T_8c357_row5_col0, #T_8c357_row5_col1, #T_8c357_row5_col2, #T_8c357_row6_col0 {
  text-align: center;
}
#T_8c357_row6_col1, #T_8c357_row6_col2 {
  text-align: center;
  background-color: #e6ffe6;
}
</style>

<div id="tbl-perf-labelme" class="anchored">
<table id="T_8c357" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;5: Generalization performance on LabelMe dataset depending on the learning strategy from the crowdsourced labels. The network used is a VGG-16 with two dense layers.</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_8c357_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">method</th>
<th id="T_8c357_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">AccTest</th>
<th id="T_8c357_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">ECE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_8c357_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">0</td>
<td id="T_8c357_row0_col0" class="data row0 col0">DS</td>
<td id="T_8c357_row0_col1" class="data row0 col1">81.061</td>
<td id="T_8c357_row0_col2" class="data row0 col2">0.189</td>
</tr>
<tr class="even">
<td id="T_8c357_level0_row1" class="row_heading level0 row1" data-quarto-table-cell-role="th">1</td>
<td id="T_8c357_row1_col0" class="data row1 col0">MV</td>
<td id="T_8c357_row1_col1" class="data row1 col1">85.606</td>
<td id="T_8c357_row1_col2" class="data row1 col2">0.143</td>
</tr>
<tr class="odd">
<td id="T_8c357_level0_row2" class="row_heading level0 row2" data-quarto-table-cell-role="th">2</td>
<td id="T_8c357_row2_col0" class="data row2 col0">NAIVESOFT</td>
<td id="T_8c357_row2_col1" class="data row2 col1">86.448</td>
<td id="T_8c357_row2_col2" class="data row2 col2">0.136</td>
</tr>
<tr class="even">
<td id="T_8c357_level0_row3" class="row_heading level0 row3" data-quarto-table-cell-role="th">3</td>
<td id="T_8c357_row3_col0" class="data row3 col0">CROWDLAYER</td>
<td id="T_8c357_row3_col1" class="data row3 col1">87.205</td>
<td id="T_8c357_row3_col2" class="data row3 col2">0.117</td>
</tr>
<tr class="odd">
<td id="T_8c357_level0_row4" class="row_heading level0 row4" data-quarto-table-cell-role="th">4</td>
<td id="T_8c357_row4_col0" class="data row4 col0">GLAD</td>
<td id="T_8c357_row4_col1" class="data row4 col1">87.542</td>
<td id="T_8c357_row4_col2" class="data row4 col2">0.124</td>
</tr>
<tr class="even">
<td id="T_8c357_level0_row5" class="row_heading level0 row5" data-quarto-table-cell-role="th">5</td>
<td id="T_8c357_row5_col0" class="data row5 col0">CONAL[SCALE=0]</td>
<td id="T_8c357_row5_col1" class="data row5 col1">88.468</td>
<td id="T_8c357_row5_col2" class="data row5 col2">0.115</td>
</tr>
<tr class="odd">
<td id="T_8c357_level0_row6" class="row_heading level0 row6" data-quarto-table-cell-role="th">6</td>
<td id="T_8c357_row6_col0" class="data row6 col0">CONAL[SCALE=1E-4]</td>
<td id="T_8c357_row6_col1" class="data row6 col1">88.889</td>
<td id="T_8c357_row6_col2" class="data row6 col2">0.112</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>As we can see, CoNAL strategy performs best. In this case, it is expected behavior as CoNAL was created for the <span class="math inline">\texttt{LabelMe}</span> dataset. However, using <code>peerannot</code> we can look into <strong>why modeling common confusion returns better results with this dataset</strong>. To do so, we can explore the datasets from two points of view: worker-wise or task-wise.</p>
</section>
</section>
<section id="exploring-crowdsourced-datasets" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Exploring crowdsourced datasets</h1>
<p>If a dataset requires crowdsourcing to be labeled, it is because expert knowledge is long and costly to obtain. In the era of big data, where datasets are built using web scraping (or using a platform like <a href="https://www.mturk.com/">Amazon Mechanical Turk</a>), citizen science is popular as it is an easy way to produce many labels.</p>
<p>However, mistakes and confusions happen during these experiments. Sometimes involuntarily (<em>e.g.</em> because the task is too hard or the worker is unable to differentiate between two classes) and sometimes not (<em>e.g.</em> the worker is a spammer).</p>
<p>Underlying all the learning models and aggregation strategies, the cornerstone of crowdsourcing is evaluating the trust we put in each worker depending on the presented task. And with the gamification of crowdsourcing <span class="citation" data-cites="plantgame2016 tinati2017investigation">(<a href="#ref-plantgame2016" role="doc-biblioref">Servajean et al. 2016</a>; <a href="#ref-tinati2017investigation" role="doc-biblioref">Tinati et al. 2017</a>)</span>, it has become essential to find scoring metrics both for workers and tasks to keep citizens in the loop so to speak. This is the purpose of the identification module in <code>peerannot</code>.</p>
<p>Our test cases are both the <span class="math inline">\texttt{CIFAR-10H}</span> dataset and the <span class="math inline">\texttt{LabelMe}</span> dataset to compare the worker and task evaluation depending on the number of votes collected. Indeed, the <span class="math inline">\texttt{LabelMe}</span> dataset has only up to three votes per task whereas <span class="math inline">\texttt{CIFAR-10H}</span> accounts for nearly fifty votes per task.</p>
<section id="exploring-tasks-difficulty" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="exploring-tasks-difficulty"><span class="header-section-number">5.1</span> Exploring tasks’ difficulty</h2>
<p>To explore the tasks’ intrinsic difficulty, we propose to compare three scoring metrics:</p>
<ul>
<li>the entropy of the NS distribution: the entropy measures the inherent uncertainty of the distribution to the possible outcomes. It is reliable with a big enough and not adversarial crowd.</li>
<li>GLAD’s scoring: by construction, <span class="citation" data-cites="whitehill_whose_2009">Whitehill et al. (<a href="#ref-whitehill_whose_2009" role="doc-biblioref">2009</a>)</span> introduced a scalar coefficient to score the difficulty of a task.</li>
<li>the Weighted Area Under the Margins (WAUM): introduced in <span class="citation" data-cites="lefort2022improve">(<a href="#ref-lefort2022improve" role="doc-biblioref">Lefort et al. 2022</a>)</span>, this weighted area under the margins indicates how difficult it is for a classifier <span class="math inline">\mathcal{C}</span> to learn a task’s label. This procedure is done with a budget of <span class="math inline">T&gt;0</span> epochs. Given the crowdsourced labels and the trust we have in each worker denoted <span class="math inline">s^{(j)}(x_i)&gt;0</span>, the WAUM of a given task <span class="math inline">x_i\in\mathcal{X}</span> and a set of crowdsourced labels <span class="math inline">\{y_i^{(j)}\}_j \in [K]^{|\mathcal{A}(x_i)|}</span> is defined as: <span class="math display">\mathrm{WAUM}(x_i) := \frac{1}{|\mathcal{A}(x_i)|}\sum_{j\in\mathcal{A}(x_i)} s^{(j)}(x_i)\left\{\frac{1}{T}\sum_{t=1}^T  \sigma(\mathcal{C}(x_i))_{y_i^{(j)}} - \sigma(\mathcal{C}(x_i))_{[2]}\right\} \enspace.
</span></li>
</ul>
<p>Note that each of these statistics is useful in its context. The entropy can not be used in a setting with small <span class="math inline">|\mathcal{A}(x_i)|</span> (few labels per task), in particular for the <span class="math inline">\texttt{LabelMe}</span> dataset it is uninformative. The WAUM can handle any number of labels, but the larger the better. However, as it uses a deep learning classifier, the WAUM needs the tasks <span class="math inline">(x_i)_i</span> in addition to the proposed labels while the other strategies are feature-blind.</p>
<section id="cifar-1oh-dataset" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="cifar-1oh-dataset"><span class="header-section-number">5.1.1</span> CIFAR-1OH dataset</h3>
<p>First, let us consider a dataset with a large number of tasks, annotations and workers: the <span class="math inline">\texttt{CIFAR-10H}</span> dataset by <span class="citation" data-cites="peterson_human_2019">Peterson et al. (<a href="#ref-peterson_human_2019" role="doc-biblioref">2019</a>)</span>.</p>
<div id="4838afcf" class="cell" data-execution_count="23">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>method WAUM <span class="op">\</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json <span class="op">--</span>model resnet34 <span class="op">\</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">100</span> <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">32</span> <span class="op">--</span>maxiter<span class="op">-</span>DS<span class="op">=</span><span class="dv">50</span> <span class="op">\</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>pretrained</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fig-difficulty-c10h" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> plotly.subplots <span class="im">import</span> make_subplots</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> (</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"plane"</span>,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"car"</span>,</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"bird"</span>,</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cat"</span>,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"deer"</span>,</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"dog"</span>,</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"frog"</span>,</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"horse"</span>,</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ship"</span>,</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"truck"</span>,</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_data(dataset, n_classes, classes):</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    entrop <span class="op">=</span> np.load(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/entropies.npy"</span>)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    path_train <span class="op">=</span> Path(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/train"</span>)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    glad <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.exp(</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        np.load(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/glad/difficulties.npy"</span>)[</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>            :, <span class="dv">1</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    dfwaum <span class="op">=</span> pd.read_csv(</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/resnet34/waum_0.01_yang/waum.csv"</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    ) <span class="cf">if</span> dataset.startswith(<span class="st">"cifar"</span>) <span class="cf">else</span> pd.read_csv(</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/modellabelme/waum_0.01_yang/waum.csv"</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    tasks <span class="op">=</span> dfwaum.sort_values(by<span class="op">=</span><span class="st">"waum"</span>)[<span class="st">"task"</span>].values</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    img_ns, img_glad, img_waum <span class="op">=</span> [], [], []</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    idxs_ns <span class="op">=</span> np.argsort(entrop)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    idxs_glad <span class="op">=</span> np.argsort(glad)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    idxs_waum <span class="op">=</span> [Path(task).stem.split(<span class="st">"-"</span>)[<span class="dv">1</span>] <span class="cf">for</span> task <span class="kw">in</span> tasks]</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idxs, im_store <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>        [idxs_ns, idxs_glad, idxs_waum], [img_ns, img_glad, img_waum]</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        imgs <span class="op">=</span> []</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes):</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>            imgs.append([])</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>            flag <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (id_, <span class="bu">file</span>) <span class="kw">in</span> <span class="bu">list</span>(</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>                itertools.product(idxs, path_train.glob(<span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss">/*"</span>))</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>            ):</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">file</span>.stem.endswith(<span class="ss">f"-</span><span class="sc">{</span>id_<span class="sc">}</span><span class="ss">"</span>):</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>                    im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="bu">file</span>)</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> dataset.startswith(<span class="st">"cifar"</span>):</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>                      im <span class="op">=</span> im.resize((<span class="dv">32</span>,<span class="dv">32</span>))</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>                      im <span class="op">=</span> im.resize((<span class="dv">64</span>, <span class="dv">64</span>))  <span class="co"># memory saving</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>                    imgs[k].append(np.array(im))</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>                    flag <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> flag <span class="op">==</span> <span class="dv">12</span>:</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>            image_k_row1 <span class="op">=</span> np.hstack(imgs[k][:<span class="dv">6</span>])</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>            image_k_row2 <span class="op">=</span> np.hstack(imgs[k][<span class="dv">6</span>:])</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>            image_k <span class="op">=</span> np.vstack((image_k_row1, image_k_row2))</span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a>            im_store.append(image_k)</span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>    all_images <span class="op">=</span> [img_ns, img_glad, img_waum]</span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_images</span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_visible_strat(strategy):</span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a>    ll <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> strategy, n_classes <span class="op">*</span> (strategy <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>        ll[k] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll</span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_layer_strat(strategy):</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    ll_layer <span class="op">=</span> [<span class="st">"below"</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> strategy, n_classes <span class="op">*</span> (strategy <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a>        ll_layer[k] <span class="op">=</span> <span class="st">"above"</span></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll_layer</span>
<span id="cb25-79"><a href="#cb25-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-80"><a href="#cb25-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_visible_class(lab):</span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a>    ll <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>        ll[n_classes <span class="op">*</span> k <span class="op">+</span> lab] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll</span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-88"><a href="#cb25-88" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_plot(n_classes, all_images):</span>
<span id="cb25-89"><a href="#cb25-89" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> make_subplots(</span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a>        rows<span class="op">=</span><span class="dv">3</span>, cols<span class="op">=</span><span class="dv">1</span>, subplot_titles<span class="op">=</span>(<span class="st">"Entropy"</span>, <span class="st">"GLAD difficulty"</span>, <span class="st">"WAUM"</span>), vertical_spacing<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a>    button_classes <span class="op">=</span> [</span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[{<span class="st">"visible"</span>: get_visible_class(k)}],</span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes)</span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb25-100"><a href="#cb25-100" aria-hidden="true" tabindex="-1"></a>    buttons_method <span class="op">=</span> [</span>
<span id="cb25-101"><a href="#cb25-101" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">0</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">0</span>)}</span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"entropy"</span>,</span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">1</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">1</span>)}</span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"glad"</span>,</span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb25-114"><a href="#cb25-114" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb25-115"><a href="#cb25-115" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">2</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">1</span>)}</span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb25-119"><a href="#cb25-119" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"waum"</span>,</span>
<span id="cb25-120"><a href="#cb25-120" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> go.Layout(</span>
<span id="cb25-124"><a href="#cb25-124" aria-hidden="true" tabindex="-1"></a>        updatemenus<span class="op">=</span>[</span>
<span id="cb25-125"><a href="#cb25-125" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb25-126"><a href="#cb25-126" aria-hidden="true" tabindex="-1"></a>                <span class="st">"type"</span>: <span class="st">"buttons"</span>,</span>
<span id="cb25-127"><a href="#cb25-127" aria-hidden="true" tabindex="-1"></a>                <span class="st">"buttons"</span>: button_classes,</span>
<span id="cb25-128"><a href="#cb25-128" aria-hidden="true" tabindex="-1"></a>                <span class="st">"active"</span>: <span class="dv">3</span>,</span>
<span id="cb25-129"><a href="#cb25-129" aria-hidden="true" tabindex="-1"></a>                <span class="st">"showactive"</span>: <span class="va">True</span>,</span>
<span id="cb25-130"><a href="#cb25-130" aria-hidden="true" tabindex="-1"></a>                <span class="st">"direction"</span>: <span class="st">"down"</span>,  <span class="co"># Display buttons horizontally</span></span>
<span id="cb25-131"><a href="#cb25-131" aria-hidden="true" tabindex="-1"></a>                <span class="st">"x"</span>: <span class="fl">0.1</span>,  <span class="co"># X-position of the buttons (0.5 centers them)</span></span>
<span id="cb25-132"><a href="#cb25-132" aria-hidden="true" tabindex="-1"></a>                <span class="st">"y"</span>: <span class="fl">1.</span>,  <span class="co"># Y-position   of the buttons</span></span>
<span id="cb25-133"><a href="#cb25-133" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb25-134"><a href="#cb25-134" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb25-135"><a href="#cb25-135" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-136"><a href="#cb25-136" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> [</span>
<span id="cb25-137"><a href="#cb25-137" aria-hidden="true" tabindex="-1"></a>        go.Image(</span>
<span id="cb25-138"><a href="#cb25-138" aria-hidden="true" tabindex="-1"></a>            z<span class="op">=</span>all_images[method][k],</span>
<span id="cb25-139"><a href="#cb25-139" aria-hidden="true" tabindex="-1"></a>            visible<span class="op">=</span><span class="va">True</span> <span class="cf">if</span> k <span class="op">==</span> <span class="dv">3</span> <span class="cf">else</span> <span class="va">False</span>,</span>
<span id="cb25-140"><a href="#cb25-140" aria-hidden="true" tabindex="-1"></a>            name<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>method<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb25-141"><a href="#cb25-141" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-142"><a href="#cb25-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> method <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(all_images))</span>
<span id="cb25-143"><a href="#cb25-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes)</span>
<span id="cb25-144"><a href="#cb25-144" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb25-145"><a href="#cb25-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-146"><a href="#cb25-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> <span class="bu">len</span>(all_images)):</span>
<span id="cb25-147"><a href="#cb25-147" aria-hidden="true" tabindex="-1"></a>        fig.add_trace(</span>
<span id="cb25-148"><a href="#cb25-148" aria-hidden="true" tabindex="-1"></a>            data[k],</span>
<span id="cb25-149"><a href="#cb25-149" aria-hidden="true" tabindex="-1"></a>            row<span class="op">=</span><span class="dv">1</span> <span class="op">+</span> k <span class="op">//</span> n_classes,</span>
<span id="cb25-150"><a href="#cb25-150" aria-hidden="true" tabindex="-1"></a>            col<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb25-151"><a href="#cb25-151" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-152"><a href="#cb25-152" aria-hidden="true" tabindex="-1"></a>    fig.update_layout(layout)</span>
<span id="cb25-153"><a href="#cb25-153" aria-hidden="true" tabindex="-1"></a>    fig.update_layout(width<span class="op">=</span><span class="dv">800</span>, height<span class="op">=</span><span class="dv">700</span>, margin<span class="op">=</span><span class="bu">dict</span>(l<span class="op">=</span><span class="dv">0</span>, r<span class="op">=</span><span class="dv">0</span>, t<span class="op">=</span><span class="dv">30</span>, b<span class="op">=</span><span class="dv">0</span>, autoexpand<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb25-154"><a href="#cb25-154" aria-hidden="true" tabindex="-1"></a>    fig.update_xaxes(showticklabels<span class="op">=</span><span class="va">False</span>).update_yaxes(showticklabels<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-155"><a href="#cb25-155" aria-hidden="true" tabindex="-1"></a>    fig.show()</span>
<span id="cb25-156"><a href="#cb25-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-157"><a href="#cb25-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-158"><a href="#cb25-158" aria-hidden="true" tabindex="-1"></a>n_classes <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb25-159"><a href="#cb25-159" aria-hidden="true" tabindex="-1"></a>all_images <span class="op">=</span> load_data(<span class="st">"cifar10H"</span>, n_classes, classes)</span>
<span id="cb25-160"><a href="#cb25-160" aria-hidden="true" tabindex="-1"></a>generate_plot(n_classes, all_images)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<figcaption class="figure-caption">Figure&nbsp;6: <strong>?(caption)</strong></figcaption>
</figure>
</div>
<p>The entropy, GLAD’s difficulty, and WAUM’s difficulty each show different images as exhebited above.. We highlight that for the <code>cat</code> label, each strategy retrieves images that are mislabeled in the ground truth labeling. Indeed, the frog, dog and fox images are labeled as <code>cat</code> in <span class="math inline">\texttt{CIFAR-10}</span>. And while the entropy and GLAD output similar tasks, in this case the WAUM often differs. We can also observe an ambiguity induced by the labels in the <code>truck</code> category, with the presence of a trailer that is technically a mixup between a <code>car</code> and a <code>truck</code>.</p>
</section>
<section id="labelme-dataset" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="labelme-dataset"><span class="header-section-number">5.1.2</span> LabelMe dataset</h3>
<p>As for the <span class="math inline">\texttt{LabelMe}</span> dataset, one difficulty in evaluating tasks’ intrinsic difficulty is that there are up to three votes given per task. Hence, the entropy in the distribution of the votes is no longer a reliable metric, and we need to rely on other models.</p>
<p>Now, let us compare the tasks’ difficulty distribution depending on the strategy considered using <code>peerannot</code>.</p>
<div id="b2810efe" class="cell" data-execution_count="25">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>method WAUM <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json <span class="op">--</span>model modellabelme <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">100</span> <span class="op">--</span>maxiter<span class="op">-</span>DS<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>alpha<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>pretrained <span class="op">--</span>optimizer<span class="op">=</span>sgd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fig-difficulty-labelme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> {</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: <span class="st">"coast"</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"forest"</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"highway"</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"insidecity"</span>,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"mountain"</span>,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"opencountry"</span>,</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"street"</span>,</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: <span class="st">"tallbuilding"</span>,</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> <span class="bu">list</span>(classes.values())</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>n_classes <span class="op">=</span> <span class="bu">len</span>(classes)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>all_images <span class="op">=</span> load_data(<span class="st">"labelme"</span>, n_classes, classes)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>generate_plot(n_classes, all_images) <span class="co"># create interactive plot</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<figcaption class="figure-caption">Figure&nbsp;7: <strong>?(caption)</strong></figcaption>
</figure>
</div>
<p>Note that in <a href="#fig-difficulty-labelme" class="quarto-xref">Figure&nbsp;7</a>, because the number of labels given per task is in <span class="math inline">\{1,2,3\}</span>, the entropy only takes four values. In particular, tasks with only one label all have a null entropy, so not just consensual tasks.</p>
<p>The underlying difficulty of these tasks mainly comes from the overlap in possible labels. For example, <code>tallbuildings</code> are most often found <code>insidecities</code>, and so are <code>streets</code>. In the <code>opencountry</code> we find <code>forests</code>, river-<code>coasts</code> and <code>mountains</code>.</p>
</section>
</section>
<section id="exploring-workers-reliability" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="exploring-workers-reliability"><span class="header-section-number">5.2</span> Exploring workers’ reliability</h2>
<p>From the labels, we can explore different worker evaluation scores. GLAD’s strategy estimates a reliability scalar coefficient <span class="math inline">\alpha_j</span> per worker. With strategies looking to estimate confusion matrices, we investigate two scoring rules for workers:</p>
<ul>
<li>the trace of the confusion matrix: the closer to <span class="math inline">K</span> the better the worker,</li>
<li>the closeness to spammer metric <span class="citation" data-cites="raykar_ranking_2011">(<a href="#ref-raykar_ranking_2011" role="doc-biblioref">Raykar and Yu 2011</a>)</span> (also called spammer score) that is the Frobenius norm between the estimated confusion matrix <span class="math inline">\hat\pi^{(j)}</span> and the closest rank-<span class="math inline">1</span> matrix. The further to zero the better the worker. On the contrary, the closer to zero, the more likely it is the worker to be a spammer.</li>
</ul>
<p>When the tasks are available, confusion-matrix-based deep learning models can also be used. We thus add to the comparison the trace of the confusion matrices with CrowdLayer and CoNAL on the <span class="math inline">\texttt{LabelMe}</span> datasets. For CoNAL, we only consider the trace of the confusion matrix <span class="math inline">\pi^{(j)}</span> in the pairwise comparison. Moreover, for CrowdLayer and CoNAL we show the weights learned without the softmax operation by row to keep the comparison as simple as possible with the actual outputs of the model.</p>
<section id="cifar-10h" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="cifar-10h"><span class="header-section-number">5.2.1</span> CIFAR-10H</h3>
<p>The <span class="math inline">\texttt{CIFAR-10H}</span> dataset has few disagreements among workers. However, these strategies disagree on the ranking of good against best workers as they do not measure the same properties.</p>
<div id="97649e75" class="cell" data-execution_count="27">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-fig-abilitiescifarh" class="cell" data-execution_count="28">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"Trace DS"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace DS"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>, plot_kws<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.2</span>})</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/seaborn/axisgrid.py:118: UserWarning:

The figure layout has changed to tight
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-abilitiescifarh" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-abilitiescifarh-output-2.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;8: Comparison of ability scores by workers for the CIFAR-10H dataset. All metrics computed identify the same poorly performing workers. A mass of good and expert workers can be seen as the dataset presents few disagreements, thus few data to seperate good from best workers.</figcaption>
</figure>
</div>
</div>
</div>
<p>From <a href="#fig-abilitiescifarh" class="quarto-xref">Figure&nbsp;8</a>, we can see that in this dataset, different methods easily separate the worse workers from the rest of the crowd (workers in the tail of the distribution).</p>
</section>
<section id="labelme" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="labelme"><span class="header-section-number">5.2.2</span> LabelMe</h3>
<p>Finally, let us evaluate workers for the <span class="math inline">\texttt{LabelMe}</span> dataset. Because of the lack of data (up to 3 labels per task), ranking workers is more difficult than in the <span class="math inline">\texttt{CIFAR-10H}</span> dataset.</p>
<div id="2f68d385" class="cell" data-execution_count="29">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">8</span> <span class="op">\</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"># CoNAL and CrowdLayer were run in section 4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cell-fig-abilities-labelme" class="cell" data-execution_count="30">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"Trace DS"</span>: [], <span class="st">"Spam score"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"Trace CrowdLayer"</span>: [], <span class="st">"Trace CoNAL[scale=1e-4]"</span>: []}</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>best_cl <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_crowdlayer.pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>best_conal <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4]_local_confusion.pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>pi_conal <span class="op">=</span> best_conal</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace CoNAL[scale=1e-4]"</span>].extend([torch.trace(pi_conal[i]).item() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pi_conal.shape[<span class="dv">0</span>])])</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace CrowdLayer"</span>].extend([torch.trace(best_cl[<span class="st">"confusion"</span>][i]).item() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(best_cl[<span class="st">"confusion"</span>].shape[<span class="dv">0</span>])])</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace DS"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Spam score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>, plot_kws<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.2</span>})</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/seaborn/axisgrid.py:118: UserWarning:

The figure layout has changed to tight
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-abilities-labelme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-abilities-labelme-output-2.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;9: Comparison of ability scores by workers for the labelme dataset. With few labels per task, workers are more difficult to rank. It is more difficult to separate workers with their abilities in this crowd. Hence the importance of investigating the generalization performance of the methods presented in the previous section.</figcaption>
</figure>
</div>
</div>
</div>
<p>We can see in Figure <a href="#fig-abilities-labelme" class="quarto-xref">Figure&nbsp;9</a> that the number of labels available by task highly impacts the worker evaluation scores. The spam score, DS model and CoNAL all show similar results in the distribution shape (bimodal distribution) whereas GLAD and CrowdLayer are more concentrated. However, this does not account for the ranking of a given worker by the methods considered. The exploration of the dataset let us look at different scores, but generalization performance presented in <a href="#sec-real-datasets" class="quarto-xref">Section&nbsp;4.3</a> should also be considered in crowdsourcing. This difference in worker evaluation scores indeed further highlights the importance of using multiple test metrics to compare model’s prediction performance in crowdsourcing. We have seen that the library <code>peerannot</code> allows users to explore the datasets, both in terms of tasks and workers, and easily compare predictive performance in this setting.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusion</h1>
<p>We introduced <code>peerannot</code>, a library to handle crowdsourced datasets. This library enables both easy label aggregation and direct training strategies with classical state-of-the-art classifiers. The identification module of the library allows exploring the collected data from both the tasks and the workers’ point of view for better scorings and data cleaning procedures. Our library also comes with templated datasets to better share crowdsourced datasets. Going beyond templating, it helps the crowdsourcing community to have openly accessible strategies to test, compare and improve in order to develop common strategies to analyse more and more common crowdsourced datasets.</p>
<p>We hope that this library helps reproducibility in the crowdsourcing community and also standardizes training from crowdsourced datasets. New strategies can easily be incorporated into the open-source code <a href="https://github.com/peerannot/peerannot">available on github</a>. Finally, as <code>peerannot</code> is mostly directed to handle classification datasets, one of our future works would be to consider other <code>peerannot</code> modules to handle crowdsourcing for object detection, segmentation and even worker evaluation in other contexts like peer-grading.</p>
<!-- -->

</section>
<section id="bibliography" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliography</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-aitchison2020statistical" class="csl-entry" role="listitem">
Aitchison, L. 2021. <span>“A Statistical Theory of Cold Posteriors in Deep Neural Networks.”</span> In <em>ICLR</em>.
</div>
<div id="ref-chagneux2023" class="csl-entry" role="listitem">
Chagneux, M, S LeCorff, P Gloaguen, C Ollion, O Lepâtre, and A Bruge. 2023. <span>“Macrolitter Video Counting on Riverbanks Using State Space Models and Moving Cameras.”</span> <em>Computo</em>, February. <a href="https://doi.org/10.57750/845m-f805">https://doi.org/10.57750/845m-f805</a>.
</div>
<div id="ref-chu2021learning" class="csl-entry" role="listitem">
Chu, Z, J Ma, and H Wang. 2021. <span>“Learning from Crowds by Modeling Common Confusions.”</span> In <em>AAAI</em>, 5832–40.
</div>
<div id="ref-dawid_maximum_1979" class="csl-entry" role="listitem">
Dawid, AP, and AM Skene. 1979. <span>“Maximum Likelihood Estimation of Observer Error-Rates Using the <span>EM</span> Algorithm.”</span> <em>J. R. Stat. Soc. Ser. C. Appl. Stat.</em> 28 (1): 20–28.
</div>
<div id="ref-imagenet_cvpr09" class="csl-entry" role="listitem">
Deng, J., W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. 2009. <span>“ImageNet: A Large-Scale Hierarchical Image Database.”</span> In <em>CVPR</em>.
</div>
<div id="ref-gao2013minimax" class="csl-entry" role="listitem">
Gao, G, and D Zhou. 2013. <span>“Minimax Optimal Convergence Rates for Estimating Ground Truth from Crowdsourced Labels.”</span> <em>arXiv Preprint arXiv:1310.5764</em>.
</div>
<div id="ref-Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021" class="csl-entry" role="listitem">
Garcin, C., A. Joly, P. Bonnet, A. Affouard, J.-C. Lombardo, M. Chouet, M. Servajean, T. Lorieul, and J. Salmon. 2021. <span>“Pl@ntNet-300K: A Plant Image Dataset with High Label Ambiguity and a Long-Tailed Distribution.”</span> In <em>Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks</em>.
</div>
<div id="ref-gruber2022better" class="csl-entry" role="listitem">
Gruber, S G, and F Buettner. 2022. <span>“Better Uncertainty Calibration via Proper Scores for Classification and Beyond.”</span> In <em>Advances in Neural Information Processing Systems</em>.
</div>
<div id="ref-guo_calibration_2017" class="csl-entry" role="listitem">
Guo, C, G Pleiss, Y Sun, and KQ Weinberger. 2017. <span>“On Calibration of Modern Neural Networks.”</span> In <em>ICML</em>, 1321.
</div>
<div id="ref-imamura2018analysis" class="csl-entry" role="listitem">
Imamura, H, I Sato, and M Sugiyama. 2018. <span>“Analysis of Minimax Error Rate for Crowdsourcing and Its Application to Worker Clustering Model.”</span> In <em>ICML</em>, 2147–56.
</div>
<div id="ref-james1998majority" class="csl-entry" role="listitem">
James, GM. 1998. <span>“Majority Vote Classifiers: Theory and Applications.”</span> PhD thesis, Stanford University.
</div>
<div id="ref-kasmi2023crowdsourced" class="csl-entry" role="listitem">
Kasmi, G, Y-M Saint-Drenan, D Trebosc, R Jolivet, J Leloux, B Sarr, and L Dubus. 2023. <span>“A Crowdsourced Dataset of Aerial Images with Annotated Solar Photovoltaic Arrays and Installation Metadata.”</span> <em>Scientific Data</em> 10 (1): 59.
</div>
<div id="ref-khattak_toward_2017" class="csl-entry" role="listitem">
Khattak, FK. 2017. <span>“Toward a Robust and Universal Crowd Labeling Framework.”</span> PhD thesis, Columbia University.
</div>
<div id="ref-krizhevsky2009learning" class="csl-entry" role="listitem">
Krizhevsky, A, and G Hinton. 2009. <span>“Learning Multiple Layers of Features from Tiny Images.”</span> University of Toronto.
</div>
<div id="ref-lefort2022improve" class="csl-entry" role="listitem">
Lefort, T, B Charlier, A Joly, and J Salmon. 2022. <span>“Identify Ambiguous Tasks Combining Crowdsourced Labels by Weighting Areas Under the Margin.”</span> <em>arXiv Preprint arXiv:2209.15380</em>.
</div>
<div id="ref-cocodataset" class="csl-entry" role="listitem">
Lin, Tsung-Yi, Michael Maire, Serge J. Belongie, Lubomir D. Bourdev, Ross B. Girshick, James Hays, Pietro Perona, Deva Ramanan, Piotr Doll’a r, and C. Lawrence Zitnick. 2014. <span>“Microsoft <span>COCO:</span> Common Objects in Context.”</span> <em>CoRR</em> abs/1405.0312. <a href="http://arxiv.org/abs/1405.0312">http://arxiv.org/abs/1405.0312</a>.
</div>
<div id="ref-torchvision" class="csl-entry" role="listitem">
Marcel, S, and Y Rodriguez. 2010. <span>“Torchvision the Machine-Vision Package of Torch.”</span> In <em>Proceedings of the 18th ACM International Conference on Multimedia</em>, 1485–88. MM ’10. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/1873951.1874254">https://doi.org/10.1145/1873951.1874254</a>.
</div>
<div id="ref-park2022calibration" class="csl-entry" role="listitem">
Park, Seo Yeon, and Cornelia Caragea. 2022. <span>“On the Calibration of Pre-Trained Language Models Using Mixup Guided by Area Under the Margin and Saliency.”</span> In <em>ACML</em>, 5364–74.
</div>
<div id="ref-passonneau-carpenter-2014-benefits" class="csl-entry" role="listitem">
Passonneau, R J., and B Carpenter. 2014. <span>“The Benefits of a Model of Annotation.”</span> <em>Transactions of the Association for Computational Linguistics</em> 2: 311–26.
</div>
<div id="ref-pytorch" class="csl-entry" role="listitem">
Paszke, A, S Gross, F Massa, A Lerer, J Bradbury, G Chanan, T Killeen, et al. 2019. <span>“PyTorch: An Imperative Style, High-Performance Deep Learning Library.”</span> In <em>NeurIPS</em>, 8024–35.
</div>
<div id="ref-peterson_human_2019" class="csl-entry" role="listitem">
Peterson, J C., R M. Battleday, T L. Griffiths, and O Russakovsky. 2019. <span>“Human Uncertainty Makes Classification More Robust.”</span> In <em>ICCV</em>, 9617–26.
</div>
<div id="ref-pleiss_identifying_2020" class="csl-entry" role="listitem">
Pleiss, G, T Zhang, E R Elenberg, and K Q Weinberger. 2020. <span>“Identifying Mislabeled Data Using the Area Under the Margin Ranking.”</span> In <em>NeurIPS</em>.
</div>
<div id="ref-raykar_ranking_2011" class="csl-entry" role="listitem">
Raykar, V C, and S Yu. 2011. <span>“Ranking Annotators for Crowdsourced Labeling Tasks.”</span> In <em>NeurIPS</em>, 1809–17.
</div>
<div id="ref-rodrigues2017learning" class="csl-entry" role="listitem">
Rodrigues, F, M Lourenco, B Ribeiro, and F C Pereira. 2017. <span>“Learning Supervised Topic Models for Classification and Regression from Crowds.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 39 (12): 2409–22.
</div>
<div id="ref-rodrigues2018deep" class="csl-entry" role="listitem">
Rodrigues, F, and F Pereira. 2018. <span>“Deep Learning from Crowds.”</span> In <em>AAAI</em>. Vol. 32.
</div>
<div id="ref-rodrigues2014gaussian" class="csl-entry" role="listitem">
Rodrigues, F, F Pereira, and B Ribeiro. 2014. <span>“Gaussian Process Classification and Active Learning with Multiple Annotators.”</span> In <em>ICML</em>, 433–41. PMLR.
</div>
<div id="ref-plantgame2016" class="csl-entry" role="listitem">
Servajean, M, A Joly, D Shasha, J Champ, and E Pacitti. 2016. <span>“ThePlantGame: Actively Training Human Annotators for Domain-Specific Crowdsourcing.”</span> In <em>Proceedings of the 24th ACM International Conference on Multimedia</em>, 720–21. MM ’16. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2964284.2973820">https://doi.org/10.1145/2964284.2973820</a>.
</div>
<div id="ref-servajean2017crowdsourcing" class="csl-entry" role="listitem">
———. 2017. <span>“Crowdsourcing Thousands of Specialized Labels: A <span>Bayesian</span> Active Training Approach.”</span> <em>IEEE Transactions on Multimedia</em> 19 (6): 1376–91.
</div>
<div id="ref-sinha2018fast" class="csl-entry" role="listitem">
Sinha, V B, S Rao, and V N Balasubramanian. 2018. <span>“Fast <span>Dawid-Skene</span>: A Fast Vote Aggregation Scheme for Sentiment Classification.”</span> <em>arXiv Preprint arXiv:1803.02781</em>.
</div>
<div id="ref-tinati2017investigation" class="csl-entry" role="listitem">
Tinati, R, M Luczak-Roesch, E Simperl, and W Hall. 2017. <span>“An Investigation of Player Motivations in Eyewire, a Gamified Citizen Science Project.”</span> <em>Computers in Human Behavior</em> 73: 527–40.
</div>
<div id="ref-whitehill_whose_2009" class="csl-entry" role="listitem">
Whitehill, J, T Wu, J Bergsma, J Movellan, and P Ruvolo. 2009. <span>“Whose Vote Should Count More: Optimal Integration of Labels from Labelers of Unknown Expertise.”</span> In <em>NeurIPS</em>. Vol. 22.
</div>
<div id="ref-YasminRomena2022ICIC" class="csl-entry" role="listitem">
Yasmin, R, M Hassan, J T Grassel, H Bhogaraju, A R Escobedo, and O Fuentes. 2022. <span>“Improving Crowdsourcing-Based Image Classification Through Expanded Input Elicitation and Machine Learning.”</span> <em>Frontiers in Artificial Intelligence</em> 5: 848056.
</div>
<div id="ref-zhang2017mixup" class="csl-entry" role="listitem">
Zhang, H, M Cissé, Y N. Dauphin, and D Lopez-Paz. 2018. <span>“Mixup: Beyond Empirical Risk Minimization.”</span> In <em>ICLR</em>.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{lefort2023,
  author = {Lefort, Tanguy and Charlier, Benjamin and Joly, Alexis and
    Salmon, Joseph},
  publisher = {Société Française de Statistique},
  title = {Peerannot: Learning from Crowdsourced Image Datasets with
    {Python}},
  journal = {Computo},
  date = {2023-07-18},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {Crowdsourcing is a quick and easy way to collect labels
    for large datasets, involving many workers. However, workers often
    disagree with each other. Sources of error can arise from the
    workers’ skills, but also from the intrinsic difficulty of the task.
    We present `peerannot`: a `Python` library for managing and learning
    from crowdsourced labels. Our library allows users to aggregate
    labels from common noise models or train a deep learning-based
    classifier directly from crowdsourced labels. In addition, we
    provide an identification module to easily explore the task
    difficulty of datasets and worker capabilities.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lefort2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Lefort, Tanguy, Benjamin Charlier, Alexis Joly, and Joseph Salmon. 2023.
<span>“Peerannot: Learning from Crowdsourced Image Datasets with
Python.”</span> <em>Computo</em>, July. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note);
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb34" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Peerannot: learning from crowdsourced image datasets with Python"</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> ""</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Tanguy Lefort</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: tanguy.lefort@umontpellier.fr</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://tanglef.github.io</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0009-0000-6710-3221</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: IMAG, Univ Montpellier, CNRS, Inria, LIRMM</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Benjamin Charlier</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="co">    email: benjamin.charlier@umontpellier.fr</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://imag.umontpellier.fr/~charlier/index.php?page=index&amp;lang=en</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: IMAG, Univ Montpellier, CNRS</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Alexis Joly</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="co">    email: alexis.joly@inria.fr</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://www-sop.inria.fr/members/Alexis.Joly/wiki/pmwiki.php</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-2161-9940</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Inria, LIRMM, Univ Montpellier, CNRS</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Joseph Salmon</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="co">    email: joseph.salmon@umontpellier.fr</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://josephsalmon.eu/</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-3181-0634</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: IMAG, Univ Montpellier, CNRS, IUF</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a><span class="co">  Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers.</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a><span class="co">  However, it is common for workers to disagree with each other.</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a><span class="co">  Sources of error can arise from the workers' skills, but also from the intrinsic difficulty of the task.</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a><span class="co">  We introduce `peerannot`, a Python library for managing and learning from crowdsourced labels.</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a><span class="co">  Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, workers often disagree with each other. Sources of error can arise from the workers' skills, but also from the intrinsic difficulty of the task. We present `peerannot`: a `Python` library for managing and learning from crowdsourced labels. Our library allows users to aggregate labels from common noise models or train a deep learning-based classifier directly from crowdsourced labels. In addition, we provide an identification module to easily explore the task difficulty of datasets and worker capabilities.</span></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [crowdsourcing, label noise, task difficulty, worker ability]</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-python"</span></span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> true</span></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span><span class="co">  # to remove at the end</span></span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a><span class="co">  cache: false</span></span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb34-59"><a href="#cb34-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-60"><a href="#cb34-60" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction: crowdsourcing in image classification</span></span>
<span id="cb34-61"><a href="#cb34-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-62"><a href="#cb34-62" aria-hidden="true" tabindex="-1"></a>Image datasets widely use crowdsourcing to collect labels, involving many workers that can annotate images for a small cost (or even free for instance in citizen science) and faster than using expert labeling.</span>
<span id="cb34-63"><a href="#cb34-63" aria-hidden="true" tabindex="-1"></a>Many classical datasets considered in machine learning have been created with human intervention to create labels, such as CIFAR-$10$, <span class="co">[</span><span class="ot">@krizhevsky2009learning</span><span class="co">]</span>,</span>
<span id="cb34-64"><a href="#cb34-64" aria-hidden="true" tabindex="-1"></a>ImageNet <span class="co">[</span><span class="ot">@imagenet_cvpr09</span><span class="co">]</span> or Pl\@ntnet <span class="co">[</span><span class="ot">@Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021</span><span class="co">]</span> in image classification, but also COCO <span class="co">[</span><span class="ot">@cocodataset</span><span class="co">]</span>, solar photovoltaic arrays <span class="co">[</span><span class="ot">@kasmi2023crowdsourced</span><span class="co">]</span> or even macro litter <span class="co">[</span><span class="ot">@chagneux2023</span><span class="co">]</span> in image segmentation and object counting.</span>
<span id="cb34-65"><a href="#cb34-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-66"><a href="#cb34-66" aria-hidden="true" tabindex="-1"></a>Crowdsourced datasets induce at least three major challenges to which we contribute with <span class="in">`peerannot`</span>:</span>
<span id="cb34-67"><a href="#cb34-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-68"><a href="#cb34-68" aria-hidden="true" tabindex="-1"></a>  1) *How to identify good workers in the crowd?* When multiple answers are given to a single task, looking for who to trust for which type of task becomes necessary to estimate the ground truth or later train a model with as few noise sources as possible. The module <span class="in">`identify`</span> uses different scoring metrics to create a worker and/or task evaluation.</span>
<span id="cb34-69"><a href="#cb34-69" aria-hidden="true" tabindex="-1"></a>  This is particularly relevant considering the gamification of crowdsourcing experiments <span class="co">[</span><span class="ot">@plantgame2016</span><span class="co">]</span></span>
<span id="cb34-70"><a href="#cb34-70" aria-hidden="true" tabindex="-1"></a>  1) *How to aggregate multiple labels into a single label from crowdsourced tasks?* This occurs for example when dealing with a single dataset that has been labeled by multiple workers with disagreements. This is also encountered with other scoring issues such as polls, reviews, peer-grading, *etc.* In our framework this is treated with the <span class="in">`aggregate`</span> command, that given multiple labels, infers a ground truth label. From aggregated labels, a classifier can then be trained using the <span class="in">`train`</span> command.</span>
<span id="cb34-71"><a href="#cb34-71" aria-hidden="true" tabindex="-1"></a>  1) *How to learn a classifier from crowdsourced datasets?* Where the first question is bound by aggregating multiple labels into a single one, this considers the case where we do not need a single label to train on, but instead train a classifier on the crowdsourced data, with the motivation to perform well on a testing set. This end-to-end vision, is common in machine learning, however, it requires the actual tasks (the images, texts, videos, *etc.*) to train on -- and in crowdsourced datasets publicly available, they are not always available. This is treated with the <span class="in">`aggregate-deep`</span> command.</span>
<span id="cb34-72"><a href="#cb34-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-73"><a href="#cb34-73" aria-hidden="true" tabindex="-1"></a>The library <span class="in">`peerannot`</span> addresses these practical questions within a reproducible setting. Indeed, the complexity of experiments often leads to a lack of transparency and reproducible results for simulations and real datasets.</span>
<span id="cb34-74"><a href="#cb34-74" aria-hidden="true" tabindex="-1"></a>We propose standard simulation settings with explicit implementation parameters that can be shared.</span>
<span id="cb34-75"><a href="#cb34-75" aria-hidden="true" tabindex="-1"></a>For real datasets, <span class="in">`peerannot`</span> is compatible with standard neural networks architectures from the <span class="in">`Torchvision`</span> <span class="co">[</span><span class="ot">@torchvision</span><span class="co">]</span> library and <span class="in">`Pytorch`</span> <span class="co">[</span><span class="ot">@pytorch</span><span class="co">]</span>, allowing a flexible framework with easy-to-share scripts to reproduce experiments.</span>
<span id="cb34-76"><a href="#cb34-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-77"><a href="#cb34-77" aria-hidden="true" tabindex="-1"></a><span class="al">![From crowdsourced labels to training a classifier neural network, the learning pipeline using the `peerannot` library. An optional preprocessing step using the `identify` command allows us to remove worse performing workers or images that can not be classified correctly (very bad quality for example). Then, from the cleaned dataset, the `aggregate` command may generate a single label per task from a prescribed strategy. From the aggregated labels we can train a neural network classifier with the `train` command. Otherwise, we can directly train a neural network classifier that takes into account the crowdsourcing setting in its architecture using `aggregate-deep`.](./figures/strategiesbis.png)</span>{#fig-pipeline width=550}</span>
<span id="cb34-78"><a href="#cb34-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-79"><a href="#cb34-79" aria-hidden="true" tabindex="-1"></a><span class="fu"># Notation and package structure</span></span>
<span id="cb34-80"><a href="#cb34-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-81"><a href="#cb34-81" aria-hidden="true" tabindex="-1"></a><span class="fu">## Crowdsourcing notation</span></span>
<span id="cb34-82"><a href="#cb34-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-83"><a href="#cb34-83" aria-hidden="true" tabindex="-1"></a>Let us consider the classical supervised learning classification framework. A training set $\mathcal{D}=<span class="sc">\{</span>(x_i, y_i^\star)<span class="sc">\}</span>_{i=1}^{n_{\text{task}}}$ is composed of $n_{\text{task}}$ tasks $x_i\in\mathcal{X}$ (the feature space) with (unobserved) ground truth label $y_i^\star \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>=<span class="sc">\{</span>1,\dots,K<span class="sc">\}</span>$ one of the $K$ possible classes.</span>
<span id="cb34-84"><a href="#cb34-84" aria-hidden="true" tabindex="-1"></a>In the following, the tasks considered are generally RGB images. We use the notation $\sigma(\cdot)$ for the softmax function.</span>
<span id="cb34-85"><a href="#cb34-85" aria-hidden="true" tabindex="-1"></a>In praticular, given a classifier $\mathcal{C}$ with logits outputs, $\sigma(\mathcal{C}(x_i))_{[1]}$ represents the largest probability and we can sort the probabilities as $\sigma(\mathcal{C}(x_i))_{[1]}\geq \sigma(\mathcal{C}(x_i))_{[2]}\geq \dots\geq \sigma(\mathcal{C}(x_i))_{<span class="co">[</span><span class="ot">K</span><span class="co">]</span>}$.</span>
<span id="cb34-86"><a href="#cb34-86" aria-hidden="true" tabindex="-1"></a>We use the $i$ index notation to range over the different tasks and the $j$ index notation for the workers in the crowdsourcing experiment.</span>
<span id="cb34-87"><a href="#cb34-87" aria-hidden="true" tabindex="-1"></a>Note that indices start at position $1$ in the equation to follow mathematical standard notation such as $<span class="co">[</span><span class="ot">K</span><span class="co">]</span>=<span class="sc">\{</span>1,\dots,K<span class="sc">\}</span>$ but it should be addressed that, as this is a <span class="in">`Python`</span> library, in the code indices start at the $0$ position.</span>
<span id="cb34-88"><a href="#cb34-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-89"><a href="#cb34-89" aria-hidden="true" tabindex="-1"></a>With crowdsourced data the ground truth of a task $x_i$, denoted $y_i^\star$ is unknown, and there is no single label that can be trusted as in standard supervised learning (even on the train set!).</span>
<span id="cb34-90"><a href="#cb34-90" aria-hidden="true" tabindex="-1"></a>Instead, there is a crowd of $n_{\text{worker}}$ workers from which multiple workers $(w_j)_j$ propose a label $(y_i^{(j)})_j$.</span>
<span id="cb34-91"><a href="#cb34-91" aria-hidden="true" tabindex="-1"></a>The set of workers answering the task $x_i$ is denoted by</span>
<span id="cb34-92"><a href="#cb34-92" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-93"><a href="#cb34-93" aria-hidden="true" tabindex="-1"></a>\mathcal{A}(x_i)=<span class="sc">\{</span>j\in<span class="co">[</span><span class="ot">n_\text{worker}</span><span class="co">]</span>: w_j \text{ answered }x_i<span class="sc">\}</span>.</span>
<span id="cb34-94"><a href="#cb34-94" aria-hidden="true" tabindex="-1"></a>$${#eq-workerset}</span>
<span id="cb34-95"><a href="#cb34-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-96"><a href="#cb34-96" aria-hidden="true" tabindex="-1"></a>The cardinal $\vert \mathcal{A}(x_i)\vert$ is called the feedback effort on the task $x_i$.</span>
<span id="cb34-97"><a href="#cb34-97" aria-hidden="true" tabindex="-1"></a>Note that the feedback effort can not exceed the total number of workers $n_{\text{worker}}$.</span>
<span id="cb34-98"><a href="#cb34-98" aria-hidden="true" tabindex="-1"></a>Similarly, one can adopt a worker point of view: the set of tasks answered by a worker $w_j$ is denoted</span>
<span id="cb34-99"><a href="#cb34-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-100"><a href="#cb34-100" aria-hidden="true" tabindex="-1"></a>\mathcal{T}(w_j)=<span class="sc">\{</span>i\in<span class="co">[</span><span class="ot">n_\text{task}</span><span class="co">]</span>: w_j \text{ answered } x_i<span class="sc">\}</span>.</span>
<span id="cb34-101"><a href="#cb34-101" aria-hidden="true" tabindex="-1"></a>$${#eq-taskset}</span>
<span id="cb34-102"><a href="#cb34-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-103"><a href="#cb34-103" aria-hidden="true" tabindex="-1"></a>The cardinal $\vert \mathcal{T}(w_j)\vert$ is called the workerload of $w_j$.</span>
<span id="cb34-104"><a href="#cb34-104" aria-hidden="true" tabindex="-1"></a>The final dataset can then be decomposed as:</span>
<span id="cb34-105"><a href="#cb34-105" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-106"><a href="#cb34-106" aria-hidden="true" tabindex="-1"></a>\mathcal{D}_{\text{train}} := \bigcup_{i\in[n_\text{task}]} \{(x_i, (y_i^{(j)})) \text{ for }j\in\mathcal{A}(x_i)\} = \bigcup_{j\in[n_\text{worker}]} <span class="sc">\{</span>(x_i, (y_i^{(j)})) \text{ for }i \in\mathcal{T}(w_j)<span class="sc">\}</span> \enspace.</span>
<span id="cb34-107"><a href="#cb34-107" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-108"><a href="#cb34-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-109"><a href="#cb34-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-110"><a href="#cb34-110" aria-hidden="true" tabindex="-1"></a>In this article, we do not address the setting where workers report their self-confidence <span class="co">[</span><span class="ot">@YasminRomena2022ICIC</span><span class="co">]</span>, nor settings where workers are presented a trapping set -- *i.e* a subset of tasks where the ground truth is known to evaluate them with known labels <span class="co">[</span><span class="ot">@khattak_toward_2017</span><span class="co">]</span>.</span>
<span id="cb34-111"><a href="#cb34-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-112"><a href="#cb34-112" aria-hidden="true" tabindex="-1"></a><span class="fu">## Storing crowdsourced datasets in `peerannot`</span></span>
<span id="cb34-113"><a href="#cb34-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-114"><a href="#cb34-114" aria-hidden="true" tabindex="-1"></a>Crowdsourced datasets come in various forms.</span>
<span id="cb34-115"><a href="#cb34-115" aria-hidden="true" tabindex="-1"></a>To store crowdsourcing datasets efficiently and in a standardized way, <span class="in">`peerannot`</span> proposes the following structure, where each dataset corresponds to a folder.</span>
<span id="cb34-116"><a href="#cb34-116" aria-hidden="true" tabindex="-1"></a>Let us set up a toy dataset example to understand the data structure and how to store it.</span>
<span id="cb34-117"><a href="#cb34-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-118"><a href="#cb34-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-119"><a href="#cb34-119" aria-hidden="true" tabindex="-1"></a><span class="in">```{#lst-datasetconvention bash lst-cap="Dataset storage template"}</span></span>
<span id="cb34-120"><a href="#cb34-120" aria-hidden="true" tabindex="-1"></a><span class="in">datasetname</span></span>
<span id="cb34-121"><a href="#cb34-121" aria-hidden="true" tabindex="-1"></a><span class="in">      ├── train</span></span>
<span id="cb34-122"><a href="#cb34-122" aria-hidden="true" tabindex="-1"></a><span class="in">      │     ├── class1</span></span>
<span id="cb34-123"><a href="#cb34-123" aria-hidden="true" tabindex="-1"></a><span class="in">      │     │     ├─ imagename-&lt;key&gt;.png</span></span>
<span id="cb34-124"><a href="#cb34-124" aria-hidden="true" tabindex="-1"></a><span class="in">      │     │     ├─ ...</span></span>
<span id="cb34-125"><a href="#cb34-125" aria-hidden="true" tabindex="-1"></a><span class="in">      │     │     └─ anotherimagename-&lt;anotherkey&gt;.png</span></span>
<span id="cb34-126"><a href="#cb34-126" aria-hidden="true" tabindex="-1"></a><span class="in">      │     ├── ...</span></span>
<span id="cb34-127"><a href="#cb34-127" aria-hidden="true" tabindex="-1"></a><span class="in">      │     └── classK</span></span>
<span id="cb34-128"><a href="#cb34-128" aria-hidden="true" tabindex="-1"></a><span class="in">      ├── val</span></span>
<span id="cb34-129"><a href="#cb34-129" aria-hidden="true" tabindex="-1"></a><span class="in">      ├── test</span></span>
<span id="cb34-130"><a href="#cb34-130" aria-hidden="true" tabindex="-1"></a><span class="in">      ├── metadata.json</span></span>
<span id="cb34-131"><a href="#cb34-131" aria-hidden="true" tabindex="-1"></a><span class="in">      └── answers.json</span></span>
<span id="cb34-132"><a href="#cb34-132" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-133"><a href="#cb34-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-134"><a href="#cb34-134" aria-hidden="true" tabindex="-1"></a>The <span class="in">`answers.json`</span> file stores the different votes for each task as described in @fig-answers.</span>
<span id="cb34-135"><a href="#cb34-135" aria-hidden="true" tabindex="-1"></a>Thus, for example for an image named <span class="in">`smiley_face-1`</span>, the associated labels are stored in the <span class="in">`answers.json`</span> at the key numbered <span class="in">`1`</span>.</span>
<span id="cb34-136"><a href="#cb34-136" aria-hidden="true" tabindex="-1"></a>This key identification system allows us to track directly from the filename the crowdsourced labels without having to rely on multiple indexing files as can be traditionally proposed.</span>
<span id="cb34-137"><a href="#cb34-137" aria-hidden="true" tabindex="-1"></a>Furthermore, storing labels in a dictionary is more memory-friendly than having an array of size <span class="in">`(n_task,n_worker)`</span> and writing $y_i^{(j)}=-1$ when the worker $w_j$ did not see the task $x_i$ and $y_i^{(j)}\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>$ otherwise.</span>
<span id="cb34-138"><a href="#cb34-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-139"><a href="#cb34-139" aria-hidden="true" tabindex="-1"></a><span class="al">![Data storage for a crowdsourced dataset for a binary classification problem ($K=2$, smiling/smiling) on recognizing smiling faces. (left: how data is stored in `peerannot` in a file `answers.json`, right: data collected)](./figures/json_answers.png)</span>{#fig-answers fig-align="center"}</span>
<span id="cb34-140"><a href="#cb34-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-141"><a href="#cb34-141" aria-hidden="true" tabindex="-1"></a>In @fig-answers, there are three tasks, $n_{\text{worker}}=4$ workers and $K=2$ classes.</span>
<span id="cb34-142"><a href="#cb34-142" aria-hidden="true" tabindex="-1"></a>Any available task should be stored in a single file whose name follows the convention described in @lst-datasetconvention. These files are spread into a <span class="in">`train`</span>, <span class="in">`val`</span> and <span class="in">`test`</span> subdir as in <span class="co">[</span><span class="ot">`ImageFolder` datasets</span><span class="co">](https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html)</span> from <span class="in">`torchvision`</span></span>
<span id="cb34-143"><a href="#cb34-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-144"><a href="#cb34-144" aria-hidden="true" tabindex="-1"></a>Finally, a <span class="in">`metadata.json`</span> file includes relevant information related to the crowdsourcing experiment such as the number of workers, the number of tasks, *etc.*</span>
<span id="cb34-145"><a href="#cb34-145" aria-hidden="true" tabindex="-1"></a>For example, a minimal <span class="in">`metadata.json`</span> file for the toy dataset presented in @fig-answers is:</span>
<span id="cb34-146"><a href="#cb34-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-149"><a href="#cb34-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{json}</span></span>
<span id="cb34-150"><a href="#cb34-150" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb34-151"><a href="#cb34-151" aria-hidden="true" tabindex="-1"></a>    <span class="st">"name"</span><span class="op">:</span> <span class="st">"toy-data"</span><span class="op">,</span></span>
<span id="cb34-152"><a href="#cb34-152" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_classes"</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb34-153"><a href="#cb34-153" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_workers"</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb34-154"><a href="#cb34-154" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_tasks"</span><span class="op">:</span> <span class="dv">3</span></span>
<span id="cb34-155"><a href="#cb34-155" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb34-156"><a href="#cb34-156" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-157"><a href="#cb34-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-158"><a href="#cb34-158" aria-hidden="true" tabindex="-1"></a>The <span class="in">`toy-data`</span> example dataset is available as an example <span class="co">[</span><span class="ot">in the `peerannot` repository</span><span class="co">](https://github.com/peerannot/peerannot/tree/main/datasets/toy-data)</span>.</span>
<span id="cb34-159"><a href="#cb34-159" aria-hidden="true" tabindex="-1"></a>Classical datasets in crowdsourcing such as $\texttt{CIFAR-10H}$ <span class="co">[</span><span class="ot">@peterson_human_2019</span><span class="co">]</span> and $\texttt{LabelMe}$ <span class="co">[</span><span class="ot">@rodrigues2014gaussian</span><span class="co">]</span> can be installed directly using <span class="in">`peerannot`</span>.</span>
<span id="cb34-160"><a href="#cb34-160" aria-hidden="true" tabindex="-1"></a>To install them, run the <span class="in">`install`</span> command from <span class="in">`peerannot`</span>:</span>
<span id="cb34-163"><a href="#cb34-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-164"><a href="#cb34-164" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-165"><a href="#cb34-165" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb34-166"><a href="#cb34-166" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>labelme.py</span>
<span id="cb34-167"><a href="#cb34-167" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>cifar10h.py</span>
<span id="cb34-168"><a href="#cb34-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-169"><a href="#cb34-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-170"><a href="#cb34-170" aria-hidden="true" tabindex="-1"></a>For both $\texttt{CIFAR-10H}$ and $\texttt{LabelMe}$, the dataset was originally released in classical supervised learning form (without crowdsourcing).</span>
<span id="cb34-171"><a href="#cb34-171" aria-hidden="true" tabindex="-1"></a>These labels are used as ground truth in evaluations and visualizations.</span>
<span id="cb34-172"><a href="#cb34-172" aria-hidden="true" tabindex="-1"></a>However, we emphasize that crowdsourcing strategies do not rely on the ground truth (only on the workers' answers).</span>
<span id="cb34-173"><a href="#cb34-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-176"><a href="#cb34-176" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-177"><a href="#cb34-177" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-178"><a href="#cb34-178" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-cifarh</span></span>
<span id="cb34-179"><a href="#cb34-179" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Example of images from CIFAR-10H. We display images rowise according to the ground truth label.</span></span>
<span id="cb34-180"><a href="#cb34-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-181"><a href="#cb34-181" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb34-182"><a href="#cb34-182" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb34-183"><a href="#cb34-183" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb34-184"><a href="#cb34-184" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb34-185"><a href="#cb34-185" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb34-186"><a href="#cb34-186" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb34-187"><a href="#cb34-187" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb34-188"><a href="#cb34-188" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb34-189"><a href="#cb34-189" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb34-190"><a href="#cb34-190" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb34-191"><a href="#cb34-191" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb34-192"><a href="#cb34-192" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb34-193"><a href="#cb34-193" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb34-194"><a href="#cb34-194" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-195"><a href="#cb34-195" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"bird"</span>, <span class="dv">1</span>: <span class="st">"car"</span>, <span class="dv">2</span>: <span class="st">"cat"</span>, <span class="dv">3</span>: <span class="st">"deer"</span>, <span class="dv">4</span>: <span class="st">"dog"</span>, <span class="dv">5</span>: <span class="st">"frog"</span>, <span class="dv">6</span>: <span class="st">"horse"</span>, <span class="dv">7</span>: <span class="st">"plane"</span>, <span class="dv">8</span>: <span class="st">"ship"</span>, <span class="dv">9</span>: <span class="st">"truck"</span>}</span>
<span id="cb34-196"><a href="#cb34-196" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb34-197"><a href="#cb34-197" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb34-198"><a href="#cb34-198" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb34-199"><a href="#cb34-199" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb34-200"><a href="#cb34-200" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb34-201"><a href="#cb34-201" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb34-202"><a href="#cb34-202" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb34-203"><a href="#cb34-203" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb34-204"><a href="#cb34-204" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb34-205"><a href="#cb34-205" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(wspace<span class="op">=-</span><span class="fl">0.8</span>, hspace<span class="op">=</span><span class="fl">0.25</span>)</span>
<span id="cb34-206"><a href="#cb34-206" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-207"><a href="#cb34-207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-208"><a href="#cb34-208" aria-hidden="true" tabindex="-1"></a>Examples of $\texttt{CIFAR-10H}$ images are available in @fig-cifarh, and $\texttt{LabelMe}$ examples in @fig-labelme here below.</span>
<span id="cb34-209"><a href="#cb34-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-210"><a href="#cb34-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-213"><a href="#cb34-213" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-214"><a href="#cb34-214" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-215"><a href="#cb34-215" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-labelme</span></span>
<span id="cb34-216"><a href="#cb34-216" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Example of images from LabelMe. We display images rowise according to the ground truth label.</span></span>
<span id="cb34-217"><a href="#cb34-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-218"><a href="#cb34-218" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb34-219"><a href="#cb34-219" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb34-220"><a href="#cb34-220" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb34-221"><a href="#cb34-221" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb34-222"><a href="#cb34-222" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb34-223"><a href="#cb34-223" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb34-224"><a href="#cb34-224" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb34-225"><a href="#cb34-225" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb34-226"><a href="#cb34-226" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-227"><a href="#cb34-227" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"coast"</span>, <span class="dv">1</span>: <span class="st">"forest"</span>, <span class="dv">2</span>: <span class="st">"highway"</span>, <span class="dv">3</span>: <span class="st">"insidecity"</span>, <span class="dv">4</span>: <span class="st">"mountain"</span>, <span class="dv">5</span>: <span class="st">"opencountry"</span>, <span class="dv">6</span>: <span class="st">"street"</span>, <span class="dv">7</span>: <span class="st">"tallbuilding"</span>}</span>
<span id="cb34-228"><a href="#cb34-228" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb34-229"><a href="#cb34-229" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb34-230"><a href="#cb34-230" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb34-231"><a href="#cb34-231" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb34-232"><a href="#cb34-232" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb34-233"><a href="#cb34-233" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb34-234"><a href="#cb34-234" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb34-235"><a href="#cb34-235" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb34-236"><a href="#cb34-236" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb34-237"><a href="#cb34-237" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(wspace<span class="op">=-</span><span class="fl">0.8</span>, hspace<span class="op">=</span><span class="fl">0.25</span>)</span>
<span id="cb34-238"><a href="#cb34-238" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-239"><a href="#cb34-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-240"><a href="#cb34-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-241"><a href="#cb34-241" aria-hidden="true" tabindex="-1"></a><span class="fu"># Aggregation strategies in crowdsourcing {#sec-introaggregation}</span></span>
<span id="cb34-242"><a href="#cb34-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-243"><a href="#cb34-243" aria-hidden="true" tabindex="-1"></a>The first question we address with <span class="in">`peerannot`</span> is: *How to aggregate multiple labels into a single label from crowdsourced tasks?*</span>
<span id="cb34-244"><a href="#cb34-244" aria-hidden="true" tabindex="-1"></a>The aggregation step can lead to two types of learnable labels $\hat y_i\in\Delta_{K}$ (where $\Delta_{K}$ is the simplex of dimension $K-1$ : $\Delta_{K}=<span class="sc">\{</span>p     # cmap = cm.get_cmap("Blues")</span>
<span id="cb34-245"><a href="#cb34-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-246"><a href="#cb34-246" aria-hidden="true" tabindex="-1"></a>\in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>: \sum_{k=1}^K p_k = 1, p_k \geq 0 <span class="sc">\}</span>$ ) depending on the use case for each task $x_i$, $i=1,\dots,n_{\text{task}}$:</span>
<span id="cb34-247"><a href="#cb34-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-248"><a href="#cb34-248" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a **hard** label: $\hat y_i$ is a Dirac distribution, this can be encoded as a classical label in $<span class="co">[</span><span class="ot">K</span><span class="co">]</span>$,</span>
<span id="cb34-249"><a href="#cb34-249" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a **soft** label: $\hat y_i\in\Delta_{K}$ can represent any probability distribution on $<span class="co">[</span><span class="ot">K</span><span class="co">]</span>$. In that case, each coordinate of the $K-$ dimensional vector $\hat y_i$ represents the probability to belong to the given class.</span>
<span id="cb34-250"><a href="#cb34-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-251"><a href="#cb34-251" aria-hidden="true" tabindex="-1"></a>Learning from soft labels has been shown to improve learning performance and make the classifier learn the task ambiguity <span class="co">[</span><span class="ot">@zhang2017mixup;@peterson_human_2019;@park2022calibration</span><span class="co">]</span>.</span>
<span id="cb34-252"><a href="#cb34-252" aria-hidden="true" tabindex="-1"></a>However, crowdsourcing is often used as a stepping stone to create a new dataset.</span>
<span id="cb34-253"><a href="#cb34-253" aria-hidden="true" tabindex="-1"></a>We usually expect a classification dataset to associate a task $x_i$ to a single label and not a full probability distribution.</span>
<span id="cb34-254"><a href="#cb34-254" aria-hidden="true" tabindex="-1"></a>In this case, we recommend to release the anonymous answered labels and the aggregation strategy used to reach a consensus on a single label.</span>
<span id="cb34-255"><a href="#cb34-255" aria-hidden="true" tabindex="-1"></a>With <span class="in">`peerannot`</span>, both soft and hard labels can be produced.</span>
<span id="cb34-256"><a href="#cb34-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-257"><a href="#cb34-257" aria-hidden="true" tabindex="-1"></a>Note that when a strategy produces a soft label, a hard label can be easily induced by taking the mode, *i.e.*, the class achieving the maximum probability.</span>
<span id="cb34-258"><a href="#cb34-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-259"><a href="#cb34-259" aria-hidden="true" tabindex="-1"></a>Moreover, the concept of confusion matrices has been commonly used to represent worker abilities.</span>
<span id="cb34-260"><a href="#cb34-260" aria-hidden="true" tabindex="-1"></a>A confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$ of a worker $w_j$ is defined such that $\pi^{(j)}_{k,\ell} = \mathbb{P}(y_i^{(j)}=\ell\vert y_i^\star=k)$.</span>
<span id="cb34-261"><a href="#cb34-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-264"><a href="#cb34-264" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-265"><a href="#cb34-265" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-266"><a href="#cb34-266" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-confusionmatrix</span></span>
<span id="cb34-267"><a href="#cb34-267" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Three profiles of confusion matrices. The spammer answers independent from the ground truth label. Common workers are good for some classes but might confuse two (ore more) labels. Expert workers are good overall.</span></span>
<span id="cb34-268"><a href="#cb34-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-269"><a href="#cb34-269" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.cm <span class="im">as</span> cm</span>
<span id="cb34-270"><a href="#cb34-270" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">0</span>)</span>
<span id="cb34-271"><a href="#cb34-271" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> rng.uniform(<span class="dv">0</span>, <span class="dv">1</span>, (<span class="dv">1</span>, <span class="dv">4</span>))</span>
<span id="cb34-272"><a href="#cb34-272" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">/=</span> mat_spammer.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb34-273"><a href="#cb34-273" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> np.vstack((mat_spammer, mat_spammer))</span>
<span id="cb34-274"><a href="#cb34-274" aria-hidden="true" tabindex="-1"></a>mat_spammer <span class="op">=</span> np.vstack((mat_spammer, mat_spammer))</span>
<span id="cb34-275"><a href="#cb34-275" aria-hidden="true" tabindex="-1"></a>mat_nearperfect <span class="op">=</span> np.clip(np.eye(<span class="dv">4</span>) <span class="op">+</span> rng.normal(<span class="dv">0</span>, <span class="fl">0.1</span>, (<span class="dv">4</span>,<span class="dv">4</span>)), <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb34-276"><a href="#cb34-276" aria-hidden="true" tabindex="-1"></a>mat_nearperfect <span class="op">/=</span> np.<span class="bu">sum</span>(mat_nearperfect, axis<span class="op">=</span><span class="dv">1</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb34-277"><a href="#cb34-277" aria-hidden="true" tabindex="-1"></a>mat_common <span class="op">=</span> np.copy(mat_nearperfect)</span>
<span id="cb34-278"><a href="#cb34-278" aria-hidden="true" tabindex="-1"></a>mat_common[:, [<span class="dv">0</span>, <span class="dv">1</span>]] <span class="op">=</span> mat_common[:, [<span class="dv">1</span>,<span class="dv">0</span>]]</span>
<span id="cb34-279"><a href="#cb34-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-280"><a href="#cb34-280" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hinton(matrix, max_weight<span class="op">=</span><span class="va">None</span>, ax<span class="op">=</span><span class="va">None</span>, classes<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb34-281"><a href="#cb34-281" aria-hidden="true" tabindex="-1"></a>           my_title<span class="op">=</span>{}):</span>
<span id="cb34-282"><a href="#cb34-282" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Draw Hinton diagram for visualizing a weight matrix."""</span></span>
<span id="cb34-283"><a href="#cb34-283" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="cf">if</span> ax <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> plt.gca()</span>
<span id="cb34-284"><a href="#cb34-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-285"><a href="#cb34-285" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> max_weight:</span>
<span id="cb34-286"><a href="#cb34-286" aria-hidden="true" tabindex="-1"></a>        max_weight <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> np.ceil(np.log2(np.<span class="bu">abs</span>(matrix).<span class="bu">max</span>()))</span>
<span id="cb34-287"><a href="#cb34-287" aria-hidden="true" tabindex="-1"></a>    ax.set_title(my_title, y<span class="op">=</span><span class="fl">1.02</span>)</span>
<span id="cb34-288"><a href="#cb34-288" aria-hidden="true" tabindex="-1"></a>    ax.patch.set_facecolor(<span class="st">"white"</span>)</span>
<span id="cb34-289"><a href="#cb34-289" aria-hidden="true" tabindex="-1"></a>    ax.set_aspect(<span class="st">"equal"</span>, <span class="st">"box"</span>)</span>
<span id="cb34-290"><a href="#cb34-290" aria-hidden="true" tabindex="-1"></a>    ax.xaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb34-291"><a href="#cb34-291" aria-hidden="true" tabindex="-1"></a>    ax.yaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb34-292"><a href="#cb34-292" aria-hidden="true" tabindex="-1"></a>    ax.set_xticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb34-293"><a href="#cb34-293" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb34-294"><a href="#cb34-294" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">"True label"</span>)</span>
<span id="cb34-295"><a href="#cb34-295" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"Proposed label"</span>)</span>
<span id="cb34-296"><a href="#cb34-296" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(classes))</span>
<span id="cb34-297"><a href="#cb34-297" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="op">-</span><span class="dv">1</span>, <span class="bu">len</span>(classes))</span>
<span id="cb34-298"><a href="#cb34-298" aria-hidden="true" tabindex="-1"></a>    ax.set_yticks(<span class="bu">range</span>(<span class="bu">len</span>(classes)))</span>
<span id="cb34-299"><a href="#cb34-299" aria-hidden="true" tabindex="-1"></a>    ax.set_xticklabels(classes, rotation<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb34-300"><a href="#cb34-300" aria-hidden="true" tabindex="-1"></a>    ax.set_yticklabels(classes)</span>
<span id="cb34-301"><a href="#cb34-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-302"><a href="#cb34-302" aria-hidden="true" tabindex="-1"></a>    blues <span class="op">=</span> cm.Blues</span>
<span id="cb34-303"><a href="#cb34-303" aria-hidden="true" tabindex="-1"></a>    newcolors <span class="op">=</span> blues(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">256</span>))</span>
<span id="cb34-304"><a href="#cb34-304" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x, y), w <span class="kw">in</span> np.ndenumerate(matrix[classes, :][:, classes]):</span>
<span id="cb34-305"><a href="#cb34-305" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> np.searchsorted(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">256</span>), w)</span>
<span id="cb34-306"><a href="#cb34-306" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> newcolors[idx]</span>
<span id="cb34-307"><a href="#cb34-307" aria-hidden="true" tabindex="-1"></a>        size <span class="op">=</span> (</span>
<span id="cb34-308"><a href="#cb34-308" aria-hidden="true" tabindex="-1"></a>            np.sqrt(<span class="bu">abs</span>(w) <span class="op">/</span> max_weight)</span>
<span id="cb34-309"><a href="#cb34-309" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb34-310"><a href="#cb34-310" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> np.sqrt(<span class="bu">abs</span>(<span class="fl">1e-8</span>) <span class="op">/</span> max_weight)</span>
<span id="cb34-311"><a href="#cb34-311" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-312"><a href="#cb34-312" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> y, x</span>
<span id="cb34-313"><a href="#cb34-313" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle(</span>
<span id="cb34-314"><a href="#cb34-314" aria-hidden="true" tabindex="-1"></a>            [x <span class="op">-</span> size <span class="op">/</span> <span class="fl">2.1</span>, y <span class="op">-</span> size <span class="op">/</span> <span class="fl">2.1</span>],</span>
<span id="cb34-315"><a href="#cb34-315" aria-hidden="true" tabindex="-1"></a>            size,</span>
<span id="cb34-316"><a href="#cb34-316" aria-hidden="true" tabindex="-1"></a>            size,</span>
<span id="cb34-317"><a href="#cb34-317" aria-hidden="true" tabindex="-1"></a>            facecolor<span class="op">=</span>color,</span>
<span id="cb34-318"><a href="#cb34-318" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span><span class="st">'black'</span>,</span>
<span id="cb34-319"><a href="#cb34-319" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-320"><a href="#cb34-320" aria-hidden="true" tabindex="-1"></a>        ax.add_patch(rect)</span>
<span id="cb34-321"><a href="#cb34-321" aria-hidden="true" tabindex="-1"></a>    ax.margins(y<span class="op">=</span><span class="fl">0.05</span>, x<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb34-322"><a href="#cb34-322" aria-hidden="true" tabindex="-1"></a>    ax.invert_yaxis()</span>
<span id="cb34-323"><a href="#cb34-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-324"><a href="#cb34-324" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-325"><a href="#cb34-325" aria-hidden="true" tabindex="-1"></a>hinton(mat_spammer, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Spammer worker"</span>, ax<span class="op">=</span>axs[<span class="dv">0</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb34-326"><a href="#cb34-326" aria-hidden="true" tabindex="-1"></a>hinton(mat_common, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Confused worker"</span>, ax<span class="op">=</span>axs[<span class="dv">1</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb34-327"><a href="#cb34-327" aria-hidden="true" tabindex="-1"></a>hinton(mat_nearperfect, <span class="dv">1</span>, my_title<span class="op">=</span><span class="st">"Expert worker"</span>, ax<span class="op">=</span>axs[<span class="dv">2</span>], classes<span class="op">=</span>np.arange(<span class="dv">4</span>))</span>
<span id="cb34-328"><a href="#cb34-328" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylabel(<span class="st">""</span>)</span>
<span id="cb34-329"><a href="#cb34-329" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].set_ylabel(<span class="st">""</span>)</span>
<span id="cb34-330"><a href="#cb34-330" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb34-331"><a href="#cb34-331" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-332"><a href="#cb34-332" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-333"><a href="#cb34-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-334"><a href="#cb34-334" aria-hidden="true" tabindex="-1"></a>In @fig-confusionmatrix, we illustrat multiple profiles of workers.</span>
<span id="cb34-335"><a href="#cb34-335" aria-hidden="true" tabindex="-1"></a>In particular, one type of worker that can hurt data quality is the spammer.</span>
<span id="cb34-336"><a href="#cb34-336" aria-hidden="true" tabindex="-1"></a>@raykar_ranking_2011 defined a spammer as a worker that answers randomly as:</span>
<span id="cb34-337"><a href="#cb34-337" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-338"><a href="#cb34-338" aria-hidden="true" tabindex="-1"></a>\forall k\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>,\ \mathbb{P}(y_i^{(j)}=k|y_i^\star) = \mathbb{P}(y_i^{(j)}=k)\enspace.</span>
<span id="cb34-339"><a href="#cb34-339" aria-hidden="true" tabindex="-1"></a>$${#eq-spammer}</span>
<span id="cb34-340"><a href="#cb34-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-341"><a href="#cb34-341" aria-hidden="true" tabindex="-1"></a>As the probability distribution by row represent the confusion given a ground truth label, the spammer has a confusion matrix with near-identical rows.</span>
<span id="cb34-342"><a href="#cb34-342" aria-hidden="true" tabindex="-1"></a>Apart from the spammer, common mistakes often involve workers ming-up one or several classes.</span>
<span id="cb34-343"><a href="#cb34-343" aria-hidden="true" tabindex="-1"></a>Expert workers have a confusion matrix near the identity matrix.</span>
<span id="cb34-344"><a href="#cb34-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-345"><a href="#cb34-345" aria-hidden="true" tabindex="-1"></a><span class="fu">## Classical models</span></span>
<span id="cb34-346"><a href="#cb34-346" aria-hidden="true" tabindex="-1"></a>We list below the most classical aggregation strategies used in crowdsourcing.</span>
<span id="cb34-347"><a href="#cb34-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-348"><a href="#cb34-348" aria-hidden="true" tabindex="-1"></a><span class="fu">### Majority vote (MV)</span></span>
<span id="cb34-349"><a href="#cb34-349" aria-hidden="true" tabindex="-1"></a>The most intuitive way to create a label from multiple answers for any type of crowdsourced task is to take the majority vote (MV). Yet, this strategy has many shortcomings <span class="co">[</span><span class="ot">@james1998majority</span><span class="co">]</span> -- there is no noise model, no worker reliability estimated, no task difficulty involved and especially no way to remove poorly performing workers. This standard choice can be expressed as:</span>
<span id="cb34-350"><a href="#cb34-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-351"><a href="#cb34-351" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-352"><a href="#cb34-352" aria-hidden="true" tabindex="-1"></a>\hat y_i^{\text{MV}} = \operatornamewithlimits{argmax}_{k\in[K]} \sum_{j\in\mathcal{A}(x_i)} \mathbf{1}_{<span class="sc">\{</span>y_i^{(j)}=k<span class="sc">\}</span>} \enspace.</span>
<span id="cb34-353"><a href="#cb34-353" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-354"><a href="#cb34-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-355"><a href="#cb34-355" aria-hidden="true" tabindex="-1"></a><span class="fu">### Naive soft (NS)</span></span>
<span id="cb34-356"><a href="#cb34-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-357"><a href="#cb34-357" aria-hidden="true" tabindex="-1"></a>One pitfall with MV is that the label produced is hard, hence the ambiguity is discarded by construction. To remedy this, the Naive Soft (NS) labeling consists in using the empirical distribution as the task label:</span>
<span id="cb34-358"><a href="#cb34-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-359"><a href="#cb34-359" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-360"><a href="#cb34-360" aria-hidden="true" tabindex="-1"></a>\hat y_i^{\text{NS}} = \bigg(\frac{1}{\vert\mathcal{A}(x_i)\vert}\sum_{j\in\mathcal{A}(x_i)} \mathbf{1}_{\{y_i^{(j)}=k\}} \bigg)_{j\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>} \enspace.</span>
<span id="cb34-361"><a href="#cb34-361" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-362"><a href="#cb34-362" aria-hidden="true" tabindex="-1"></a>With the NS label, we keep the ambiguity, but all workers and all tasks are put on the same level. In practice, it is known that each worker comes with their abilities, thus modeling this knowledge can produce better results.</span>
<span id="cb34-363"><a href="#cb34-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-364"><a href="#cb34-364" aria-hidden="true" tabindex="-1"></a><span class="fu">### Dawid and Skene (DS)</span></span>
<span id="cb34-365"><a href="#cb34-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-366"><a href="#cb34-366" aria-hidden="true" tabindex="-1"></a>Refining the aggregation, researchers began creating a noise model to take into account the workers' abilities.</span>
<span id="cb34-367"><a href="#cb34-367" aria-hidden="true" tabindex="-1"></a>These types of models are most often optimized using EM-based procedures and one of the most studied <span class="co">[</span><span class="ot">@gao2013minimax</span><span class="co">]</span> and applied <span class="co">[</span><span class="ot">@servajean2017crowdsourcing;@rodrigues2018deep</span><span class="co">]</span> is the Dawid and Skene's (DS) model <span class="co">[</span><span class="ot">@dawid_maximum_1979</span><span class="co">]</span>.</span>
<span id="cb34-368"><a href="#cb34-368" aria-hidden="true" tabindex="-1"></a>Assuming the workers are answering tasks independently, this model boils down to model pairwise confusions between each possible class.</span>
<span id="cb34-369"><a href="#cb34-369" aria-hidden="true" tabindex="-1"></a>Each worker $w_j$ is assigned a confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$ as described in @sec-introaggregation.</span>
<span id="cb34-370"><a href="#cb34-370" aria-hidden="true" tabindex="-1"></a>The model assumes that for a task $x_i$, conditionally on the true label $y_i^\star=k$ the label distribution of the worker's answer follows a multinomial distribution with probabilities $\pi^{(j)}_{k,\cdot}$ for each worker.</span>
<span id="cb34-371"><a href="#cb34-371" aria-hidden="true" tabindex="-1"></a>Each class has a prevalence $\rho_k=\mathbb{P}(y_i^\star=k)$ to appear in the dataset.</span>
<span id="cb34-372"><a href="#cb34-372" aria-hidden="true" tabindex="-1"></a>Using the independence between workers, we obtain the following likelihood to maximize (with latent variables $\rho$, $<span class="sc">\{</span>\pi^{(j)}<span class="sc">\}</span>_{j}$ and $T$ and observed variables $\{y_i^{(j)}\}_{i,j}$):</span>
<span id="cb34-373"><a href="#cb34-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-374"><a href="#cb34-374" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-375"><a href="#cb34-375" aria-hidden="true" tabindex="-1"></a>\displaystyle\prod_{i\in <span class="co">[</span><span class="ot">n_{\texttt{task}}</span><span class="co">]</span>}\prod_{k \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\bigg<span class="co">[</span><span class="ot">\rho_k\prod_{j\in [n_{\texttt{worker}}</span><span class="co">]</span>}</span>
<span id="cb34-376"><a href="#cb34-376" aria-hidden="true" tabindex="-1"></a>    \prod_{k\in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\big(\pi^{(j)}_{k, k}\big)^{\mathbf{1}_{<span class="sc">\{</span>y_i^{(j)}=k<span class="sc">\}</span>}}</span>
<span id="cb34-377"><a href="#cb34-377" aria-hidden="true" tabindex="-1"></a>    \bigg]^{T_{i,k}},</span>
<span id="cb34-378"><a href="#cb34-378" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-379"><a href="#cb34-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-380"><a href="#cb34-380" aria-hidden="true" tabindex="-1"></a>with $T_{i,k}=\mathbf{1}_{\{y_i^{\star}=k \}}$. The final aggregated soft label is $\hat y_i^{\text{DS}} = T_{i,\cdot}$.</span>
<span id="cb34-381"><a href="#cb34-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-382"><a href="#cb34-382" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for the DS model</span><span class="co">](./figures/bayesien_plaque_ds.png)</span>{fig-align="center"}</span>
<span id="cb34-383"><a href="#cb34-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-384"><a href="#cb34-384" aria-hidden="true" tabindex="-1"></a><span class="fu">### Variations around the DS model</span></span>
<span id="cb34-385"><a href="#cb34-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-386"><a href="#cb34-386" aria-hidden="true" tabindex="-1"></a>Many variants of the DS model have been proposed in the literature, using Dirichlet priors on the confusion matrices <span class="co">[</span><span class="ot">@passonneau-carpenter-2014-benefits</span><span class="co">]</span>, using $1\leq L\leq n_{\text{worker}}$ clusters of workers <span class="co">[</span><span class="ot">@imamura2018analysis</span><span class="co">]</span> (DSWC) or even faster implementation that produces only hard labels <span class="co">[</span><span class="ot">@sinha2018fast</span><span class="co">]</span>.</span>
<span id="cb34-387"><a href="#cb34-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-388"><a href="#cb34-388" aria-hidden="true" tabindex="-1"></a>In particular, the DSWC strategy (Dawid and Skene with Worker Clustering) highly reduces the dimension of the parameters in the DS model.</span>
<span id="cb34-389"><a href="#cb34-389" aria-hidden="true" tabindex="-1"></a>In the original model, there are $K^2\times n_{\text{worker}}$ parameters to be estimated for the confusion matrices only.</span>
<span id="cb34-390"><a href="#cb34-390" aria-hidden="true" tabindex="-1"></a>The DSWC model reduces them to $K^2\times L + L$ parameters.</span>
<span id="cb34-391"><a href="#cb34-391" aria-hidden="true" tabindex="-1"></a>Indeed, there are $L$ confusion matrices $<span class="sc">\{</span>\Lambda_1,\dots,\Lambda_L<span class="sc">\}</span>$ and the confusion matrix of a cluster is assumed drawn from a multinomial distribution with weights $(\tau_1,\dots,\tau_L)$, such that $\mathbb{P}(\pi^{(j)}=\Lambda_\ell)=\tau_\ell$.</span>
<span id="cb34-392"><a href="#cb34-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-393"><a href="#cb34-393" aria-hidden="true" tabindex="-1"></a><span class="fu">### Generative model of Labels, Abilities, and Difficulties (GLAD)</span></span>
<span id="cb34-394"><a href="#cb34-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-395"><a href="#cb34-395" aria-hidden="true" tabindex="-1"></a>Finally, we present the GLAD model <span class="co">[</span><span class="ot">@whitehill_whose_2009</span><span class="co">]</span> that not only takes into account the worker's ability, but also the task difficulty in the noise model.</span>
<span id="cb34-396"><a href="#cb34-396" aria-hidden="true" tabindex="-1"></a>The likelihood is optimized using an EM algorithm to recover the soft label $\hat y_i^{\text{GLAD}}$.</span>
<span id="cb34-397"><a href="#cb34-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-398"><a href="#cb34-398" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for the GLAD model</span><span class="co">](./figures/schema_bayesien_glad.png)</span>{fig-align="center"}</span>
<span id="cb34-399"><a href="#cb34-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-400"><a href="#cb34-400" aria-hidden="true" tabindex="-1"></a>Denoting $\alpha_j\in\mathbb{R}$ the worker ability (the higher the better) and $\beta_i\in\mathbb{R}^+_\star$ the task's difficulty (the higher the easier), the model noise is:</span>
<span id="cb34-401"><a href="#cb34-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-402"><a href="#cb34-402" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-403"><a href="#cb34-403" aria-hidden="true" tabindex="-1"></a>\mathbb{P}(y_i^{(j)}=y_i^\star\vert \alpha_j,\beta_i) = \frac{1}{1+\exp(-\alpha_j\beta_i)} \enspace.</span>
<span id="cb34-404"><a href="#cb34-404" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-405"><a href="#cb34-405" aria-hidden="true" tabindex="-1"></a>GLAD's model also assumes that the errors are uniform across wrong labels, thus:</span>
<span id="cb34-406"><a href="#cb34-406" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-407"><a href="#cb34-407" aria-hidden="true" tabindex="-1"></a>\forall k \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>,\ \mathbb{P}(y_i^{(j)}=k\vert y_i^\star\neq k,\alpha_j,\beta_i) = \frac{1}{K-1}\left(1-\frac{1}{1+\exp(-\alpha_j\beta_i)}\right)\enspace.</span>
<span id="cb34-408"><a href="#cb34-408" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-409"><a href="#cb34-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-410"><a href="#cb34-410" aria-hidden="true" tabindex="-1"></a><span class="fu">### Aggregation strategies in `peerannot`</span></span>
<span id="cb34-411"><a href="#cb34-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-412"><a href="#cb34-412" aria-hidden="true" tabindex="-1"></a>All of these aggregation strategies -- and more -- are available in the <span class="in">`peerannot`</span> library from the <span class="in">`peerannot.models`</span> module.</span>
<span id="cb34-413"><a href="#cb34-413" aria-hidden="true" tabindex="-1"></a>Each model is a class object in its own <span class="in">`Python`</span> file. It inherits from the <span class="in">`CrowdModel`</span> template class and is defined with at least two methods:</span>
<span id="cb34-414"><a href="#cb34-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-415"><a href="#cb34-415" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`run`</span>: includes the optimization procedure to obtain needed weights (*e.g.* the EM algorithm for the DS model),</span>
<span id="cb34-416"><a href="#cb34-416" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`get_probas`</span>: returns the soft labels output for each task.</span>
<span id="cb34-417"><a href="#cb34-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-418"><a href="#cb34-418" aria-hidden="true" tabindex="-1"></a><span class="fu">## Experiments and evaluation of label aggregation strategies {#sec-evaluation-aggregation}</span></span>
<span id="cb34-419"><a href="#cb34-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-420"><a href="#cb34-420" aria-hidden="true" tabindex="-1"></a>One way to evaluate the label aggregation strategies is to measure their accuracy.</span>
<span id="cb34-421"><a href="#cb34-421" aria-hidden="true" tabindex="-1"></a>This means that the underlying ground truth must be known -- or at least for a representative subset.</span>
<span id="cb34-422"><a href="#cb34-422" aria-hidden="true" tabindex="-1"></a>As the set of $n_{\text{task}}$ can be seen as a training set for a future classifier, we denote this metric $\operatornamewithlimits{AccTrain}$ on a dataset $\mathcal{D}$ for some given aggregated label $(\hat y_i)_i$ as:</span>
<span id="cb34-423"><a href="#cb34-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-424"><a href="#cb34-424" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-425"><a href="#cb34-425" aria-hidden="true" tabindex="-1"></a>\operatornamewithlimits{AccTrain}(\mathcal{D}) = \frac{1}{\vert \mathcal{D}\vert}\sum_{i=1}^{\vert\mathcal{D}\vert} \mathbf{1}_{\{y_i^\star=\operatornamewithlimits{argmax}_{k\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\hat y_i<span class="sc">\}</span>} \enspace.</span>
<span id="cb34-426"><a href="#cb34-426" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-427"><a href="#cb34-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-428"><a href="#cb34-428" aria-hidden="true" tabindex="-1"></a>In the following, we write $\operatornamewithlimits{AccTrain}$ for $\operatornamewithlimits{AccTrain}(\mathcal{D}_{\text{train}})$ as we only consider the full training set so there is no ambiguity.</span>
<span id="cb34-429"><a href="#cb34-429" aria-hidden="true" tabindex="-1"></a>While this metric is useful, in practice there are a few arguable issues:</span>
<span id="cb34-430"><a href="#cb34-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-431"><a href="#cb34-431" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the $\operatornamewithlimits{AccTrain}$ metric does not consider the ambiguity of the soft label, only the most probable class, whereas in some contexts ambiguity can be informative,</span>
<span id="cb34-432"><a href="#cb34-432" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>in supervised learning one objective is to identify difficult or mislabeled tasks <span class="co">[</span><span class="ot">@pleiss_identifying_2020;@lefort2022improve</span><span class="co">]</span>, pruning those tasks can easily artificially improve the $\operatornamewithlimits{AccTrain}$, but there is no guarantee over the predictive performance of a model based on the newly pruned dataset,</span>
<span id="cb34-433"><a href="#cb34-433" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>in practice, ground truth labels are unknown, thus this metric would not be computable.</span>
<span id="cb34-434"><a href="#cb34-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-435"><a href="#cb34-435" aria-hidden="true" tabindex="-1"></a>We first consider classical simulation settings in the literature that can easily be created and reproduced using <span class="in">`peerannot`</span>.</span>
<span id="cb34-436"><a href="#cb34-436" aria-hidden="true" tabindex="-1"></a>For each dataset, we present the distribution of the number of workers per task $(|\mathcal{A}(x_i)|)_i$ @eq-workerset on the right and the distribution of the number of tasks per worker $(|\mathcal{T}(w_j)|)_j$ @eq-taskset on the left.</span>
<span id="cb34-437"><a href="#cb34-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-438"><a href="#cb34-438" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated independent mistakes simu-independent {#sec-simu-independent}</span></span>
<span id="cb34-439"><a href="#cb34-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-440"><a href="#cb34-440" aria-hidden="true" tabindex="-1"></a>The independent mistakes consider that each worker $w_j$ answers follows a multinomial distribution with weights given at the row $y_i^\star$ of their confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$. Each confusion row in the confusion matrix is generated uniformly in the simplex. Then, we make the matrix diagonally dominant (to represent non-adversarial workers) by switching the diagonal term with the maximum value by row.</span>
<span id="cb34-441"><a href="#cb34-441" aria-hidden="true" tabindex="-1"></a>Answers are independent of one another as each matrix is generated independently and each worker answers independently of other workers.</span>
<span id="cb34-442"><a href="#cb34-442" aria-hidden="true" tabindex="-1"></a>In this setting, the DS model is expected to perform better with enough data as we are simulating data from its assumed noise model.</span>
<span id="cb34-443"><a href="#cb34-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-444"><a href="#cb34-444" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=200$ tasks and $n_{\text{worker}}=30$ workers with $K=5$ possible classes. Each task $x_i$ receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb34-445"><a href="#cb34-445" aria-hidden="true" tabindex="-1"></a>With $200$ tasks and $30$ workers, asking for $10$ leads to around $\frac{200\times 10}{30}\simeq 67$ tasks per worker (with variations due to randomness in the affectations).</span>
<span id="cb34-448"><a href="#cb34-448" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-449"><a href="#cb34-449" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-450"><a href="#cb34-450" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb34-451"><a href="#cb34-451" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb34-452"><a href="#cb34-452" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb34-453"><a href="#cb34-453" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent</span>
<span id="cb34-454"><a href="#cb34-454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-457"><a href="#cb34-457" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-458"><a href="#cb34-458" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-459"><a href="#cb34-459" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> peerannot.helpers.helpers_visu <span class="im">import</span> feedback_effort, working_load</span>
<span id="cb34-460"><a href="#cb34-460" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb34-461"><a href="#cb34-461" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb34-462"><a href="#cb34-462" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> MaxNLocator</span>
<span id="cb34-463"><a href="#cb34-463" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb34-464"><a href="#cb34-464" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb34-465"><a href="#cb34-465" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb34-466"><a href="#cb34-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-467"><a href="#cb34-467" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb34-468"><a href="#cb34-468" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb34-469"><a href="#cb34-469" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-470"><a href="#cb34-470" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb34-471"><a href="#cb34-471" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-472"><a href="#cb34-472" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb34-473"><a href="#cb34-473" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb34-474"><a href="#cb34-474" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb34-475"><a href="#cb34-475" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-476"><a href="#cb34-476" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb34-477"><a href="#cb34-477" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb34-478"><a href="#cb34-478" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-479"><a href="#cb34-479" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb34-480"><a href="#cb34-480" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-481"><a href="#cb34-481" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb34-482"><a href="#cb34-482" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb34-483"><a href="#cb34-483" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb34-484"><a href="#cb34-484" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-485"><a href="#cb34-485" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-486"><a href="#cb34-486" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-487"><a href="#cb34-487" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-488"><a href="#cb34-488" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-489"><a href="#cb34-489" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb34-490"><a href="#cb34-490" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb34-491"><a href="#cb34-491" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-492"><a href="#cb34-492" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-493"><a href="#cb34-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-494"><a href="#cb34-494" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb34-495"><a href="#cb34-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-498"><a href="#cb34-498" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-499"><a href="#cb34-499" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-500"><a href="#cb34-500" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb34-501"><a href="#cb34-501" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb34-502"><a href="#cb34-502" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-503"><a href="#cb34-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-506"><a href="#cb34-506" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-507"><a href="#cb34-507" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-independent</span></span>
<span id="cb34-508"><a href="#cb34-508" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated independent mistakes considering classical feature-blind label aggregation strategies</span></span>
<span id="cb34-509"><a href="#cb34-509" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-510"><a href="#cb34-510" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb34-511"><a href="#cb34-511" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb34-512"><a href="#cb34-512" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb34-513"><a href="#cb34-513" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent"</span></span>
<span id="cb34-514"><a href="#cb34-514" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb34-515"><a href="#cb34-515" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb34-516"><a href="#cb34-516" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb34-517"><a href="#cb34-517" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb34-518"><a href="#cb34-518" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb34-519"><a href="#cb34-519" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb34-520"><a href="#cb34-520" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb34-521"><a href="#cb34-521" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb34-522"><a href="#cb34-522" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb34-523"><a href="#cb34-523" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-524"><a href="#cb34-524" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb34-525"><a href="#cb34-525" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb34-526"><a href="#cb34-526" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-527"><a href="#cb34-527" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb34-528"><a href="#cb34-528" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb34-529"><a href="#cb34-529" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb34-530"><a href="#cb34-530" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb34-531"><a href="#cb34-531" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb34-532"><a href="#cb34-532" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb34-533"><a href="#cb34-533" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb34-534"><a href="#cb34-534" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-535"><a href="#cb34-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-536"><a href="#cb34-536" aria-hidden="true" tabindex="-1"></a>As expected by the simulation framework, @tbl-simu-independent fits the DS model, thus leading to better accuracy to retrieve the simulated labels for the DS model. The MV aggregation does not consider any worker-ability scoring or the task's difficulty and performs the worse.</span>
<span id="cb34-537"><a href="#cb34-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-538"><a href="#cb34-538" aria-hidden="true" tabindex="-1"></a>**Remark.** <span class="in">`peerannot`</span> can also simulate datasets with an imbalanced number of votes chosen uniformly at random between $1$ and the number of workers available). For example:</span>
<span id="cb34-539"><a href="#cb34-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-542"><a href="#cb34-542" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-543"><a href="#cb34-543" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-544"><a href="#cb34-544" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb34-545"><a href="#cb34-545" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb34-546"><a href="#cb34-546" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>imbalance<span class="op">-</span>votes <span class="op">\</span></span>
<span id="cb34-547"><a href="#cb34-547" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb34-548"><a href="#cb34-548" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">-</span>imbalanced<span class="op">/</span></span>
<span id="cb34-549"><a href="#cb34-549" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-550"><a href="#cb34-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-551"><a href="#cb34-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-554"><a href="#cb34-554" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-555"><a href="#cb34-555" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-556"><a href="#cb34-556" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb34-557"><a href="#cb34-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-558"><a href="#cb34-558" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb34-559"><a href="#cb34-559" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb34-560"><a href="#cb34-560" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-561"><a href="#cb34-561" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb34-562"><a href="#cb34-562" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-563"><a href="#cb34-563" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb34-564"><a href="#cb34-564" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb34-565"><a href="#cb34-565" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb34-566"><a href="#cb34-566" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-567"><a href="#cb34-567" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb34-568"><a href="#cb34-568" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb34-569"><a href="#cb34-569" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-570"><a href="#cb34-570" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb34-571"><a href="#cb34-571" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-572"><a href="#cb34-572" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb34-573"><a href="#cb34-573" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb34-574"><a href="#cb34-574" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-575"><a href="#cb34-575" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-576"><a href="#cb34-576" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-577"><a href="#cb34-577" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-578"><a href="#cb34-578" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-579"><a href="#cb34-579" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb34-580"><a href="#cb34-580" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb34-581"><a href="#cb34-581" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-582"><a href="#cb34-582" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-583"><a href="#cb34-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-584"><a href="#cb34-584" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb34-585"><a href="#cb34-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-588"><a href="#cb34-588" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-589"><a href="#cb34-589" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-590"><a href="#cb34-590" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb34-591"><a href="#cb34-591" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">-</span>imbalanced<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb34-592"><a href="#cb34-592" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-593"><a href="#cb34-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-596"><a href="#cb34-596" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-597"><a href="#cb34-597" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-independent-imb</span></span>
<span id="cb34-598"><a href="#cb34-598" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated independent mistakes with an imbalanced number of votes per task considering classical feature-blind label aggregation strategies</span></span>
<span id="cb34-599"><a href="#cb34-599" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-600"><a href="#cb34-600" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb34-601"><a href="#cb34-601" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb34-602"><a href="#cb34-602" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb34-603"><a href="#cb34-603" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent-imbalanced"</span></span>
<span id="cb34-604"><a href="#cb34-604" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb34-605"><a href="#cb34-605" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb34-606"><a href="#cb34-606" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb34-607"><a href="#cb34-607" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb34-608"><a href="#cb34-608" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb34-609"><a href="#cb34-609" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb34-610"><a href="#cb34-610" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb34-611"><a href="#cb34-611" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb34-612"><a href="#cb34-612" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb34-613"><a href="#cb34-613" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-614"><a href="#cb34-614" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb34-615"><a href="#cb34-615" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb34-616"><a href="#cb34-616" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-617"><a href="#cb34-617" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb34-618"><a href="#cb34-618" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb34-619"><a href="#cb34-619" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb34-620"><a href="#cb34-620" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb34-621"><a href="#cb34-621" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb34-622"><a href="#cb34-622" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb34-623"><a href="#cb34-623" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb34-624"><a href="#cb34-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-625"><a href="#cb34-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-626"><a href="#cb34-626" aria-hidden="true" tabindex="-1"></a>While more realistic, working with an imbalanced number of votes per task can lead to disrupting orders of performance for some strategies (here GLAD is downgraded).</span>
<span id="cb34-627"><a href="#cb34-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-628"><a href="#cb34-628" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated correlated mistakes</span></span>
<span id="cb34-629"><a href="#cb34-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-630"><a href="#cb34-630" aria-hidden="true" tabindex="-1"></a>The correlated mistakes are also known as the student-teacher setting. Consider that the crowd of workers is divided into two categories: teachers and students (with $n_{\text{teacher}} + n_{\text{student}}=n_{\text{worker}}$). Each student is randomly assigned to one teacher at the beginning of the experiment. We generate the (diagonally dominant as in @sec-simu-independent) confusion matrices of each teacher and the the student share the same confusion matrix as their associated teacher. Hence, clustering strategies are expected to perform best in this context. Then, they all answer independently, following a multinomial distribution with weights given at the row $y_i^\star$ of their confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$.</span>
<span id="cb34-631"><a href="#cb34-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-632"><a href="#cb34-632" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=200$ tasks and $n_{\text{worker}}=30$ with $80\%$ of students in the crowd. There are $K=5$ possible classes. Each task receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb34-633"><a href="#cb34-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-636"><a href="#cb34-636" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-637"><a href="#cb34-637" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-638"><a href="#cb34-638" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb34-639"><a href="#cb34-639" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy student<span class="op">-</span>teacher <span class="op">\</span></span>
<span id="cb34-640"><a href="#cb34-640" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.8</span> <span class="op">\</span></span>
<span id="cb34-641"><a href="#cb34-641" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb34-642"><a href="#cb34-642" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>student_teacher</span>
<span id="cb34-643"><a href="#cb34-643" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-644"><a href="#cb34-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-645"><a href="#cb34-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-648"><a href="#cb34-648" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-649"><a href="#cb34-649" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-650"><a href="#cb34-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-651"><a href="#cb34-651" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb34-652"><a href="#cb34-652" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb34-653"><a href="#cb34-653" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-654"><a href="#cb34-654" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb34-655"><a href="#cb34-655" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-656"><a href="#cb34-656" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb34-657"><a href="#cb34-657" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb34-658"><a href="#cb34-658" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb34-659"><a href="#cb34-659" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-660"><a href="#cb34-660" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb34-661"><a href="#cb34-661" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb34-662"><a href="#cb34-662" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-663"><a href="#cb34-663" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb34-664"><a href="#cb34-664" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-665"><a href="#cb34-665" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb34-666"><a href="#cb34-666" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb34-667"><a href="#cb34-667" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb34-668"><a href="#cb34-668" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-669"><a href="#cb34-669" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-670"><a href="#cb34-670" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-671"><a href="#cb34-671" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-672"><a href="#cb34-672" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-673"><a href="#cb34-673" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb34-674"><a href="#cb34-674" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb34-675"><a href="#cb34-675" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-676"><a href="#cb34-676" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-677"><a href="#cb34-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-678"><a href="#cb34-678" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb34-679"><a href="#cb34-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-682"><a href="#cb34-682" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-683"><a href="#cb34-683" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-684"><a href="#cb34-684" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb34-685"><a href="#cb34-685" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>student_teacher<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb34-686"><a href="#cb34-686" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-687"><a href="#cb34-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-690"><a href="#cb34-690" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-691"><a href="#cb34-691" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-corr</span></span>
<span id="cb34-692"><a href="#cb34-692" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated correlated mistakes considering classical feature-blind label aggregation strategies</span></span>
<span id="cb34-693"><a href="#cb34-693" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-694"><a href="#cb34-694" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"student_teacher"</span></span>
<span id="cb34-695"><a href="#cb34-695" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb34-696"><a href="#cb34-696" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb34-697"><a href="#cb34-697" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_student-teacher_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb34-698"><a href="#cb34-698" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb34-699"><a href="#cb34-699" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb34-700"><a href="#cb34-700" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb34-701"><a href="#cb34-701" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb34-702"><a href="#cb34-702" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb34-703"><a href="#cb34-703" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb34-704"><a href="#cb34-704" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-705"><a href="#cb34-705" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb34-706"><a href="#cb34-706" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb34-707"><a href="#cb34-707" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-708"><a href="#cb34-708" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb34-709"><a href="#cb34-709" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb34-710"><a href="#cb34-710" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb34-711"><a href="#cb34-711" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb34-712"><a href="#cb34-712" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb34-713"><a href="#cb34-713" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb34-714"><a href="#cb34-714" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb34-715"><a href="#cb34-715" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-716"><a href="#cb34-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-717"><a href="#cb34-717" aria-hidden="true" tabindex="-1"></a>With @tbl-simu-corr, we see that with correlated data ($24$ students and $6$ teachers), using $5$ confusion matrices with DSWC<span class="co">[</span><span class="ot">L=5</span><span class="co">]</span> outperforms the vanilla DS strategy that does not consider the correlations.</span>
<span id="cb34-718"><a href="#cb34-718" aria-hidden="true" tabindex="-1"></a>And the best-performing method here estimates only $10$ confusion matrices (instead of $30$ for the vanilla DS model).</span>
<span id="cb34-719"><a href="#cb34-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-720"><a href="#cb34-720" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated mistakes with discrete difficulty levels on tasks</span></span>
<span id="cb34-721"><a href="#cb34-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-722"><a href="#cb34-722" aria-hidden="true" tabindex="-1"></a>For the final simulation setting, we consider the so called discrete difficulty presented in @whitehill_whose_2009.</span>
<span id="cb34-723"><a href="#cb34-723" aria-hidden="true" tabindex="-1"></a>Contrary to other simulations, we here consider that workers belong to two levels of abilities: \texttt{good} or \texttt{bad}, and tasks have two levels of difficulty: \texttt{easy} or \texttt{hard}.</span>
<span id="cb34-724"><a href="#cb34-724" aria-hidden="true" tabindex="-1"></a>The keyword <span class="in">`ratio-diff`</span> indicates the prevalence of each level of difficulty, it is defined as the ratio of \texttt{easy} tasks over \texttt{hard} tasks:</span>
<span id="cb34-725"><a href="#cb34-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-726"><a href="#cb34-726" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-727"><a href="#cb34-727" aria-hidden="true" tabindex="-1"></a>\texttt{ratio-diff} = \frac{\mathbb{P}(\texttt{easy})}{\mathbb{P}(\texttt{hard})} \text{ with } \mathbb{P}(\texttt{easy}) +\mathbb{P}(\texttt{hard}) = 1 \enspace.</span>
<span id="cb34-728"><a href="#cb34-728" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-729"><a href="#cb34-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-730"><a href="#cb34-730" aria-hidden="true" tabindex="-1"></a>Difficulties are then drawn <span class="co">[</span><span class="ot">at random</span><span class="co">](https://peerannot.github.io/datasets/simulate_discrete_difficulty/)</span>.</span>
<span id="cb34-731"><a href="#cb34-731" aria-hidden="true" tabindex="-1"></a>Tasks that are \texttt{easy} are answered correctly by every worker.</span>
<span id="cb34-732"><a href="#cb34-732" aria-hidden="true" tabindex="-1"></a>Tasks that are \texttt{hard} are answered following the confusion matrix assigned to each worker.</span>
<span id="cb34-733"><a href="#cb34-733" aria-hidden="true" tabindex="-1"></a>Each worker then answers independently to the presented tasks.</span>
<span id="cb34-734"><a href="#cb34-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-735"><a href="#cb34-735" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=500$ tasks and $n_{\text{worker}}=100$ with $35\%$ of good workers in the crowd and $50\%$ of easy tasks. There are $K=5$ possible classes. Each task receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb34-736"><a href="#cb34-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-739"><a href="#cb34-739" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-740"><a href="#cb34-740" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-741"><a href="#cb34-741" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb34-742"><a href="#cb34-742" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy discrete<span class="op">-</span>difficulty <span class="op">\</span></span>
<span id="cb34-743"><a href="#cb34-743" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.35</span> <span class="op">--</span>ratio<span class="op">-</span>diff <span class="dv">1</span> <span class="op">\</span></span>
<span id="cb34-744"><a href="#cb34-744" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback <span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb34-745"><a href="#cb34-745" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty</span>
<span id="cb34-746"><a href="#cb34-746" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-747"><a href="#cb34-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-748"><a href="#cb34-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-751"><a href="#cb34-751" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-752"><a href="#cb34-752" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-753"><a href="#cb34-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-754"><a href="#cb34-754" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb34-755"><a href="#cb34-755" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb34-756"><a href="#cb34-756" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-757"><a href="#cb34-757" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb34-758"><a href="#cb34-758" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb34-759"><a href="#cb34-759" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb34-760"><a href="#cb34-760" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb34-761"><a href="#cb34-761" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb34-762"><a href="#cb34-762" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-763"><a href="#cb34-763" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb34-764"><a href="#cb34-764" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb34-765"><a href="#cb34-765" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb34-766"><a href="#cb34-766" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb34-767"><a href="#cb34-767" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb34-768"><a href="#cb34-768" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb34-769"><a href="#cb34-769" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb34-770"><a href="#cb34-770" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb34-771"><a href="#cb34-771" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-772"><a href="#cb34-772" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb34-773"><a href="#cb34-773" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-774"><a href="#cb34-774" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb34-775"><a href="#cb34-775" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb34-776"><a href="#cb34-776" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb34-777"><a href="#cb34-777" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-778"><a href="#cb34-778" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-779"><a href="#cb34-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-780"><a href="#cb34-780" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb34-781"><a href="#cb34-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-784"><a href="#cb34-784" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-785"><a href="#cb34-785" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-786"><a href="#cb34-786" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=2]"</span>, <span class="st">"DSWC[L=5]"</span>]:</span>
<span id="cb34-787"><a href="#cb34-787" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb34-788"><a href="#cb34-788" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-791"><a href="#cb34-791" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-792"><a href="#cb34-792" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-discrete-diff</span></span>
<span id="cb34-793"><a href="#cb34-793" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated mistakes when tasks are associated a difficulty level considering classical feature-blind label aggregation strategies</span></span>
<span id="cb34-794"><a href="#cb34-794" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-795"><a href="#cb34-795" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span></span>
<span id="cb34-796"><a href="#cb34-796" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=2]"</span>: [], <span class="st">"dswc[l=5]"</span>: []}</span>
<span id="cb34-797"><a href="#cb34-797" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb34-798"><a href="#cb34-798" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_discrete-difficulty_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb34-799"><a href="#cb34-799" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb34-800"><a href="#cb34-800" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb34-801"><a href="#cb34-801" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb34-802"><a href="#cb34-802" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb34-803"><a href="#cb34-803" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb34-804"><a href="#cb34-804" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb34-805"><a href="#cb34-805" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-806"><a href="#cb34-806" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb34-807"><a href="#cb34-807" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb34-808"><a href="#cb34-808" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-809"><a href="#cb34-809" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb34-810"><a href="#cb34-810" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb34-811"><a href="#cb34-811" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb34-812"><a href="#cb34-812" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb34-813"><a href="#cb34-813" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb34-814"><a href="#cb34-814" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb34-815"><a href="#cb34-815" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb34-816"><a href="#cb34-816" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-817"><a href="#cb34-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-818"><a href="#cb34-818" aria-hidden="true" tabindex="-1"></a>Finally, in this setting involving task difficulty coefficients, the only strategy that involves a latent variable for the task difficulty, knowing GLAD, outperforms the other strategies (see @tbl-simu-discrete-diff). Note that in this case, creating clusters of answers leads to worse decisions than an MV aggregation.</span>
<span id="cb34-819"><a href="#cb34-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-820"><a href="#cb34-820" aria-hidden="true" tabindex="-1"></a>To summarize our simulations, we see that depending on workers answering strategies, different latent variable models perform best.</span>
<span id="cb34-821"><a href="#cb34-821" aria-hidden="true" tabindex="-1"></a>However, these are unknown outside of a simulation framework, thus if we want to obtain labels from multiple responses, we need to investigate multiple models.</span>
<span id="cb34-822"><a href="#cb34-822" aria-hidden="true" tabindex="-1"></a>This can be done easily with <span class="in">`peerannot`</span> as we demonstrated using the <span class="in">`aggregate`</span> module.</span>
<span id="cb34-823"><a href="#cb34-823" aria-hidden="true" tabindex="-1"></a>However, one might not want to generate a label, simply learn a classifier to predict labels on unseen data. This leads us to another module part of <span class="in">`peerannot`</span>.</span>
<span id="cb34-824"><a href="#cb34-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-825"><a href="#cb34-825" aria-hidden="true" tabindex="-1"></a><span class="fu"># Learning from crowdsourced tasks</span></span>
<span id="cb34-826"><a href="#cb34-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-827"><a href="#cb34-827" aria-hidden="true" tabindex="-1"></a>Most often, tasks are crowdsourced to create a large training set as modern machine learning models require more and more data.</span>
<span id="cb34-828"><a href="#cb34-828" aria-hidden="true" tabindex="-1"></a>The aggregation step then simply becomes the first step in the complete learning pipeline.</span>
<span id="cb34-829"><a href="#cb34-829" aria-hidden="true" tabindex="-1"></a>However, instead of aggregating labels, modern neural networks are directly trained end-to-end from multiple noisy labels.</span>
<span id="cb34-830"><a href="#cb34-830" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-831"><a href="#cb34-831" aria-hidden="true" tabindex="-1"></a><span class="fu">## Popular models</span></span>
<span id="cb34-832"><a href="#cb34-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-833"><a href="#cb34-833" aria-hidden="true" tabindex="-1"></a>In recent years, directly learning a classifier from noisy labels was introduced.</span>
<span id="cb34-834"><a href="#cb34-834" aria-hidden="true" tabindex="-1"></a>Two of the most used models: CrowdLayer <span class="co">[</span><span class="ot">@rodrigues2018deep</span><span class="co">]</span> and CoNAL <span class="co">[</span><span class="ot">@chu2021learning</span><span class="co">]</span>, are directly available in <span class="in">`peerannot`</span>.</span>
<span id="cb34-835"><a href="#cb34-835" aria-hidden="true" tabindex="-1"></a>These two learning strategies directly incorporate a DS-based noise model in the neural network's architecture.</span>
<span id="cb34-836"><a href="#cb34-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-837"><a href="#cb34-837" aria-hidden="true" tabindex="-1"></a><span class="fu">### CrowdLayer</span></span>
<span id="cb34-838"><a href="#cb34-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-839"><a href="#cb34-839" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">CrowdLayer</span><span class="co">](https://github.com/peerannot/peerannot/blob/main/peerannot/models/agg_deep/Crowdlayer.py)</span> trains a classifier with noisy labels as follows.</span>
<span id="cb34-840"><a href="#cb34-840" aria-hidden="true" tabindex="-1"></a>Let the scores (logits) output by a given classifier neural network $\mathcal{C}$ be $z_i=\mathcal{C}(x_i)$.</span>
<span id="cb34-841"><a href="#cb34-841" aria-hidden="true" tabindex="-1"></a>Then CrowdLayer adds as a last layer $\pi\in\mathbb{R}^{n_{\text{worker}}\times K\times K}$, the tensor of all $\pi^{(j)}$'s such that the crossentropy loss $(\mathrm{CE})$ is adapted to the crowdsourcing setting into $\mathcal{L}_{CE}^{\text{CrowdLayer}}$ and computed as:</span>
<span id="cb34-842"><a href="#cb34-842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-843"><a href="#cb34-843" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-844"><a href="#cb34-844" aria-hidden="true" tabindex="-1"></a>\mathcal{L}_{CE}^{\text{CrowdLayer}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(\sigma\left(\pi^{(j)}\sigma\big(z_i\big)\right), y_i^{(j)}) \enspace,</span>
<span id="cb34-845"><a href="#cb34-845" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-846"><a href="#cb34-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-847"><a href="#cb34-847" aria-hidden="true" tabindex="-1"></a>where the crossentropy loss for two distribution $u,v \in\Delta_{K}$ is defined as $\mathrm{CE}(u, v) = \sum_{k\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>} u_k\log(v_k)$.</span>
<span id="cb34-848"><a href="#cb34-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-849"><a href="#cb34-849" aria-hidden="true" tabindex="-1"></a>The confusion matrices are taken into the network architecture as a new layer to transform the output probabilities.</span>
<span id="cb34-850"><a href="#cb34-850" aria-hidden="true" tabindex="-1"></a>The backbone classifier predicts a distribution that is then corrupted through the added layer to learn the worker-specific confusion.</span>
<span id="cb34-851"><a href="#cb34-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-852"><a href="#cb34-852" aria-hidden="true" tabindex="-1"></a><span class="fu">### CoNAL</span></span>
<span id="cb34-853"><a href="#cb34-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-854"><a href="#cb34-854" aria-hidden="true" tabindex="-1"></a>For some datasets, it was noticed that global confusion occurs between the proposed classes.</span>
<span id="cb34-855"><a href="#cb34-855" aria-hidden="true" tabindex="-1"></a>It is the case for example in the $\texttt{LabelMe}$ dataset <span class="co">[</span><span class="ot">@rodrigues2017learning</span><span class="co">]</span> where classes overlap.</span>
<span id="cb34-856"><a href="#cb34-856" aria-hidden="true" tabindex="-1"></a>In this case, @chu2021learning proposed to extend the CrowdLayer model by adding global confusion matrix $\pi^g\in\mathbb{R}^{K\times K}$ to the model on top of each worker's confusion.</span>
<span id="cb34-857"><a href="#cb34-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-858"><a href="#cb34-858" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- ![Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for CoNAL model. Each worker is assigned a confusion matrix $\pi^{(j)}$. A global confusion matrix $\pi^g$ is shared between workers. A tradeoff between the global confusion and the local one is applied.](./figures/schema_bayesien_conal.png){#fig-conal fig-align="center"} --&gt;</span></span>
<span id="cb34-859"><a href="#cb34-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-860"><a href="#cb34-860" aria-hidden="true" tabindex="-1"></a>Given the output $z_i=\mathcal{C}(x_i)\in\mathbb{R}^K$ of a given classifier and task, <span class="co">[</span><span class="ot">CoNAL</span><span class="co">](https://github.com/peerannot/peerannot/blob/main/peerannot/models/agg_deep/CoNAL.py)</span></span>
<span id="cb34-861"><a href="#cb34-861" aria-hidden="true" tabindex="-1"></a>interpolates between the local confusion $\pi^{(j)}z_i$ and the global one $\pi^gz_i$.</span>
<span id="cb34-862"><a href="#cb34-862" aria-hidden="true" tabindex="-1"></a>The loss function is computed as follows:</span>
<span id="cb34-863"><a href="#cb34-863" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-864"><a href="#cb34-864" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb34-865"><a href="#cb34-865" aria-hidden="true" tabindex="-1"></a>&amp;\mathcal{L}_{CE}^{\text{CoNAL}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(h_i^{(j)}, y_i^{(j)}) \enspace, <span class="sc">\\</span></span>
<span id="cb34-866"><a href="#cb34-866" aria-hidden="true" tabindex="-1"></a>&amp;\text{with } h_i^{(j)} = \sigma\left(\big(\omega_i^{(j)} \pi^g + (1-\omega_i^{(j)})\pi^{(j)}\big)z_i\right) \enspace.</span>
<span id="cb34-867"><a href="#cb34-867" aria-hidden="true" tabindex="-1"></a>\end{aligned} \</span>
<span id="cb34-868"><a href="#cb34-868" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-869"><a href="#cb34-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-870"><a href="#cb34-870" aria-hidden="true" tabindex="-1"></a>The interpolation weight $\omega_i^{(j)}$ is unobservable in practice.</span>
<span id="cb34-871"><a href="#cb34-871" aria-hidden="true" tabindex="-1"></a>So, to compute $h_i^{(j)}$, the weight is obtained through an auxiliary network.</span>
<span id="cb34-872"><a href="#cb34-872" aria-hidden="true" tabindex="-1"></a>This network takes in input the image and worker information and outputs a task-related vector $v_i$ and a worker-related vector $u_j$ of the same dimension.</span>
<span id="cb34-873"><a href="#cb34-873" aria-hidden="true" tabindex="-1"></a>Finally, $w_i^{(j)}=(1+\exp(- u_j^\top v_i))^{-1}$.</span>
<span id="cb34-874"><a href="#cb34-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-875"><a href="#cb34-875" aria-hidden="true" tabindex="-1"></a>Both CrowdLayer and CoNAL model worker confusions directly in the classifier's weights to learn from the noisy collected labels and are available in <span class="in">`peerannot`</span> as we will see in the following.</span>
<span id="cb34-876"><a href="#cb34-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-877"><a href="#cb34-877" aria-hidden="true" tabindex="-1"></a><span class="fu">## Prediction error when learning from crowdsourced tasks</span></span>
<span id="cb34-878"><a href="#cb34-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-879"><a href="#cb34-879" aria-hidden="true" tabindex="-1"></a>The $\mathrm{AccTrain}$ metric presented in @sec-evaluation-aggregation might no longer be of interest when training a classifier. Classical error measurements involve a test dataset to estimate the generalization error.</span>
<span id="cb34-880"><a href="#cb34-880" aria-hidden="true" tabindex="-1"></a>To do so, we present hereafter two error metrics. Assuming we trained our classifier $f_\theta$ on a training set:</span>
<span id="cb34-881"><a href="#cb34-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-882"><a href="#cb34-882" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the test accuracy is computed as $\frac{1}{n_{\text{test}}}\sum_{i=1}^{n_{\text{test}}}\mathbf{1}_{\{y_i^\star = \widehat{f_\theta(x_i)}<span class="sc">\}</span>}$</span>
<span id="cb34-883"><a href="#cb34-883" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the expected calibration error <span class="co">[</span><span class="ot">@guo_calibration_2017</span><span class="co">]</span> over $M$ equally spaced bins $I_1,\dots,I_M$ partitionning the interval $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, is computed as:</span>
<span id="cb34-884"><a href="#cb34-884" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-885"><a href="#cb34-885" aria-hidden="true" tabindex="-1"></a>\mathrm{ECE} = \sum_{m=1}^M \frac{|B_m|}{n_{\text{task}}}|\mathrm{acc}(B_m) - \mathrm{conf}(B_m)|\enspace,</span>
<span id="cb34-886"><a href="#cb34-886" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-887"><a href="#cb34-887" aria-hidden="true" tabindex="-1"></a>with $B_m=\{x_i| \mathcal{C}(x_i)_{<span class="co">[</span><span class="ot">1</span><span class="co">]</span>}\in I_m<span class="sc">\}</span>$ the tasks with predicted probability in the $m$-th bin, $\mathrm{acc}(B_m)$ the accuracy of the network for the samples in $B_m$ and $\mathrm{conf}(B_m)$ the associated empirical confidence. More precisely:</span>
<span id="cb34-888"><a href="#cb34-888" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-889"><a href="#cb34-889" aria-hidden="true" tabindex="-1"></a>\mathrm{acc}(B_m) = \frac{1}{|B_m|}\sum_{i\in B_m} \mathbf{1}(\hat y_i=y_i^\star)\quad \text{and} \quad \mathrm{conf}(B_m) = \frac{1}{|B_m|}\sum_{i\in B_m} \sigma(\mathcal{C}(x_i)_{<span class="co">[</span><span class="ot">1</span><span class="co">]</span>})\enspace.</span>
<span id="cb34-890"><a href="#cb34-890" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-891"><a href="#cb34-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-892"><a href="#cb34-892" aria-hidden="true" tabindex="-1"></a>The accuracy represents how well the classifier generalizes, and the expected calibration error (ECE) quantifies the deviation between the accuracy and the confidence of the classifier. Modern neural networks are known to often be overconfident in their predictions <span class="co">[</span><span class="ot">@guo_calibration_2017</span><span class="co">]</span>. However, it has also been remarked that training on crowdsourced data, depending on the strategy, mitigates this confidence issue. That is why we propose to compare them both in our coming experiments.</span>
<span id="cb34-893"><a href="#cb34-893" aria-hidden="true" tabindex="-1"></a>Note that the ECE error estimator is known to be biased <span class="co">[</span><span class="ot">@gruber2022better</span><span class="co">]</span>.</span>
<span id="cb34-894"><a href="#cb34-894" aria-hidden="true" tabindex="-1"></a>Smaller training sets are known to have a higher ECE estimation error.</span>
<span id="cb34-895"><a href="#cb34-895" aria-hidden="true" tabindex="-1"></a>And in the crowdsourcing setting, openly available datasets are often quite small.</span>
<span id="cb34-896"><a href="#cb34-896" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-897"><a href="#cb34-897" aria-hidden="true" tabindex="-1"></a><span class="fu">## Use case with `peerannot` on real datasets {#sec-real-datasets}</span></span>
<span id="cb34-898"><a href="#cb34-898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-899"><a href="#cb34-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-900"><a href="#cb34-900" aria-hidden="true" tabindex="-1"></a>Few real crowdsourcing experiments have been released publicly.</span>
<span id="cb34-901"><a href="#cb34-901" aria-hidden="true" tabindex="-1"></a>Among the available ones, $\texttt{CIFAR-10H}$ <span class="co">[</span><span class="ot">@peterson_human_2019</span><span class="co">]</span> is one of the largest with $10 000$ tasks labeled by workers (the testing set of CIFAR-10).</span>
<span id="cb34-902"><a href="#cb34-902" aria-hidden="true" tabindex="-1"></a>The main limitation of $\texttt{CIFAR-10H}$ is that there are few disagreements between workers and a simple majority voting already leads to a near-perfect $\mathrm{AccTrain}$ error.</span>
<span id="cb34-903"><a href="#cb34-903" aria-hidden="true" tabindex="-1"></a>Hence, comparing the impact of aggregation and end-to-end strategies might not be relevant <span class="co">[</span><span class="ot">@peterson_human_2019;@aitchison2020statistical</span><span class="co">]</span>, it is however a good benchmark for task difficulty identification and worker evaluation scoring</span>
<span id="cb34-904"><a href="#cb34-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-905"><a href="#cb34-905" aria-hidden="true" tabindex="-1"></a>The $\texttt{LabelMe}$ dataset was extracted from crowdsourcing segmentation experiments and a subset of $K=8$ classes was released in @rodrigues2017learning.</span>
<span id="cb34-906"><a href="#cb34-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-907"><a href="#cb34-907" aria-hidden="true" tabindex="-1"></a>Let us use <span class="in">`peerannot`</span> to train a VGG-16 with two dense layers on the $\texttt{LabelMe}$ dataset.</span>
<span id="cb34-908"><a href="#cb34-908" aria-hidden="true" tabindex="-1"></a>Note that this modification was introduced to reach state-of-the-art performance in <span class="co">[</span><span class="ot">@chu2021learning</span><span class="co">]</span>.</span>
<span id="cb34-909"><a href="#cb34-909" aria-hidden="true" tabindex="-1"></a>Other models from the <span class="in">`torchvision`</span> library can be used, such as Resnets, Alexnet *etc.*</span>
<span id="cb34-910"><a href="#cb34-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-913"><a href="#cb34-913" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-914"><a href="#cb34-914" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb34-915"><a href="#cb34-915" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-916"><a href="#cb34-916" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>]:</span>
<span id="cb34-917"><a href="#cb34-917" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>labalme<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb34-918"><a href="#cb34-918" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot train .<span class="op">/</span>labelme <span class="op">-</span>o labelme_${strat} <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>labels<span class="op">=</span>.<span class="op">/</span>labelme<span class="op">/</span>labels<span class="op">/</span>labels_labelme_${strat}.npy <span class="op">--</span>model modellabelme <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">500</span> <span class="op">-</span>m <span class="dv">50</span> <span class="op">-</span>m <span class="dv">150</span> <span class="op">-</span>m <span class="dv">250</span> <span class="op">--</span>scheduler<span class="op">=</span>multistep <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>num<span class="op">-</span>workers<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>pretrained <span class="op">--</span>data<span class="op">-</span>augmentation <span class="op">--</span>optimizer<span class="op">=</span>adam <span class="op">--</span>batch<span class="op">-</span>size<span class="op">=</span><span class="dv">32</span> <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">224</span> <span class="op">--</span>seed<span class="op">=</span><span class="dv">1</span></span>
<span id="cb34-919"><a href="#cb34-919" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"CrowdLayer"</span>, <span class="st">"CoNAL[scale=0]"</span>, <span class="st">"CoNAL[scale=1e-4]"</span>]:</span>
<span id="cb34-920"><a href="#cb34-920" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate<span class="op">-</span>deep .<span class="op">/</span> <span class="op">-</span>o labelme_${strat} <span class="op">--</span>answers .<span class="op">/</span>labelme<span class="op">/</span>answers.json <span class="op">-</span>s ${strat} <span class="op">--</span>model modellabelme <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">224</span> <span class="op">--</span>pretrained <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>n<span class="op">-</span>epochs<span class="op">=</span><span class="dv">500</span> <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.001</span> <span class="op">-</span>m <span class="dv">300</span> <span class="op">-</span>m <span class="dv">400</span> <span class="op">--</span>scheduler<span class="op">=</span>multistep <span class="op">--</span>batch<span class="op">-</span>size<span class="op">=</span><span class="dv">228</span> <span class="op">--</span>optimizer<span class="op">=</span>adam <span class="op">--</span>num<span class="op">-</span>workers<span class="op">=</span><span class="dv">8</span> <span class="op">--</span>data<span class="op">-</span>augmentation <span class="op">--</span>seed<span class="op">=</span><span class="dv">1</span></span>
<span id="cb34-921"><a href="#cb34-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-922"><a href="#cb34-922" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-923"><a href="#cb34-923" aria-hidden="true" tabindex="-1"></a><span class="co"># command to save separately a specific part of conal model (memory intensive otherwise)</span></span>
<span id="cb34-924"><a href="#cb34-924" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb34-925"><a href="#cb34-925" aria-hidden="true" tabindex="-1"></a>best_conal <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4].pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb34-926"><a href="#cb34-926" aria-hidden="true" tabindex="-1"></a>torch.save(best_conal[<span class="st">"noise_adaptation"</span>][<span class="st">"local_confusion_matrices"</span>], path_ <span class="op">/</span> <span class="st">"best_models"</span><span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4]_local_confusion.pth"</span>)</span>
<span id="cb34-927"><a href="#cb34-927" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-928"><a href="#cb34-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-931"><a href="#cb34-931" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-932"><a href="#cb34-932" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-933"><a href="#cb34-933" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-perf-labelme</span></span>
<span id="cb34-934"><a href="#cb34-934" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: Generalization performance on LabelMe dataset depending on the learning strategy from the crowdsourced labels. The network used is a VGG-16 with two dense layers.</span></span>
<span id="cb34-935"><a href="#cb34-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-936"><a href="#cb34-936" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highlight_max(s, props<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb34-937"><a href="#cb34-937" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(s <span class="op">==</span> np.nanmax(s.values), props, <span class="st">''</span>)</span>
<span id="cb34-938"><a href="#cb34-938" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-939"><a href="#cb34-939" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highlight_min(s, props<span class="op">=</span><span class="st">''</span>):</span>
<span id="cb34-940"><a href="#cb34-940" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(s <span class="op">==</span> np.nanmin(s.values), props, <span class="st">''</span>)</span>
<span id="cb34-941"><a href="#cb34-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-942"><a href="#cb34-942" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb34-943"><a href="#cb34-943" aria-hidden="true" tabindex="-1"></a>dir_results <span class="op">=</span> Path().cwd() <span class="op">/</span> <span class="st">'datasets'</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"results"</span></span>
<span id="cb34-944"><a href="#cb34-944" aria-hidden="true" tabindex="-1"></a>meth, accuracy, ece <span class="op">=</span> [], [], []</span>
<span id="cb34-945"><a href="#cb34-945" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> res <span class="kw">in</span> dir_results.glob(<span class="st">"modellabelme/*"</span>):</span>
<span id="cb34-946"><a href="#cb34-946" aria-hidden="true" tabindex="-1"></a>  filename <span class="op">=</span> res.stem</span>
<span id="cb34-947"><a href="#cb34-947" aria-hidden="true" tabindex="-1"></a>  _, mm <span class="op">=</span> filename.split(<span class="st">"_"</span>)</span>
<span id="cb34-948"><a href="#cb34-948" aria-hidden="true" tabindex="-1"></a>  meth.append(mm)</span>
<span id="cb34-949"><a href="#cb34-949" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> <span class="bu">open</span>(res, <span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb34-950"><a href="#cb34-950" aria-hidden="true" tabindex="-1"></a>    dd <span class="op">=</span> json.load(f)</span>
<span id="cb34-951"><a href="#cb34-951" aria-hidden="true" tabindex="-1"></a>    accuracy.append(dd[<span class="st">"test_accuracy"</span>])</span>
<span id="cb34-952"><a href="#cb34-952" aria-hidden="true" tabindex="-1"></a>    ece.append(dd[<span class="st">"test_ece"</span>])</span>
<span id="cb34-953"><a href="#cb34-953" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(<span class="bu">zip</span>(meth, accuracy, ece)), columns<span class="op">=</span>[<span class="st">"method"</span>, <span class="st">"AccTest"</span>, <span class="st">"ECE"</span>])</span>
<span id="cb34-954"><a href="#cb34-954" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"method"</span>] <span class="op">=</span> results[<span class="st">"method"</span>].<span class="bu">str</span>.upper()</span>
<span id="cb34-955"><a href="#cb34-955" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.sort_values(by<span class="op">=</span><span class="st">"AccTest"</span>, ascending<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-956"><a href="#cb34-956" aria-hidden="true" tabindex="-1"></a>results.reset_index(drop<span class="op">=</span><span class="va">True</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-957"><a href="#cb34-957" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb34-958"><a href="#cb34-958" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb34-959"><a href="#cb34-959" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb34-960"><a href="#cb34-960" aria-hidden="true" tabindex="-1"></a>results.<span class="bu">apply</span>(highlight_max, props<span class="op">=</span><span class="st">'background-color:#e6ffe6;'</span>, axis<span class="op">=</span><span class="dv">0</span>, subset<span class="op">=</span>[<span class="st">"AccTest"</span>])</span>
<span id="cb34-961"><a href="#cb34-961" aria-hidden="true" tabindex="-1"></a>results.<span class="bu">apply</span>(highlight_min, props<span class="op">=</span><span class="st">'background-color:#e6ffe6;'</span>, axis<span class="op">=</span><span class="dv">0</span>, subset<span class="op">=</span>[<span class="st">"ECE"</span>])</span>
<span id="cb34-962"><a href="#cb34-962" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb34-963"><a href="#cb34-963" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-964"><a href="#cb34-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-965"><a href="#cb34-965" aria-hidden="true" tabindex="-1"></a>As we can see, CoNAL strategy performs best.</span>
<span id="cb34-966"><a href="#cb34-966" aria-hidden="true" tabindex="-1"></a>In this case, it is expected behavior as CoNAL was created for the $\texttt{LabelMe}$ dataset.</span>
<span id="cb34-967"><a href="#cb34-967" aria-hidden="true" tabindex="-1"></a>However, using <span class="in">`peerannot`</span> we can look into **why modeling common confusion returns better results with this dataset**.</span>
<span id="cb34-968"><a href="#cb34-968" aria-hidden="true" tabindex="-1"></a>To do so, we can explore the datasets from two points of view: worker-wise or task-wise.</span>
<span id="cb34-969"><a href="#cb34-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-970"><a href="#cb34-970" aria-hidden="true" tabindex="-1"></a><span class="fu"># Exploring crowdsourced datasets</span></span>
<span id="cb34-971"><a href="#cb34-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-972"><a href="#cb34-972" aria-hidden="true" tabindex="-1"></a>If a dataset requires crowdsourcing to be labeled, it is because expert knowledge is long and costly to obtain. In the era of big data, where datasets are built using web scraping (or using a platform like <span class="co">[</span><span class="ot">Amazon Mechanical Turk</span><span class="co">](https://www.mturk.com/)</span>), citizen science is popular as it is an easy way to produce many labels.</span>
<span id="cb34-973"><a href="#cb34-973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-974"><a href="#cb34-974" aria-hidden="true" tabindex="-1"></a>However, mistakes and confusions happen during these experiments.</span>
<span id="cb34-975"><a href="#cb34-975" aria-hidden="true" tabindex="-1"></a>Sometimes involuntarily (*e.g.* because the task is too hard or the worker is unable to differentiate between two classes) and sometimes not (*e.g.* the worker is a spammer).</span>
<span id="cb34-976"><a href="#cb34-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-977"><a href="#cb34-977" aria-hidden="true" tabindex="-1"></a>Underlying all the learning models and aggregation strategies, the cornerstone of crowdsourcing is evaluating the trust we put in each worker depending on the presented task. And with the gamification of crowdsourcing <span class="co">[</span><span class="ot">@plantgame2016;@tinati2017investigation</span><span class="co">]</span>, it has become essential to find scoring metrics both for workers and tasks to keep citizens in the loop so to speak.</span>
<span id="cb34-978"><a href="#cb34-978" aria-hidden="true" tabindex="-1"></a>This is the purpose of the identification module in <span class="in">`peerannot`</span>.</span>
<span id="cb34-979"><a href="#cb34-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-980"><a href="#cb34-980" aria-hidden="true" tabindex="-1"></a>Our test cases are both the $\texttt{CIFAR-10H}$ dataset and the $\texttt{LabelMe}$ dataset to compare the worker and task evaluation depending on the number of votes collected.</span>
<span id="cb34-981"><a href="#cb34-981" aria-hidden="true" tabindex="-1"></a>Indeed, the $\texttt{LabelMe}$ dataset has only up to three votes per task whereas $\texttt{CIFAR-10H}$ accounts for nearly fifty votes per task.</span>
<span id="cb34-982"><a href="#cb34-982" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-983"><a href="#cb34-983" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring tasks' difficulty</span></span>
<span id="cb34-984"><a href="#cb34-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-985"><a href="#cb34-985" aria-hidden="true" tabindex="-1"></a>To explore the tasks' intrinsic difficulty, we propose to compare three scoring metrics:</span>
<span id="cb34-986"><a href="#cb34-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-987"><a href="#cb34-987" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the entropy of the NS distribution: the entropy measures the inherent uncertainty of the distribution to the possible outcomes. It is reliable with a big enough and not adversarial crowd.</span>
<span id="cb34-988"><a href="#cb34-988" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>GLAD's scoring: by construction, @whitehill_whose_2009 introduced a scalar coefficient to score the difficulty of a task.</span>
<span id="cb34-989"><a href="#cb34-989" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the Weighted Area Under the Margins (WAUM): introduced in <span class="co">[</span><span class="ot">@lefort2022improve</span><span class="co">]</span>, this weighted area under the margins indicates how difficult it is for a classifier $\mathcal{C}$ to learn a task's label. This procedure is done with a budget of $T&gt;0$ epochs. Given the crowdsourced labels and the trust we have in each worker denoted $s^{(j)}(x_i)&gt;0$, the WAUM of a given task $x_i\in\mathcal{X}$ and a set of crowdsourced labels $\{y_i^{(j)}\}_j \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>^{|\mathcal{A}(x_i)|}$ is defined as:</span>
<span id="cb34-990"><a href="#cb34-990" aria-hidden="true" tabindex="-1"></a>$$\mathrm{WAUM}(x_i) := \frac{1}{|\mathcal{A}(x_i)|}\sum_{j\in\mathcal{A}(x_i)} s^{(j)}(x_i)\left\{\frac{1}{T}\sum_{t=1}^T  \sigma(\mathcal{C}(x_i))_{y_i^{(j)}} - \sigma(\mathcal{C}(x_i))_{<span class="co">[</span><span class="ot">2</span><span class="co">]</span>}\right<span class="sc">\}</span> \enspace.</span>
<span id="cb34-991"><a href="#cb34-991" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb34-992"><a href="#cb34-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-993"><a href="#cb34-993" aria-hidden="true" tabindex="-1"></a>Note that each of these statistics is useful in its context. The entropy can not be used in a setting with small $|\mathcal{A}(x_i)|$ (few labels per task), in particular for the $\texttt{LabelMe}$ dataset it is uninformative.</span>
<span id="cb34-994"><a href="#cb34-994" aria-hidden="true" tabindex="-1"></a>The WAUM can handle any number of labels, but the larger the better. However, as it uses a deep learning classifier, the WAUM needs the tasks $(x_i)_i$ in addition to the proposed labels while the other strategies are feature-blind.</span>
<span id="cb34-995"><a href="#cb34-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-996"><a href="#cb34-996" aria-hidden="true" tabindex="-1"></a><span class="fu">### CIFAR-1OH dataset</span></span>
<span id="cb34-997"><a href="#cb34-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-998"><a href="#cb34-998" aria-hidden="true" tabindex="-1"></a>First, let us consider a dataset with a large number of tasks, annotations and workers: the $\texttt{CIFAR-10H}$ dataset by @peterson_human_2019.</span>
<span id="cb34-999"><a href="#cb34-999" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1002"><a href="#cb34-1002" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1003"><a href="#cb34-1003" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1004"><a href="#cb34-1004" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb34-1005"><a href="#cb34-1005" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb34-1006"><a href="#cb34-1006" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb34-1007"><a href="#cb34-1007" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>method WAUM <span class="op">\</span></span>
<span id="cb34-1008"><a href="#cb34-1008" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json <span class="op">--</span>model resnet34 <span class="op">\</span></span>
<span id="cb34-1009"><a href="#cb34-1009" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">100</span> <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>img<span class="op">-</span>size<span class="op">=</span><span class="dv">32</span> <span class="op">--</span>maxiter<span class="op">-</span>DS<span class="op">=</span><span class="dv">50</span> <span class="op">\</span></span>
<span id="cb34-1010"><a href="#cb34-1010" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>pretrained</span>
<span id="cb34-1011"><a href="#cb34-1011" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1014"><a href="#cb34-1014" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1015"><a href="#cb34-1015" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-1016"><a href="#cb34-1016" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1017"><a href="#cb34-1017" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-difficulty-c10H</span></span>
<span id="cb34-1018"><a href="#cb34-1018" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Most difficult tasks identified depending on the strategy used (entropy, GLAD or WAUM) using a Resnet34.</span></span>
<span id="cb34-1019"><a href="#cb34-1019" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1020"><a href="#cb34-1020" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb34-1021"><a href="#cb34-1021" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> plotly.subplots <span class="im">import</span> make_subplots</span>
<span id="cb34-1022"><a href="#cb34-1022" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb34-1023"><a href="#cb34-1023" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb34-1024"><a href="#cb34-1024" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1025"><a href="#cb34-1025" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> (</span>
<span id="cb34-1026"><a href="#cb34-1026" aria-hidden="true" tabindex="-1"></a>    <span class="st">"plane"</span>,</span>
<span id="cb34-1027"><a href="#cb34-1027" aria-hidden="true" tabindex="-1"></a>    <span class="st">"car"</span>,</span>
<span id="cb34-1028"><a href="#cb34-1028" aria-hidden="true" tabindex="-1"></a>    <span class="st">"bird"</span>,</span>
<span id="cb34-1029"><a href="#cb34-1029" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cat"</span>,</span>
<span id="cb34-1030"><a href="#cb34-1030" aria-hidden="true" tabindex="-1"></a>    <span class="st">"deer"</span>,</span>
<span id="cb34-1031"><a href="#cb34-1031" aria-hidden="true" tabindex="-1"></a>    <span class="st">"dog"</span>,</span>
<span id="cb34-1032"><a href="#cb34-1032" aria-hidden="true" tabindex="-1"></a>    <span class="st">"frog"</span>,</span>
<span id="cb34-1033"><a href="#cb34-1033" aria-hidden="true" tabindex="-1"></a>    <span class="st">"horse"</span>,</span>
<span id="cb34-1034"><a href="#cb34-1034" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ship"</span>,</span>
<span id="cb34-1035"><a href="#cb34-1035" aria-hidden="true" tabindex="-1"></a>    <span class="st">"truck"</span>,</span>
<span id="cb34-1036"><a href="#cb34-1036" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb34-1037"><a href="#cb34-1037" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1038"><a href="#cb34-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1039"><a href="#cb34-1039" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_data(dataset, n_classes, classes):</span>
<span id="cb34-1040"><a href="#cb34-1040" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1041"><a href="#cb34-1041" aria-hidden="true" tabindex="-1"></a>    entrop <span class="op">=</span> np.load(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/entropies.npy"</span>)</span>
<span id="cb34-1042"><a href="#cb34-1042" aria-hidden="true" tabindex="-1"></a>    path_train <span class="op">=</span> Path(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/train"</span>)</span>
<span id="cb34-1043"><a href="#cb34-1043" aria-hidden="true" tabindex="-1"></a>    glad <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.exp(</span>
<span id="cb34-1044"><a href="#cb34-1044" aria-hidden="true" tabindex="-1"></a>        np.load(<span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/glad/difficulties.npy"</span>)[</span>
<span id="cb34-1045"><a href="#cb34-1045" aria-hidden="true" tabindex="-1"></a>            :, <span class="dv">1</span></span>
<span id="cb34-1046"><a href="#cb34-1046" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb34-1047"><a href="#cb34-1047" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-1048"><a href="#cb34-1048" aria-hidden="true" tabindex="-1"></a>    dfwaum <span class="op">=</span> pd.read_csv(</span>
<span id="cb34-1049"><a href="#cb34-1049" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/resnet34/waum_0.01_yang/waum.csv"</span></span>
<span id="cb34-1050"><a href="#cb34-1050" aria-hidden="true" tabindex="-1"></a>    ) <span class="cf">if</span> dataset.startswith(<span class="st">"cifar"</span>) <span class="cf">else</span> pd.read_csv(</span>
<span id="cb34-1051"><a href="#cb34-1051" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"./datasets/</span><span class="sc">{</span>dataset<span class="sc">}</span><span class="ss">/identification/modellabelme/waum_0.01_yang/waum.csv"</span></span>
<span id="cb34-1052"><a href="#cb34-1052" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-1053"><a href="#cb34-1053" aria-hidden="true" tabindex="-1"></a>    tasks <span class="op">=</span> dfwaum.sort_values(by<span class="op">=</span><span class="st">"waum"</span>)[<span class="st">"task"</span>].values</span>
<span id="cb34-1054"><a href="#cb34-1054" aria-hidden="true" tabindex="-1"></a>    img_ns, img_glad, img_waum <span class="op">=</span> [], [], []</span>
<span id="cb34-1055"><a href="#cb34-1055" aria-hidden="true" tabindex="-1"></a>    idxs_ns <span class="op">=</span> np.argsort(entrop)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-1056"><a href="#cb34-1056" aria-hidden="true" tabindex="-1"></a>    idxs_glad <span class="op">=</span> np.argsort(glad)[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-1057"><a href="#cb34-1057" aria-hidden="true" tabindex="-1"></a>    idxs_waum <span class="op">=</span> [Path(task).stem.split(<span class="st">"-"</span>)[<span class="dv">1</span>] <span class="cf">for</span> task <span class="kw">in</span> tasks]</span>
<span id="cb34-1058"><a href="#cb34-1058" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idxs, im_store <span class="kw">in</span> <span class="bu">zip</span>(</span>
<span id="cb34-1059"><a href="#cb34-1059" aria-hidden="true" tabindex="-1"></a>        [idxs_ns, idxs_glad, idxs_waum], [img_ns, img_glad, img_waum]</span>
<span id="cb34-1060"><a href="#cb34-1060" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb34-1061"><a href="#cb34-1061" aria-hidden="true" tabindex="-1"></a>        imgs <span class="op">=</span> []</span>
<span id="cb34-1062"><a href="#cb34-1062" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes):</span>
<span id="cb34-1063"><a href="#cb34-1063" aria-hidden="true" tabindex="-1"></a>            imgs.append([])</span>
<span id="cb34-1064"><a href="#cb34-1064" aria-hidden="true" tabindex="-1"></a>            flag <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb34-1065"><a href="#cb34-1065" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (id_, <span class="bu">file</span>) <span class="kw">in</span> <span class="bu">list</span>(</span>
<span id="cb34-1066"><a href="#cb34-1066" aria-hidden="true" tabindex="-1"></a>                itertools.product(idxs, path_train.glob(<span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss">/*"</span>))</span>
<span id="cb34-1067"><a href="#cb34-1067" aria-hidden="true" tabindex="-1"></a>            ):</span>
<span id="cb34-1068"><a href="#cb34-1068" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">file</span>.stem.endswith(<span class="ss">f"-</span><span class="sc">{</span>id_<span class="sc">}</span><span class="ss">"</span>):</span>
<span id="cb34-1069"><a href="#cb34-1069" aria-hidden="true" tabindex="-1"></a>                    im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="bu">file</span>)</span>
<span id="cb34-1070"><a href="#cb34-1070" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> dataset.startswith(<span class="st">"cifar"</span>):</span>
<span id="cb34-1071"><a href="#cb34-1071" aria-hidden="true" tabindex="-1"></a>                      im <span class="op">=</span> im.resize((<span class="dv">32</span>,<span class="dv">32</span>))</span>
<span id="cb34-1072"><a href="#cb34-1072" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb34-1073"><a href="#cb34-1073" aria-hidden="true" tabindex="-1"></a>                      im <span class="op">=</span> im.resize((<span class="dv">64</span>, <span class="dv">64</span>))  <span class="co"># memory saving</span></span>
<span id="cb34-1074"><a href="#cb34-1074" aria-hidden="true" tabindex="-1"></a>                    imgs[k].append(np.array(im))</span>
<span id="cb34-1075"><a href="#cb34-1075" aria-hidden="true" tabindex="-1"></a>                    flag <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb34-1076"><a href="#cb34-1076" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> flag <span class="op">==</span> <span class="dv">12</span>:</span>
<span id="cb34-1077"><a href="#cb34-1077" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb34-1078"><a href="#cb34-1078" aria-hidden="true" tabindex="-1"></a>            image_k_row1 <span class="op">=</span> np.hstack(imgs[k][:<span class="dv">6</span>])</span>
<span id="cb34-1079"><a href="#cb34-1079" aria-hidden="true" tabindex="-1"></a>            image_k_row2 <span class="op">=</span> np.hstack(imgs[k][<span class="dv">6</span>:])</span>
<span id="cb34-1080"><a href="#cb34-1080" aria-hidden="true" tabindex="-1"></a>            image_k <span class="op">=</span> np.vstack((image_k_row1, image_k_row2))</span>
<span id="cb34-1081"><a href="#cb34-1081" aria-hidden="true" tabindex="-1"></a>            im_store.append(image_k)</span>
<span id="cb34-1082"><a href="#cb34-1082" aria-hidden="true" tabindex="-1"></a>    all_images <span class="op">=</span> [img_ns, img_glad, img_waum]</span>
<span id="cb34-1083"><a href="#cb34-1083" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_images</span>
<span id="cb34-1084"><a href="#cb34-1084" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1085"><a href="#cb34-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1086"><a href="#cb34-1086" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_visible_strat(strategy):</span>
<span id="cb34-1087"><a href="#cb34-1087" aria-hidden="true" tabindex="-1"></a>    ll <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb34-1088"><a href="#cb34-1088" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> strategy, n_classes <span class="op">*</span> (strategy <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb34-1089"><a href="#cb34-1089" aria-hidden="true" tabindex="-1"></a>        ll[k] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb34-1090"><a href="#cb34-1090" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll</span>
<span id="cb34-1091"><a href="#cb34-1091" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1092"><a href="#cb34-1092" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1093"><a href="#cb34-1093" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_layer_strat(strategy):</span>
<span id="cb34-1094"><a href="#cb34-1094" aria-hidden="true" tabindex="-1"></a>    ll_layer <span class="op">=</span> [<span class="st">"below"</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb34-1095"><a href="#cb34-1095" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> strategy, n_classes <span class="op">*</span> (strategy <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb34-1096"><a href="#cb34-1096" aria-hidden="true" tabindex="-1"></a>        ll_layer[k] <span class="op">=</span> <span class="st">"above"</span></span>
<span id="cb34-1097"><a href="#cb34-1097" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll_layer</span>
<span id="cb34-1098"><a href="#cb34-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1099"><a href="#cb34-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1100"><a href="#cb34-1100" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_visible_class(lab):</span>
<span id="cb34-1101"><a href="#cb34-1101" aria-hidden="true" tabindex="-1"></a>    ll <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (n_classes <span class="op">*</span> <span class="dv">3</span>)</span>
<span id="cb34-1102"><a href="#cb34-1102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb34-1103"><a href="#cb34-1103" aria-hidden="true" tabindex="-1"></a>        ll[n_classes <span class="op">*</span> k <span class="op">+</span> lab] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb34-1104"><a href="#cb34-1104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ll</span>
<span id="cb34-1105"><a href="#cb34-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1106"><a href="#cb34-1106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1107"><a href="#cb34-1107" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_plot(n_classes, all_images):</span>
<span id="cb34-1108"><a href="#cb34-1108" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> make_subplots(</span>
<span id="cb34-1109"><a href="#cb34-1109" aria-hidden="true" tabindex="-1"></a>        rows<span class="op">=</span><span class="dv">3</span>, cols<span class="op">=</span><span class="dv">1</span>, subplot_titles<span class="op">=</span>(<span class="st">"Entropy"</span>, <span class="st">"GLAD difficulty"</span>, <span class="st">"WAUM"</span>), vertical_spacing<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb34-1110"><a href="#cb34-1110" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-1111"><a href="#cb34-1111" aria-hidden="true" tabindex="-1"></a>    button_classes <span class="op">=</span> [</span>
<span id="cb34-1112"><a href="#cb34-1112" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb34-1113"><a href="#cb34-1113" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[{<span class="st">"visible"</span>: get_visible_class(k)}],</span>
<span id="cb34-1114"><a href="#cb34-1114" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb34-1115"><a href="#cb34-1115" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb34-1116"><a href="#cb34-1116" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-1117"><a href="#cb34-1117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes)</span>
<span id="cb34-1118"><a href="#cb34-1118" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb34-1119"><a href="#cb34-1119" aria-hidden="true" tabindex="-1"></a>    buttons_method <span class="op">=</span> [</span>
<span id="cb34-1120"><a href="#cb34-1120" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb34-1121"><a href="#cb34-1121" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb34-1122"><a href="#cb34-1122" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">0</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">0</span>)}</span>
<span id="cb34-1123"><a href="#cb34-1123" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb34-1124"><a href="#cb34-1124" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"entropy"</span>,</span>
<span id="cb34-1125"><a href="#cb34-1125" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb34-1126"><a href="#cb34-1126" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb34-1127"><a href="#cb34-1127" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb34-1128"><a href="#cb34-1128" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb34-1129"><a href="#cb34-1129" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">1</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">1</span>)}</span>
<span id="cb34-1130"><a href="#cb34-1130" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb34-1131"><a href="#cb34-1131" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"glad"</span>,</span>
<span id="cb34-1132"><a href="#cb34-1132" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb34-1133"><a href="#cb34-1133" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb34-1134"><a href="#cb34-1134" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dict</span>(</span>
<span id="cb34-1135"><a href="#cb34-1135" aria-hidden="true" tabindex="-1"></a>            args<span class="op">=</span>[</span>
<span id="cb34-1136"><a href="#cb34-1136" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"visible"</span>: get_visible_strat(<span class="dv">2</span>), <span class="st">"layer"</span>: get_layer_strat(<span class="dv">1</span>)}</span>
<span id="cb34-1137"><a href="#cb34-1137" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb34-1138"><a href="#cb34-1138" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"waum"</span>,</span>
<span id="cb34-1139"><a href="#cb34-1139" aria-hidden="true" tabindex="-1"></a>            method<span class="op">=</span><span class="st">"update"</span>,</span>
<span id="cb34-1140"><a href="#cb34-1140" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb34-1141"><a href="#cb34-1141" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb34-1142"><a href="#cb34-1142" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> go.Layout(</span>
<span id="cb34-1143"><a href="#cb34-1143" aria-hidden="true" tabindex="-1"></a>        updatemenus<span class="op">=</span>[</span>
<span id="cb34-1144"><a href="#cb34-1144" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb34-1145"><a href="#cb34-1145" aria-hidden="true" tabindex="-1"></a>                <span class="st">"type"</span>: <span class="st">"buttons"</span>,</span>
<span id="cb34-1146"><a href="#cb34-1146" aria-hidden="true" tabindex="-1"></a>                <span class="st">"buttons"</span>: button_classes,</span>
<span id="cb34-1147"><a href="#cb34-1147" aria-hidden="true" tabindex="-1"></a>                <span class="st">"active"</span>: <span class="dv">3</span>,</span>
<span id="cb34-1148"><a href="#cb34-1148" aria-hidden="true" tabindex="-1"></a>                <span class="st">"showactive"</span>: <span class="va">True</span>,</span>
<span id="cb34-1149"><a href="#cb34-1149" aria-hidden="true" tabindex="-1"></a>                <span class="st">"direction"</span>: <span class="st">"down"</span>,  <span class="co"># Display buttons horizontally</span></span>
<span id="cb34-1150"><a href="#cb34-1150" aria-hidden="true" tabindex="-1"></a>                <span class="st">"x"</span>: <span class="fl">0.1</span>,  <span class="co"># X-position of the buttons (0.5 centers them)</span></span>
<span id="cb34-1151"><a href="#cb34-1151" aria-hidden="true" tabindex="-1"></a>                <span class="st">"y"</span>: <span class="fl">1.</span>,  <span class="co"># Y-position   of the buttons</span></span>
<span id="cb34-1152"><a href="#cb34-1152" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb34-1153"><a href="#cb34-1153" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb34-1154"><a href="#cb34-1154" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb34-1155"><a href="#cb34-1155" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> [</span>
<span id="cb34-1156"><a href="#cb34-1156" aria-hidden="true" tabindex="-1"></a>        go.Image(</span>
<span id="cb34-1157"><a href="#cb34-1157" aria-hidden="true" tabindex="-1"></a>            z<span class="op">=</span>all_images[method][k],</span>
<span id="cb34-1158"><a href="#cb34-1158" aria-hidden="true" tabindex="-1"></a>            visible<span class="op">=</span><span class="va">True</span> <span class="cf">if</span> k <span class="op">==</span> <span class="dv">3</span> <span class="cf">else</span> <span class="va">False</span>,</span>
<span id="cb34-1159"><a href="#cb34-1159" aria-hidden="true" tabindex="-1"></a>            name<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>classes[k]<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>method<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb34-1160"><a href="#cb34-1160" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-1161"><a href="#cb34-1161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> method <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(all_images))</span>
<span id="cb34-1162"><a href="#cb34-1162" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes)</span>
<span id="cb34-1163"><a href="#cb34-1163" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb34-1164"><a href="#cb34-1164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1165"><a href="#cb34-1165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n_classes <span class="op">*</span> <span class="bu">len</span>(all_images)):</span>
<span id="cb34-1166"><a href="#cb34-1166" aria-hidden="true" tabindex="-1"></a>        fig.add_trace(</span>
<span id="cb34-1167"><a href="#cb34-1167" aria-hidden="true" tabindex="-1"></a>            data[k],</span>
<span id="cb34-1168"><a href="#cb34-1168" aria-hidden="true" tabindex="-1"></a>            row<span class="op">=</span><span class="dv">1</span> <span class="op">+</span> k <span class="op">//</span> n_classes,</span>
<span id="cb34-1169"><a href="#cb34-1169" aria-hidden="true" tabindex="-1"></a>            col<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb34-1170"><a href="#cb34-1170" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb34-1171"><a href="#cb34-1171" aria-hidden="true" tabindex="-1"></a>    fig.update_layout(layout)</span>
<span id="cb34-1172"><a href="#cb34-1172" aria-hidden="true" tabindex="-1"></a>    fig.update_layout(width<span class="op">=</span><span class="dv">800</span>, height<span class="op">=</span><span class="dv">700</span>, margin<span class="op">=</span><span class="bu">dict</span>(l<span class="op">=</span><span class="dv">0</span>, r<span class="op">=</span><span class="dv">0</span>, t<span class="op">=</span><span class="dv">30</span>, b<span class="op">=</span><span class="dv">0</span>, autoexpand<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb34-1173"><a href="#cb34-1173" aria-hidden="true" tabindex="-1"></a>    fig.update_xaxes(showticklabels<span class="op">=</span><span class="va">False</span>).update_yaxes(showticklabels<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb34-1174"><a href="#cb34-1174" aria-hidden="true" tabindex="-1"></a>    fig.show()</span>
<span id="cb34-1175"><a href="#cb34-1175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1176"><a href="#cb34-1176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1177"><a href="#cb34-1177" aria-hidden="true" tabindex="-1"></a>n_classes <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb34-1178"><a href="#cb34-1178" aria-hidden="true" tabindex="-1"></a>all_images <span class="op">=</span> load_data(<span class="st">"cifar10H"</span>, n_classes, classes)</span>
<span id="cb34-1179"><a href="#cb34-1179" aria-hidden="true" tabindex="-1"></a>generate_plot(n_classes, all_images)</span>
<span id="cb34-1180"><a href="#cb34-1180" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1181"><a href="#cb34-1181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1182"><a href="#cb34-1182" aria-hidden="true" tabindex="-1"></a>The entropy, GLAD's difficulty, and WAUM's difficulty each show different images as exhebited above.. We highlight that for the <span class="in">`cat`</span> label, each strategy retrieves images that are mislabeled in the ground truth labeling. Indeed, the frog, dog and fox images are labeled as <span class="in">`cat`</span> in $\texttt{CIFAR-10}$. And while the entropy and GLAD output similar tasks, in this case the WAUM often differs. We can also observe an ambiguity induced by the labels in the <span class="in">`truck`</span> category, with the presence of a trailer that is technically a mixup between a <span class="in">`car`</span> and a <span class="in">`truck`</span>.</span>
<span id="cb34-1183"><a href="#cb34-1183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1184"><a href="#cb34-1184" aria-hidden="true" tabindex="-1"></a><span class="fu">### LabelMe dataset</span></span>
<span id="cb34-1185"><a href="#cb34-1185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1186"><a href="#cb34-1186" aria-hidden="true" tabindex="-1"></a>As for the $\texttt{LabelMe}$ dataset, one difficulty in evaluating tasks' intrinsic difficulty is that there are up to three votes given per task.</span>
<span id="cb34-1187"><a href="#cb34-1187" aria-hidden="true" tabindex="-1"></a>Hence, the entropy in the distribution of the votes is no longer a reliable metric, and we need to rely on other models.</span>
<span id="cb34-1188"><a href="#cb34-1188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1189"><a href="#cb34-1189" aria-hidden="true" tabindex="-1"></a>Now, let us compare the tasks' difficulty distribution depending on the strategy considered using <span class="in">`peerannot`</span>.</span>
<span id="cb34-1190"><a href="#cb34-1190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1193"><a href="#cb34-1193" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1194"><a href="#cb34-1194" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1195"><a href="#cb34-1195" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb34-1196"><a href="#cb34-1196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1197"><a href="#cb34-1197" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb34-1198"><a href="#cb34-1198" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb34-1199"><a href="#cb34-1199" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>K <span class="dv">8</span> <span class="op">--</span>method WAUM <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json <span class="op">--</span>model modellabelme <span class="op">--</span>lr<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>n<span class="op">-</span>epochs <span class="dv">100</span> <span class="op">--</span>maxiter<span class="op">-</span>DS<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>alpha<span class="op">=</span><span class="fl">0.01</span> <span class="op">--</span>pretrained <span class="op">--</span>optimizer<span class="op">=</span>sgd</span>
<span id="cb34-1200"><a href="#cb34-1200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1201"><a href="#cb34-1201" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1202"><a href="#cb34-1202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1205"><a href="#cb34-1205" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1206"><a href="#cb34-1206" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-1207"><a href="#cb34-1207" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1208"><a href="#cb34-1208" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-difficulty-labelme</span></span>
<span id="cb34-1209"><a href="#cb34-1209" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Most difficult tasks identified depending on the strategy used (entropy, GLAD or WAUM) using a VGG-16 with two dense layers.</span></span>
<span id="cb34-1210"><a href="#cb34-1210" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> {</span>
<span id="cb34-1211"><a href="#cb34-1211" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: <span class="st">"coast"</span>,</span>
<span id="cb34-1212"><a href="#cb34-1212" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"forest"</span>,</span>
<span id="cb34-1213"><a href="#cb34-1213" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"highway"</span>,</span>
<span id="cb34-1214"><a href="#cb34-1214" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"insidecity"</span>,</span>
<span id="cb34-1215"><a href="#cb34-1215" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"mountain"</span>,</span>
<span id="cb34-1216"><a href="#cb34-1216" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"opencountry"</span>,</span>
<span id="cb34-1217"><a href="#cb34-1217" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"street"</span>,</span>
<span id="cb34-1218"><a href="#cb34-1218" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: <span class="st">"tallbuilding"</span>,</span>
<span id="cb34-1219"><a href="#cb34-1219" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb34-1220"><a href="#cb34-1220" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> <span class="bu">list</span>(classes.values())</span>
<span id="cb34-1221"><a href="#cb34-1221" aria-hidden="true" tabindex="-1"></a>n_classes <span class="op">=</span> <span class="bu">len</span>(classes)</span>
<span id="cb34-1222"><a href="#cb34-1222" aria-hidden="true" tabindex="-1"></a>all_images <span class="op">=</span> load_data(<span class="st">"labelme"</span>, n_classes, classes)</span>
<span id="cb34-1223"><a href="#cb34-1223" aria-hidden="true" tabindex="-1"></a>generate_plot(n_classes, all_images) <span class="co"># create interactive plot</span></span>
<span id="cb34-1224"><a href="#cb34-1224" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1225"><a href="#cb34-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1226"><a href="#cb34-1226" aria-hidden="true" tabindex="-1"></a>Note that in @fig-difficulty-labelme, because the number of labels given per task is in $<span class="sc">\{</span>1,2,3<span class="sc">\}</span>$, the entropy only takes four values.</span>
<span id="cb34-1227"><a href="#cb34-1227" aria-hidden="true" tabindex="-1"></a>In particular, tasks with only one label all have a null entropy, so not just consensual tasks.</span>
<span id="cb34-1228"><a href="#cb34-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1229"><a href="#cb34-1229" aria-hidden="true" tabindex="-1"></a>The underlying difficulty of these tasks mainly comes from the overlap in possible labels. For example, <span class="in">`tallbuildings`</span> are most often found <span class="in">`insidecities`</span>, and so are <span class="in">`streets`</span>. In the <span class="in">`opencountry`</span> we find <span class="in">`forests`</span>, river-<span class="in">`coasts`</span> and <span class="in">`mountains`</span>.</span>
<span id="cb34-1230"><a href="#cb34-1230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1231"><a href="#cb34-1231" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring workers' reliability</span></span>
<span id="cb34-1232"><a href="#cb34-1232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1233"><a href="#cb34-1233" aria-hidden="true" tabindex="-1"></a>From the labels, we can explore different worker evaluation scores.</span>
<span id="cb34-1234"><a href="#cb34-1234" aria-hidden="true" tabindex="-1"></a>GLAD's strategy estimates a reliability scalar coefficient $\alpha_j$ per worker.</span>
<span id="cb34-1235"><a href="#cb34-1235" aria-hidden="true" tabindex="-1"></a>With strategies looking to estimate confusion matrices, we investigate two scoring rules for workers:</span>
<span id="cb34-1236"><a href="#cb34-1236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1237"><a href="#cb34-1237" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the trace of the confusion matrix: the closer to $K$ the better the worker,</span>
<span id="cb34-1238"><a href="#cb34-1238" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the closeness to spammer metric <span class="co">[</span><span class="ot">@raykar_ranking_2011</span><span class="co">]</span> (also called spammer score) that is the Frobenius norm between the estimated confusion matrix $\hat\pi^{(j)}$ and the closest rank-$1$ matrix. The further to zero the better the worker. On the contrary, the closer to zero, the more likely it is the worker to be a spammer.</span>
<span id="cb34-1239"><a href="#cb34-1239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1240"><a href="#cb34-1240" aria-hidden="true" tabindex="-1"></a>When the tasks are available, confusion-matrix-based deep learning models can also be used.</span>
<span id="cb34-1241"><a href="#cb34-1241" aria-hidden="true" tabindex="-1"></a>We thus add to the comparison the trace of the confusion matrices with CrowdLayer and CoNAL on the $\texttt{LabelMe}$ datasets.</span>
<span id="cb34-1242"><a href="#cb34-1242" aria-hidden="true" tabindex="-1"></a>For CoNAL, we only consider the trace of the confusion matrix $\pi^{(j)}$ in the pairwise comparison.</span>
<span id="cb34-1243"><a href="#cb34-1243" aria-hidden="true" tabindex="-1"></a>Moreover, for CrowdLayer and CoNAL we show the weights learned without the softmax operation by row to keep the comparison as simple as possible with the actual outputs of the model.</span>
<span id="cb34-1244"><a href="#cb34-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1245"><a href="#cb34-1245" aria-hidden="true" tabindex="-1"></a><span class="fu">### CIFAR-10H</span></span>
<span id="cb34-1246"><a href="#cb34-1246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1247"><a href="#cb34-1247" aria-hidden="true" tabindex="-1"></a>The $\texttt{CIFAR-10H}$ dataset has few disagreements among workers.</span>
<span id="cb34-1248"><a href="#cb34-1248" aria-hidden="true" tabindex="-1"></a>However, these strategies disagree on the ranking of good against best workers as they do not measure the same properties.</span>
<span id="cb34-1249"><a href="#cb34-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1252"><a href="#cb34-1252" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1253"><a href="#cb34-1253" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1254"><a href="#cb34-1254" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb34-1255"><a href="#cb34-1255" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb34-1256"><a href="#cb34-1256" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb34-1257"><a href="#cb34-1257" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb34-1258"><a href="#cb34-1258" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb34-1259"><a href="#cb34-1259" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1260"><a href="#cb34-1260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1263"><a href="#cb34-1263" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1264"><a href="#cb34-1264" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-1265"><a href="#cb34-1265" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-abilitiescifarh</span></span>
<span id="cb34-1266"><a href="#cb34-1266" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of ability scores by workers for the CIFAR-10H dataset. All metrics  computed identify the same poorly performing workers. A mass of good and expert workers can be seen as the dataset presents few disagreements, thus few data to seperate good from best workers.</span></span>
<span id="cb34-1267"><a href="#cb34-1267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1268"><a href="#cb34-1268" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span></span>
<span id="cb34-1269"><a href="#cb34-1269" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"Trace DS"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb34-1270"><a href="#cb34-1270" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace DS"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb34-1271"><a href="#cb34-1271" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb34-1272"><a href="#cb34-1272" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb34-1273"><a href="#cb34-1273" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb34-1274"><a href="#cb34-1274" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>, plot_kws<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.2</span>})</span>
<span id="cb34-1275"><a href="#cb34-1275" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-1276"><a href="#cb34-1276" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1277"><a href="#cb34-1277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1278"><a href="#cb34-1278" aria-hidden="true" tabindex="-1"></a>From @fig-abilitiescifarh, we can see that in this dataset, different methods easily separate the worse workers from the rest of the crowd (workers in the tail of the distribution).</span>
<span id="cb34-1279"><a href="#cb34-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1280"><a href="#cb34-1280" aria-hidden="true" tabindex="-1"></a><span class="fu">### LabelMe</span></span>
<span id="cb34-1281"><a href="#cb34-1281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1282"><a href="#cb34-1282" aria-hidden="true" tabindex="-1"></a>Finally, let us evaluate workers for the $\texttt{LabelMe}$ dataset.</span>
<span id="cb34-1283"><a href="#cb34-1283" aria-hidden="true" tabindex="-1"></a>Because of the lack of data (up to 3 labels per task), ranking workers is more difficult than in the $\texttt{CIFAR-10H}$ dataset.</span>
<span id="cb34-1284"><a href="#cb34-1284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1287"><a href="#cb34-1287" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1288"><a href="#cb34-1288" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb34-1289"><a href="#cb34-1289" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb34-1290"><a href="#cb34-1290" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb34-1291"><a href="#cb34-1291" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb34-1292"><a href="#cb34-1292" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">8</span> <span class="op">\</span></span>
<span id="cb34-1293"><a href="#cb34-1293" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb34-1294"><a href="#cb34-1294" aria-hidden="true" tabindex="-1"></a><span class="co"># CoNAL and CrowdLayer were run in section 4</span></span>
<span id="cb34-1295"><a href="#cb34-1295" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1296"><a href="#cb34-1296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1299"><a href="#cb34-1299" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb34-1300"><a href="#cb34-1300" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb34-1301"><a href="#cb34-1301" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-abilities-labelme</span></span>
<span id="cb34-1302"><a href="#cb34-1302" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of ability scores by workers for the labelme dataset. With few labels per task, workers are more difficult to rank. It is more difficult to separate workers with their abilities in this crowd. Hence the importance of investigating the generalization performance of the methods presented in the previous section.</span></span>
<span id="cb34-1303"><a href="#cb34-1303" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb34-1304"><a href="#cb34-1304" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"Trace DS"</span>: [], <span class="st">"Spam score"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"Trace CrowdLayer"</span>: [], <span class="st">"Trace CoNAL[scale=1e-4]"</span>: []}</span>
<span id="cb34-1305"><a href="#cb34-1305" aria-hidden="true" tabindex="-1"></a>best_cl <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_crowdlayer.pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb34-1306"><a href="#cb34-1306" aria-hidden="true" tabindex="-1"></a>best_conal <span class="op">=</span> torch.load(path_ <span class="op">/</span> <span class="st">"best_models"</span> <span class="op">/</span> <span class="st">"labelme_conal[scale=1e-4]_local_confusion.pth"</span>, map_location<span class="op">=</span><span class="st">"cpu"</span>)</span>
<span id="cb34-1307"><a href="#cb34-1307" aria-hidden="true" tabindex="-1"></a>pi_conal <span class="op">=</span> best_conal</span>
<span id="cb34-1308"><a href="#cb34-1308" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace CoNAL[scale=1e-4]"</span>].extend([torch.trace(pi_conal[i]).item() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pi_conal.shape[<span class="dv">0</span>])])</span>
<span id="cb34-1309"><a href="#cb34-1309" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace CrowdLayer"</span>].extend([torch.trace(best_cl[<span class="st">"confusion"</span>][i]).item() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(best_cl[<span class="st">"confusion"</span>].shape[<span class="dv">0</span>])])</span>
<span id="cb34-1310"><a href="#cb34-1310" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Trace DS"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb34-1311"><a href="#cb34-1311" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"Spam score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb34-1312"><a href="#cb34-1312" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb34-1313"><a href="#cb34-1313" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb34-1314"><a href="#cb34-1314" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>, plot_kws<span class="op">=</span>{<span class="st">'alpha'</span>:<span class="fl">0.2</span>})</span>
<span id="cb34-1315"><a href="#cb34-1315" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb34-1316"><a href="#cb34-1316" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb34-1317"><a href="#cb34-1317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1318"><a href="#cb34-1318" aria-hidden="true" tabindex="-1"></a>We can see in Figure @fig-abilities-labelme that the number of labels available by task highly impacts the worker evaluation scores.</span>
<span id="cb34-1319"><a href="#cb34-1319" aria-hidden="true" tabindex="-1"></a>The spam score, DS model and CoNAL all show similar results in the distribution shape (bimodal distribution) whereas GLAD and CrowdLayer are more concentrated.</span>
<span id="cb34-1320"><a href="#cb34-1320" aria-hidden="true" tabindex="-1"></a>However, this does not account for the ranking of a given worker by the methods considered.</span>
<span id="cb34-1321"><a href="#cb34-1321" aria-hidden="true" tabindex="-1"></a>The exploration of the dataset let us look at different scores, but generalization performance presented in @sec-real-datasets should also be considered in crowdsourcing.</span>
<span id="cb34-1322"><a href="#cb34-1322" aria-hidden="true" tabindex="-1"></a>This difference in worker evaluation scores indeed further highlights the importance of using multiple test metrics to compare model's prediction performance in crowdsourcing.</span>
<span id="cb34-1323"><a href="#cb34-1323" aria-hidden="true" tabindex="-1"></a>We have seen that the library <span class="in">`peerannot`</span> allows users to explore the datasets, both in terms of tasks and workers, and easily compare predictive performance in this setting.</span>
<span id="cb34-1324"><a href="#cb34-1324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1325"><a href="#cb34-1325" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion</span></span>
<span id="cb34-1326"><a href="#cb34-1326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1327"><a href="#cb34-1327" aria-hidden="true" tabindex="-1"></a>We introduced <span class="in">`peerannot`</span>, a library to handle crowdsourced datasets. This library enables both easy label aggregation and direct training strategies with classical state-of-the-art classifiers. The identification module of the library allows exploring the collected data from both the tasks and the workers' point of view for better scorings and data cleaning procedures.</span>
<span id="cb34-1328"><a href="#cb34-1328" aria-hidden="true" tabindex="-1"></a>Our library also comes with templated datasets to better share crowdsourced datasets.</span>
<span id="cb34-1329"><a href="#cb34-1329" aria-hidden="true" tabindex="-1"></a>Going beyond templating, it helps the crowdsourcing community to have openly accessible strategies to test, compare and improve in order to develop common strategies to analyse more and more common crowdsourced datasets.</span>
<span id="cb34-1330"><a href="#cb34-1330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-1331"><a href="#cb34-1331" aria-hidden="true" tabindex="-1"></a>We hope that this library helps reproducibility in the crowdsourcing community and also standardizes training from crowdsourced datasets. New strategies can easily be incorporated into the open-source code <span class="co">[</span><span class="ot">available on github</span><span class="co">](https://github.com/peerannot/peerannot)</span>. Finally, as <span class="in">`peerannot`</span> is mostly directed to handle classification datasets, one of our future works would be to consider other <span class="in">`peerannot`</span> modules to handle crowdsourcing for object detection, segmentation and even worker evaluation in other contexts like peer-grading.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>