<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.330">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tanguy Lefort">
<meta name="author" content="Benjamin Charlier">
<meta name="author" content="Alexis Joly">
<meta name="author" content="Joseph Salmon">
<meta name="dcterms.date" content="2023-04-19">
<meta name="keywords" content="crowdsourcing, label noise, task difficulty, worker ability">
<meta name="description" content="Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, it is common for workers to disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We introduce peerannot, a Python library for managing and learning from crowdsourced labels.">

<title>Peerannot: learning from crowdsourced image datasets with Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="content_files/libs/clipboard/clipboard.min.js"></script>
<script src="content_files/libs/quarto-html/quarto.js"></script>
<script src="content_files/libs/quarto-html/popper.min.js"></script>
<script src="content_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="content_files/libs/quarto-html/anchor.min.js"></script>
<link href="content_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="content_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="content_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="content_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="content_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>
    .quarto-title-block .quarto-title-banner,
    .quarto-title-block .quarto-title-banner h1,
    .quarto-title-block .quarto-title-banner h2,
    .quarto-title-block .quarto-title-banner h3,
    .quarto-title-block .quarto-title-banner h4,
    .quarto-title-block .quarto-title-banner h5,
    .quarto-title-block .quarto-title-banner h6
    {
      color: #FFFFFF;
background: #034E79;
    }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Peerannot: learning from crowdsourced image datasets with Python</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, it is common for workers to disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We introduce peerannot, a Python library for managing and learning from crowdsourced labels.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://tanglef.github.io">Tanguy Lefort</a> <a href="https://orcid.org/0009-0000-6710-3221" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://someplace.themoon.org">
                  Name of Affiliation one
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://imag.umontpellier.fr/~charlier/index.php?page=index&amp;lang=en">Benjamin Charlier</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://someplace.themoon.org">
                  Name of Afficiliation two
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://www-sop.inria.fr/members/Alexis.Joly/wiki/pmwiki.php">Alexis Joly</a> <a href="https://orcid.org/0000-0002-2161-9940" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://someplace.themoon.org">
                  Name of Afficiliation two
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://josephsalmon.eu/">Joseph Salmon</a> <a href="https://orcid.org/0000-0002-3181-0634" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://someplace.themoon.org">
                  Name of Afficiliation two
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 19, 2023</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">April 19, 2023</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">crowdsourcing, label noise, task difficulty, worker ability</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, workers often disagree with each other. Sources of error can arise from the workers’ skills, but also from the intrinsic difficulty of the task. We present <code>peerannot</code>: a <code>Python</code> library for managing and learning from crowdsourced labels. Our library allows users to aggregate labels from common noise models or train a deep learning-based classifier directly from crowdsourced labels. In addition, we provide an identification module to easily explore the task difficulty of datasets and worker capabilities.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction-crowdsourcing-in-image-classification" id="toc-introduction-crowdsourcing-in-image-classification" class="nav-link active" data-scroll-target="#introduction-crowdsourcing-in-image-classification"><span class="header-section-number">1</span> Introduction: crowdsourcing in image classification</a></li>
  <li><a href="#notation-and-package-structure" id="toc-notation-and-package-structure" class="nav-link" data-scroll-target="#notation-and-package-structure"><span class="header-section-number">2</span> Notation and package structure</a>
  <ul class="collapse">
  <li><a href="#crowdsourcing-notation" id="toc-crowdsourcing-notation" class="nav-link" data-scroll-target="#crowdsourcing-notation"><span class="header-section-number">2.1</span> Crowdsourcing notation</a></li>
  <li><a href="#storing-crowdsourced-datasets-in-peerannot" id="toc-storing-crowdsourced-datasets-in-peerannot" class="nav-link" data-scroll-target="#storing-crowdsourced-datasets-in-peerannot"><span class="header-section-number">2.2</span> Storing crowdsourced datasets in <code>peerannot</code></a></li>
  </ul></li>
  <li><a href="#aggregation-strategies-in-crowdsourcing" id="toc-aggregation-strategies-in-crowdsourcing" class="nav-link" data-scroll-target="#aggregation-strategies-in-crowdsourcing"><span class="header-section-number">3</span> Aggregation strategies in crowdsourcing</a>
  <ul class="collapse">
  <li><a href="#classical-models" id="toc-classical-models" class="nav-link" data-scroll-target="#classical-models"><span class="header-section-number">3.1</span> Classical models</a></li>
  <li><a href="#sec-evaluation-aggregation" id="toc-sec-evaluation-aggregation" class="nav-link" data-scroll-target="#sec-evaluation-aggregation"><span class="header-section-number">3.2</span> Experiments and evaluation of label aggregation strategies</a>
  <ul class="collapse">
  <li><a href="#simulated-independent-mistakes" id="toc-simulated-independent-mistakes" class="nav-link" data-scroll-target="#simulated-independent-mistakes"><span class="header-section-number">3.2.1</span> Simulated independent mistakes</a></li>
  <li><a href="#simulated-correlated-mistakes" id="toc-simulated-correlated-mistakes" class="nav-link" data-scroll-target="#simulated-correlated-mistakes"><span class="header-section-number">3.2.2</span> Simulated correlated mistakes</a></li>
  <li><a href="#simulated-mistakes-with-discrete-difficulty-levels-on-tasks" id="toc-simulated-mistakes-with-discrete-difficulty-levels-on-tasks" class="nav-link" data-scroll-target="#simulated-mistakes-with-discrete-difficulty-levels-on-tasks"><span class="header-section-number">3.2.3</span> Simulated mistakes with discrete difficulty levels on tasks</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#learning-from-crowdsourced-tasks" id="toc-learning-from-crowdsourced-tasks" class="nav-link" data-scroll-target="#learning-from-crowdsourced-tasks"><span class="header-section-number">4</span> Learning from crowdsourced tasks</a>
  <ul class="collapse">
  <li><a href="#classical-models-1" id="toc-classical-models-1" class="nav-link" data-scroll-target="#classical-models-1"><span class="header-section-number">4.1</span> Classical models</a></li>
  <li><a href="#prediction-error-when-learning-from-crowdsourced-tasks" id="toc-prediction-error-when-learning-from-crowdsourced-tasks" class="nav-link" data-scroll-target="#prediction-error-when-learning-from-crowdsourced-tasks"><span class="header-section-number">4.2</span> Prediction error when learning from crowdsourced tasks</a></li>
  <li><a href="#use-case-with-peerannot-on-real-datasets" id="toc-use-case-with-peerannot-on-real-datasets" class="nav-link" data-scroll-target="#use-case-with-peerannot-on-real-datasets"><span class="header-section-number">4.3</span> Use case with <code>peerannot</code> on real datasets</a></li>
  </ul></li>
  <li><a href="#exploring-crowdsourced-datasets" id="toc-exploring-crowdsourced-datasets" class="nav-link" data-scroll-target="#exploring-crowdsourced-datasets"><span class="header-section-number">5</span> Exploring crowdsourced datasets</a>
  <ul class="collapse">
  <li><a href="#exploring-tasks-difficulty" id="toc-exploring-tasks-difficulty" class="nav-link" data-scroll-target="#exploring-tasks-difficulty"><span class="header-section-number">5.1</span> Exploring tasks’ difficulty</a>
  <ul class="collapse">
  <li><a href="#cifar-1oh-dataset" id="toc-cifar-1oh-dataset" class="nav-link" data-scroll-target="#cifar-1oh-dataset"><span class="header-section-number">5.1.1</span> CIFAR-1OH dataset</a></li>
  <li><a href="#labelme-dataset" id="toc-labelme-dataset" class="nav-link" data-scroll-target="#labelme-dataset"><span class="header-section-number">5.1.2</span> LabelMe dataset</a></li>
  </ul></li>
  <li><a href="#exploring-workers-reliability" id="toc-exploring-workers-reliability" class="nav-link" data-scroll-target="#exploring-workers-reliability"><span class="header-section-number">5.2</span> Exploring workers’ reliability</a>
  <ul class="collapse">
  <li><a href="#cifar-10h" id="toc-cifar-10h" class="nav-link" data-scroll-target="#cifar-10h"><span class="header-section-number">5.2.1</span> CIFAR-10H</a></li>
  <li><a href="#labelme" id="toc-labelme" class="nav-link" data-scroll-target="#labelme"><span class="header-section-number">5.2.2</span> LabelMe</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">6</span> Conclusion</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliography</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="content.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<section id="introduction-crowdsourcing-in-image-classification" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction: crowdsourcing in image classification</h1>
<p>Image datasets widely use crowdsourcing to collect labels, involving many workers that can annotate images for a small cost (or even free for instance in citizen science) and faster than using expert labeling. Many classical datasets considered in machine learning have been created with human intervention to create labels, such as CIFAR-<span class="math inline">10</span>, <span class="citation" data-cites="krizhevsky2009learning">(<a href="#ref-krizhevsky2009learning" role="doc-biblioref">Krizhevsky and Hinton 2009</a>)</span>, ImageNet <span class="citation" data-cites="imagenet_cvpr09">(<a href="#ref-imagenet_cvpr09" role="doc-biblioref">Deng et al. 2009</a>)</span> or <span class="citation" data-cites="Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021">(<a href="#ref-Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021" role="doc-biblioref">Garcin et al. 2021</a>)</span> in image classification, but also COCO <span class="citation" data-cites="cocodataset">(<a href="#ref-cocodataset" role="doc-biblioref">Lin et al. 2014</a>)</span>, solar photovoltaic arrays <span class="citation" data-cites="kasmi2023crowdsourced">(<a href="#ref-kasmi2023crowdsourced" role="doc-biblioref">Kasmi et al. 2023</a>)</span> or even macro litter <span class="citation" data-cites="chagneux2023">(<a href="#ref-chagneux2023" role="doc-biblioref">Chagneux et al. 2023</a>)</span> in image segmentation and object counting.</p>
<p>Crowdsourced datasets induce at least three major challenges to which we contribute with <code>peerannot</code>:</p>
<ul>
<li><p><em>How to identify good workers in the crowd?</em> When multiple answers are given to a single task, looking for who to trust for which type of task becomes necessary to estimate the ground truth or later train a model with as few noise sources as possible. The module <code>identify</code> uses different scoring metrics to create a worker and/or task evaluation. This is particularly relevant considering the gamification of crowdsourcing experiments <span class="citation" data-cites="plantgame2016">(<a href="#ref-plantgame2016" role="doc-biblioref">Servajean et al. 2016</a>)</span></p></li>
<li><p><em>How to aggregate multiple labels into a single label from crowdsourced tasks?</em> This occurs for example when dealing with a single dataset that has been labeled by multiple workers with disagreements. This is also encountered with other scoring issues such as polls, reviews, peer-grading, <em>etc.</em> In our framework this is treated with the <code>aggregate</code> command, that given multiple labels, infers a ground truth label.</p></li>
<li><p><em>How to learn a classifier from crowdsourced datasets?</em> Where the first question is bound by aggregating multiple labels into a single one, this considers the case where we do not need a single label to train on, but instead train a classifier on the crowdsourced data, with the motivation to perform well on a testing set. This end-to-end vision, is common in machine learning, however, it requires the actual tasks (the images, texts, videos, <em>etc.</em>) to train on – and in crowdsourced datasets publicly available, they are not always available. This is treated with the <code>aggregate-deep</code> command.</p></li>
</ul>
<p>The library <code>peerannot</code> addresses these practical questions within a reproducible setting. Indeed, the complexity of experiments often leads to a lack of transparency and reproducible results for simulations and real datasets. We propose standard simulation settings with explicit implementation parameters that can be shared. For real datasets, <code>peerannot</code> is compatible with standard neural networks architectures from the <code>Torchvision</code> <span class="citation" data-cites="torchvision">(<a href="#ref-torchvision" role="doc-biblioref">Marcel and Rodriguez 2010</a>)</span> library and <code>Pytorch</code> <span class="citation" data-cites="pytorch">(<a href="#ref-pytorch" role="doc-biblioref">Paszke et al. 2019</a>)</span>, allowing a flexible framework with easy-to-share scripts to reproduce experiments.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figures/strategiesbis.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">From crowdsourced labels to training a classifier neural network, the learning pipeline using the <code>peerannot</code> library.</figcaption><p></p>
</figure>
</div>
</section>
<section id="notation-and-package-structure" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Notation and package structure</h1>
<section id="crowdsourcing-notation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="crowdsourcing-notation"><span class="header-section-number">2.1</span> Crowdsourcing notation</h2>
<p>Let us consider the classical supervised learning classification framework. A training set <span class="math inline">\mathcal{D}=\{(x_i, y_i^\star)\}_{i=1}^{n_{\text{task}}}</span> is composed of <span class="math inline">n_{\text{task}}</span> tasks <span class="math inline">x_i\in\mathcal{X}</span> (the feature space) with ground truth label <span class="math inline">y_i^\star \in\mathcal [K]={1,\dots,K}</span> one of the <span class="math inline">K</span> possible classes. In the following, the tasks considered are generally RGB images. We use the notation <span class="math inline">\sigma</span> for the softmax function.</p>
<p>With crowdsourced data the ground truth <span class="math inline">y_i^\star</span> is unknown, and there is no single label that can be trusted as in standard supervised learning (even on the train set!). Instead, for a given task <span class="math inline">x_i</span>, a worker <span class="math inline">w_j</span> proposes a label <span class="math inline">y_i^{(j)}</span>. The set of workers answering the task <span class="math inline">x_i</span> is denoted by <span class="math inline">\mathcal{A}(x_i)=\{j\in[n_\text{worker}]: w_j \text{ answered }x_i\}</span>. The cardinal <span class="math inline">\vert \mathcal{A}(x_i)\vert</span> is called the feedback effort on the task <span class="math inline">x_i</span>. Note that the feedback effort can not exceed the total number of workers <span class="math inline">n_{\text{worker}}</span>. Similarly, one can adopt a worker point of view: the set of tasks answered by a worker <span class="math inline">w_j</span> is denoted <span class="math inline">\mathcal{T}(w_j)=\{i\in[n_\text{task}]: w_j \text{ answered } x_i\}</span>. The cardinal <span class="math inline">\vert \mathcal{T}(w_j)\vert</span> is called the workerload of <span class="math inline">w_j</span>. The final dataset can then be decomposed as: <span class="math display">
\mathcal{D}_{\text{train}} := \bigcup_{i\in[n_\text{task}]} \{(x_i, (y_i^{(j)}) \text{ for }j\in\mathcal{A}(x_i))\} = \bigcup_{j\in[n_\text{worker}]} \{(x_i, (y_i^{(j)})) \text{ for }i \in\mathcal{T}(w_j)\} \enspace.
</span></p>
<p>In this article, we do not address the setting where workers report their self-confidence <span class="citation" data-cites="YasminRomena2022ICIC">(<a href="#ref-YasminRomena2022ICIC" role="doc-biblioref">Yasmin et al. 2022</a>)</span>, nor settings where workers are presented a trapping set – <em>i.e</em> a subset of tasks where the ground truth is known to evaluate them with known labels <span class="citation" data-cites="khattak_toward_2017">(<a href="#ref-khattak_toward_2017" role="doc-biblioref">Khattak 2017</a>)</span>.</p>
</section>
<section id="storing-crowdsourced-datasets-in-peerannot" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="storing-crowdsourced-datasets-in-peerannot"><span class="header-section-number">2.2</span> Storing crowdsourced datasets in <code>peerannot</code></h2>
<p>To store crowdsourcing datasets efficiently and in a standardized way, <code>peerannot</code> proposes the following structure, where each dataset equals a folder:</p>
<pre class="{bash}"><code>datasetname
      ├── train
      │     ├── class0
      │     │     ├─ task0-&lt;vote_index_0&gt;.png
      │     │     ├─ task1-&lt;vote_index_1&gt;.png
      │     │     ├─ ...
      │     │     └─ taskn0-&lt;vote_index_n0&gt;.png
      │     ├── class1
      │     ├── ...
      │     └── classK
      ├── val
      ├── test
      ├── metadata.json
      └── answers.json</code></pre>
<p>If the tasks (images) are available, they must be stored as it is usual to store <code>ImageFolder</code> datasets with <code>pytorch</code> into a <code>train</code>, <code>val</code> and <code>test</code> folder. Each image can have its name followed by its index in the <code>answers.json</code> file.</p>
<p>The <code>answers.json</code> file stores the different votes for each task as described in <a href="#fig-answers">Figure&nbsp;1</a>.</p>
<div id="fig-answers" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./figures/json_answers.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: From collected labels to data storage in the <code>answers.json</code> file for a binary classification task on recognizing smiling faces. (left: data stored in <code>peerannot</code>, right: table of data collected)</figcaption><p></p>
</figure>
</div>
<p>In this example, there are three tasks, <span class="math inline">n_{worker}=4</span> workers and <span class="math inline">K=2</span> classes. For the first task, the feedback effort is <span class="math inline">\vert\mathcal{A}(x_1)\vert=4</span>. The workerload of <span class="math inline">w_2</span> is <span class="math inline">\vert\mathcal{T}(w_2)\vert=2</span>.</p>
<p>Finally, a <code>metadata.json</code> file includes relevant information related to the crowdsourcing experiment such as the number of workers, the number of tasks, <em>etc.</em> For example, a minimal <code>metadata.json</code> file for the toy dataset presented in <a href="#fig-answers">Figure&nbsp;1</a> is:</p>
<pre class="{json}"><code>{
    "name": "toy-data",
    "n_classes": 2,
    "n_workers": 4,
    "n_tasks": 3,
}</code></pre>
</section>
</section>
<section id="aggregation-strategies-in-crowdsourcing" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Aggregation strategies in crowdsourcing</h1>
<p>The first question we address with <code>peerannot</code> is: <em>How to aggregate multiple labels into a single label from crowdsourced tasks?</em> The aggregation step can lead to two types of learnable labels <span class="math inline">\hat y_i\in\Delta_{K}</span> defined on the simplex of dimension <span class="math inline">K-1</span> depending on the use case:</p>
<ul>
<li>a <strong>hard</strong> label: <span class="math inline">\hat y_i</span> is a Dirac distribution, this can be encoded as a classical label in <span class="math inline">[K]</span>,</li>
<li>a <strong>soft</strong> label: <span class="math inline">\hat y_i\in\Delta_{K}</span> can be a probability distribution other than Dirac distribution, in that case, each coefficient in <span class="math inline">\hat y_i</span> represents the probability to belong to the given class.</li>
</ul>
<p>Learning from soft labels has been shown to improve learning performance and make the classifier learn the task ambiguity <span class="citation" data-cites="zhang2017mixup peterson_human_2019 park2022calibration">(<a href="#ref-zhang2017mixup" role="doc-biblioref">Zhang et al. 2018</a>; <a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>; <a href="#ref-park2022calibration" role="doc-biblioref">Park and Caragea 2022</a>)</span>. However, crowdsourcing is often used as a stepping stone to creating a new dataset and we usually expect a classification dataset to associate a task <span class="math inline">x_i</span> to a single label and not a full probability distribution. In this case, we recommend in practice releasing the anonymous answered labels and the aggregation strategy used to reach a consensus on a single label. With <code>peerannot</code>, both soft and hard labels can be produced. Note that when a strategy produces a soft label, a hard label can be induced by taking the class with the maximum probability.</p>
<section id="classical-models" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="classical-models"><span class="header-section-number">3.1</span> Classical models</h2>
<p>While the most intuitive way to create a label from multiple answers for any type of crowdsourced task would be to take the majority vote (MV), this strategy has many shortcomings <span class="citation" data-cites="james1998majority">(<a href="#ref-james1998majority" role="doc-biblioref">James 1998</a>)</span> – there is no noise model, no worker reliability estimated, no task difficulty involved and especially no way to remove poorly performing workers. This baseline aggregation can be expressed as:</p>
<p><span class="math display">
\hat y_i^{\text{MV}} = \operatornamewithlimits{argmax}_{k\in[K]} \sum_{j\in\mathcal{A}(x_i)} 1_{\{y_i^{(j)}=k\}} \enspace.
</span></p>
<p>One pitfall with the MV is that the label produced is hard, hence the ambiguity is discarded by construction. To remedy this, the Naive Soft (NS) labeling consists in using the empirical frequency distribution as the task label:</p>
<p><span class="math display">
\hat y_i^{\text{NS}} = \bigg(\frac{1}{\vert\mathcal{A}(x_i)\vert}\sum_{j\in\mathcal{A}(x_i)} 1_{\{y_i^{(j)}=k\}} \bigg)_{j\in[K]} \enspace.
</span> With the NS label, we keep the ambiguity, but all workers and all tasks are put on the same level. In practice, it is known that each worker comes with their abilities, thus modeling this knowledge can produce better results.</p>
<p>Going further into the aggregation, researchers began creating a noise model to take into account the workers’ abilities in the aggregation. These types of models are most often EM-based and one of the most studied <span class="citation" data-cites="gao2013minimax">(<a href="#ref-gao2013minimax" role="doc-biblioref">Gao and Zhou 2013</a>)</span> and applied <span class="citation" data-cites="servajean2017crowdsourcing rodrigues2018deep">(<a href="#ref-servajean2017crowdsourcing" role="doc-biblioref">Servajean et al. 2017</a>; <a href="#ref-rodrigues2018deep" role="doc-biblioref">Rodrigues and Pereira 2018</a>)</span> is the Dawid and Skene’s (DS) model <span class="citation" data-cites="dawid_maximum_1979">(<a href="#ref-dawid_maximum_1979" role="doc-biblioref">Dawid and Skene 1979</a>)</span>. Assuming the workers are answering tasks independently, this model boils down to model pairwise confusions between each possible class. Each worker <span class="math inline">w_j</span> is assigned a confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span> such that <span class="math inline">\pi^{(j)}_{k\ell} = \mathbb{P}(y_i^{(j)}=\ell\vert y_i^\star=k)</span>. The model assumes that the probability for a task <span class="math inline">x_i</span> to have true label <span class="math inline">y_i^\star=k</span> follows a multinomial distribution with probabilities <span class="math inline">\pi^{(j)}_{k,\bullet}</span> for each worker. Each class has a prevalence <span class="math inline">\rho_k=\mathbb{P}(y_i^\star=k)</span> to appear in the dataset. Using the independence between workers, we obtain the following likelihood to maximize (using the EM algorithm):</p>
<p><span class="math display">
\displaystyle\prod_{i\in [n_{\texttt{task}}]}\prod_{k \in [K]}\bigg[\rho_k\prod_{j\in [n_{\texttt{worker}}]}
    \prod_{k\in [K]}\big(\pi^{(j)}_{k, k}\big)^{1_{\{y_i^{(j)}=k\}}}
    \bigg]^{T_{ik}},
</span></p>
<p>with <span class="math inline">T_{i,k}=1_{\{y_i^{\star}=k \}}</span>. The final aggregated soft label is <span class="math inline">\hat y_i^{\text{DS}} = T_{i,\cdot}</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figures/bayesien_plaque_ds.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Bayesian <a href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a> for the DS model</figcaption><p></p>
</figure>
</div>
<p>Many variants of the DS model have been proposed in the literature, using Dirichlet priors on the confusion matrices <span class="citation" data-cites="passonneau-carpenter-2014-benefits">(<a href="#ref-passonneau-carpenter-2014-benefits" role="doc-biblioref">Passonneau and Carpenter 2014</a>)</span>, using <span class="math inline">L</span> clusters of workers <span class="citation" data-cites="imamura2018analysis">(<a href="#ref-imamura2018analysis" role="doc-biblioref">Imamura, Sato, and Sugiyama 2018</a>)</span> with <span class="math inline">1\leq L\leq n_{\text{worker}}</span> (DSWC) or even faster implementation that produces only hard labels <span class="citation" data-cites="sinha2018fast">(<a href="#ref-sinha2018fast" role="doc-biblioref">Sinha, Rao, and Balasubramanian 2018</a>)</span>.</p>
<p>Finally, we present the GLAD model <span class="citation" data-cites="whitehill_whose_2009">(<a href="#ref-whitehill_whose_2009" role="doc-biblioref">Whitehill et al. 2009</a>)</span> that not only takes into account the worker’s ability, but also the task difficulty in the noise model. Denoting <span class="math inline">\alpha_j\in\mathbb{R}</span> the worker ability (the higher the better) and <span class="math inline">\beta_i\in\mathbb{R}^+_\star</span> the task’s difficulty (the higher the easier), the model noise is:</p>
<p><span class="math display">
\mathbb{P}(y_i^{(j)}=y_i^\star\vert \alpha_j,\beta_i) = \frac{1}{1+\exp(-\alpha_j\beta_i)} \enspace.
</span> GLAD’s model also assumes that the errors are uniform across wrong labels, thus: <span class="math display">
\forall k \in [K],\ \mathbb{P}(y_i^{(j)}=k\vert y_i^\star\neq k,\alpha_j,\beta_i) = \frac{1}{K-1}\left(1-\frac{1}{1+\exp(-\alpha_j\beta_i)}\right)\enspace.
</span> The likelihood can then be optimized using an EM algorithm to recover the soft label <span class="math inline">\hat y_i^{\text{GLAD}}</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./figures/schema_bayesien_glad.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Bayesian <a href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a> for the GLAD model</figcaption><p></p>
</figure>
</div>
<p>All of these aggregation strategies – and more – are available in the <code>peerannot</code> library from the <code>peerannot.models</code> module. Each model is a class object in its own <code>Python</code> file. It inherits from the <code>CrowdModel</code> template class and is defined with at least two methods:</p>
<ul>
<li><code>run</code>: includes the optimization procedure to obtain needed weights (<em>e.g.</em> the EM algorithm for the DS model),</li>
<li><code>get_probas</code>: returns the soft labels output for each task.</li>
</ul>
</section>
<section id="sec-evaluation-aggregation" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-evaluation-aggregation"><span class="header-section-number">3.2</span> Experiments and evaluation of label aggregation strategies</h2>
<p>One way to evaluate the label aggregation strategies is to measure their accuracy. This means that the underlying ground truth must be known – or at least for a representative subset. As the set of <span class="math inline">n_{\text{task}}</span> can be seen as a training set for a future classifier, we denote this metric <span class="math inline">\operatornamewithlimits{AccTrain}</span> on a dataset <span class="math inline">\mathcal{D}</span> for a given aggregated label <span class="math inline">(\hat y_i)_i</span> as:</p>
<p><span class="math display">
\operatornamewithlimits{AccTrain}(\mathcal{D}) = \frac{1}{\vert \mathcal{D}\vert}\sum_{i=1}^{\vert\mathcal{D}\vert} 1_{\{y_i^\star=\operatornamewithlimits{argmax}_{k\in[K]}\hat y_i\}} \enspace.
</span></p>
<p>In the following, we write <span class="math inline">\operatornamewithlimits{AccTrain}</span> for <span class="math inline">\operatornamewithlimits{AccTrain}(\mathcal{D}_{\text{train}})</span> as we only consider the full training set so there is no ambiguity. While this metric is useful, in practice there are a few arguable issues:</p>
<ul>
<li>the <span class="math inline">\operatornamewithlimits{AccTrain}</span> does not consider the ambiguity of the soft label, only the most probable class, whereas in some contexts ambiguity can be informative,</li>
<li>in supervised learning one objective is to identify difficult or mislabeled tasks <span class="citation" data-cites="pleiss_identifying_2020 lefort2022improve">(<a href="#ref-pleiss_identifying_2020" role="doc-biblioref">Pleiss et al. 2020</a>; <a href="#ref-lefort2022improve" role="doc-biblioref">Lefort et al. 2022</a>)</span>, pruning those tasks can easily artificially improve the <span class="math inline">\operatornamewithlimits{AccTrain}</span>, but there is no guarantee over the predictive performance of a model based on the newly pruned dataset.</li>
</ul>
<p>We first consider classical simulation settings in the literature that can easily be created and reproduced using <code>peerannot</code>.</p>
<section id="simulated-independent-mistakes" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="simulated-independent-mistakes"><span class="header-section-number">3.2.1</span> Simulated independent mistakes</h3>
<p>The independent mistakes consider that each worker <span class="math inline">w_j</span> answers following a multinomial distribution with weights given at the row <span class="math inline">y_i^\star</span> of their confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span>. Each confusion matrix is generated diagonally dominant. Answers are independent of one another as each matrix is generated independently and each worker answers independently of other workers. In this setting, the DS model is expected to perform the best with enough data as we are simulating data from its assumed noise model.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=200</span> tasks and <span class="math inline">n_{\text{worker}}=30</span> workers with <span class="math inline">K=5</span> possible classes. Each task receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels.</p>
<div class="cell" data-execution_count="1">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="2">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> peerannot.helpers.helpers_visu <span class="im">import</span> feedback_effort, working_load</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> MaxNLocator</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-3-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div class="cell" data-execution_count="3">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="4">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent"</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_399b0 th {
  text-align: center;
}
#T_399b0_row0_col0, #T_399b0_row0_col1, #T_399b0_row0_col2, #T_399b0_row0_col3, #T_399b0_row0_col4, #T_399b0_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-independent" class="anchored">
<table id="T_399b0" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;1: AccTrain metric on simulated independent mistakes considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_399b0_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_399b0_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_399b0_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_399b0_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_399b0_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=5]</th>
<th id="T_399b0_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=10]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_399b0_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_399b0_row0_col0" class="data row0 col0">0.765</td>
<td id="T_399b0_row0_col1" class="data row0 col1">0.760</td>
<td id="T_399b0_row0_col2" class="data row0 col2">0.780</td>
<td id="T_399b0_row0_col3" class="data row0 col3">0.890</td>
<td id="T_399b0_row0_col4" class="data row0 col4">0.775</td>
<td id="T_399b0_row0_col5" class="data row0 col5">0.770</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>As expected by the simulation framework, <a href="#tbl-simu-independent">Table&nbsp;1</a> fits the DS model, thus leading to a better accuracy on the retrieval of the simulated label for the DS model. The MV aggregation doesn’t consider any worker-ability scoring or the task’s difficulty and performs the worse.</p>
</section>
<section id="simulated-correlated-mistakes" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="simulated-correlated-mistakes"><span class="header-section-number">3.2.2</span> Simulated correlated mistakes</h3>
<p>The correlated mistakes are also known as the student-teacher setting. Consider that the crowd of workers is divided into two categories: teachers and students such that <span class="math inline">n_{\text{teacher}} + n_{\text{student}}=n_{\text{worker}}</span>. Each student is randomly assigned to one teacher at the beginning of the experiment. We generate the (diagonally dominant) confusion matrices of each teacher and the students are associated with their’s teacher confusion matrix. Then, they all answer independently, following a multinomial distribution with weights given at the row <span class="math inline">y_i^\star</span> of their confusion matrix <span class="math inline">\pi^{(j)}\in\mathbb{R}^{K\times K}</span>.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=200</span> tasks and <span class="math inline">n_{\text{worker}}=30</span> with <span class="math inline">80\%</span> of students in the crowd. There are <span class="math inline">K=5</span> possible classes. Each task receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels.</p>
<div class="cell" data-execution_count="5">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy student<span class="op">-</span>teacher <span class="op">\</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.8</span> <span class="op">\</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>student_teacher</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="6">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-7-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div class="cell" data-execution_count="7">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>student_teacher<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="8">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"student_teacher"</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_student-teacher_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>display(results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<style type="text/css">
#T_b273a th {
  text-align: center;
}
#T_b273a_row0_col0, #T_b273a_row0_col1, #T_b273a_row0_col2, #T_b273a_row0_col3, #T_b273a_row0_col4, #T_b273a_row0_col5 {
  text-align: center;
}
</style>

<div id="tbl-simu-corr" class="anchored">
<table id="T_b273a" data-quarto-postprocess="true" class="table table-sm table-striped small">
<caption>Table&nbsp;2: AccTrain metric on simulated correlated mistakes considering classical feature-blind label aggregation strategies</caption>
<thead>
<tr class="header">
<th class="blank level0" data-quarto-table-cell-role="th">&nbsp;</th>
<th id="T_b273a_level0_col0" class="col_heading level0 col0" data-quarto-table-cell-role="th">MV</th>
<th id="T_b273a_level0_col1" class="col_heading level0 col1" data-quarto-table-cell-role="th">NAIVESOFT</th>
<th id="T_b273a_level0_col2" class="col_heading level0 col2" data-quarto-table-cell-role="th">GLAD</th>
<th id="T_b273a_level0_col3" class="col_heading level0 col3" data-quarto-table-cell-role="th">DS</th>
<th id="T_b273a_level0_col4" class="col_heading level0 col4" data-quarto-table-cell-role="th">DSWC[L=5]</th>
<th id="T_b273a_level0_col5" class="col_heading level0 col5" data-quarto-table-cell-role="th">DSWC[L=10]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td id="T_b273a_level0_row0" class="row_heading level0 row0" data-quarto-table-cell-role="th">AccTrain</td>
<td id="T_b273a_row0_col0" class="data row0 col0">0.705</td>
<td id="T_b273a_row0_col1" class="data row0 col1">0.690</td>
<td id="T_b273a_row0_col2" class="data row0 col2">0.645</td>
<td id="T_b273a_row0_col3" class="data row0 col3">0.755</td>
<td id="T_b273a_row0_col4" class="data row0 col4">0.795</td>
<td id="T_b273a_row0_col5" class="data row0 col5">0.815</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>With <a href="#tbl-simu-corr">Table&nbsp;2</a>, we see that with correlated data (<span class="math inline">24</span> students and <span class="math inline">6</span> teachers), using <span class="math inline">5</span> confusion matrices with DSWC[L=5] outperforms the vanilla DS strategy that does not consider the correlations. And the best performing method here estimates <span class="math inline">10</span> different confusion matrices (insted of <span class="math inline">30</span> for the vanilla DS model).</p>
</section>
<section id="simulated-mistakes-with-discrete-difficulty-levels-on-tasks" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="simulated-mistakes-with-discrete-difficulty-levels-on-tasks"><span class="header-section-number">3.2.3</span> Simulated mistakes with discrete difficulty levels on tasks</h3>
<p>For the final simulation setting, we consider the discrete difficulty presented in <span class="citation" data-cites="whitehill_whose_2009">Whitehill et al. (<a href="#ref-whitehill_whose_2009" role="doc-biblioref">2009</a>)</span>. Contrary to other simulations, we here consider that each worker is either good or bad and each task is either easy or hard. Easy tasks are answered without mistakes by involved workers. However, hard tasks are answered following the worker’s confusion matrix. The confusion matrix <span class="math inline">\pi^{(j)}</span> is diagonally dominant for good workers while each row is drawn uniformly in the simplex <span class="math inline">\Delta_K</span> for bad workers. Each worker then answers independently to the presented tasks.</p>
<p>We simulate <span class="math inline">n_{\text{task}}=500</span> tasks and <span class="math inline">n_{\text{worker}}=100</span> with <span class="math inline">35\%</span> of good workers in the crowd and <span class="math inline">50\%</span> of easy tasks. There are <span class="math inline">K=5</span> possible classes. Each task receives <span class="math inline">\vert\mathcal{A}(x_i)\vert=10</span> labels.</p>
<div class="cell" data-execution_count="9">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy discrete<span class="op">-</span>difficulty <span class="op">\</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.35</span> <span class="op">--</span>ratio<span class="op">-</span>diff <span class="dv">1</span> <span class="op">\</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback <span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="10">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="content_files/figure-html/cell-11-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</p>
<div class="cell" data-execution_count="11">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=2]"</span>, <span class="st">"DSWC[L=5]"</span>]:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty<span class="op">/</span> <span class="op">-</span>s {strat}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>

<!-- ```{python}
#| label: tbl-simu-discrete-diff
#| tbl-cap: AccTrain metric on simulated mistakes when tasks are associated a difficulty level considering classical feature-blind label aggregation strategies
#| code-fold: true
simu_corr = Path.cwd() / 'simus' / "discrete_difficulty"
results = {"mv": [], "naivesoft": [], "glad": [], "ds": [], "dswc[l=2]": [], "dswc[l=5]": []}
for strategy in results.keys():
  path_labels = simu_corr / "labels" / f"labels_discrete-difficulty_{strategy}.npy"
  ground_truth = np.load(simu_corr / "ground_truth.npy")
  labels = np.load(path_labels)
  acc = (
          np.mean(labels == ground_truth)
          if labels.ndim == 1
          else np.mean(
              np.argmax(labels, axis=1)
              == ground_truth
          )
        )
  results[strategy].append(acc)
results = pd.DataFrame(results, index=['AccTrain'])
results.columns = map(str.upper, results.columns)
results = results.style.set_table_styles([dict(selector='th', props=[('text-align', 'center')])])
results.set_properties(**{'text-align': 'center'})
results = results.format(precision=3)
display(results)
``` -->
<p>Finally, in this setting involving task diffulty coefficients, the only strategy that involves a latent variable for the task difficulty, knowing GLAD, outperforms the other other strategies (see <strong>?@tbl-simu-discrete-diff</strong>). Note that in this case, creating clusters of answers leads to worse decisions than a MV aggregation.</p>
<p>To summurize our simulations, we see that depending on workers answering strategies, different latent variable models perform best. However, these are unknown outside of a simulation framework, thus if we want to obtain labels from multiple responses, we need to investigate multiple models. This can be done easily with <code>peerannot</code> as we demonstrated using the <code>aggregate</code> module. However, one might not want to generate a label, simply learn a classifier to predict labels on unseen data. This leads us to another module part of <code>peerannot</code>.</p>
</section>
</section>
</section>
<section id="learning-from-crowdsourced-tasks" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Learning from crowdsourced tasks</h1>
<p>Most often, tasks are crowdsourced to create a large training set as modern machine learning models require more and more data. The aggregation step then simply becomes the first step in the complete learning pipeline. However, instead of aggregating labels, modern neural networks let us directly train a classifier from multiple noisy labels.</p>
<section id="classical-models-1" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="classical-models-1"><span class="header-section-number">4.1</span> Classical models</h2>
<p>In recent years, directly learning a classifier from noisy labels was introduced. Two of the most used models: CrowdLayer <span class="citation" data-cites="rodrigues2018deep">(<a href="#ref-rodrigues2018deep" role="doc-biblioref">Rodrigues and Pereira 2018</a>)</span> and CoNAL <span class="citation" data-cites="chu2021learning">(<a href="#ref-chu2021learning" role="doc-biblioref">Chu, Ma, and Wang 2021</a>)</span>, are directly available in <code>peerannot</code>. These two learning strategies directly incorporate a DS-based noise model in the neural network’s architecture.</p>
<p>CrowdLayer trains a classifier with noisy labels as follows. Let the scores (logits) output of a given classifier neural network <span class="math inline">\mathcal{C}</span> be <span class="math inline">z_i=\mathcal{C}(x_i)</span>. Then CrowdLayer adds a new layer <span class="math inline">\pi\in\mathbb{R}^{n_{\text{worker}}\times K\times K}</span>, the tensor of all <span class="math inline">\pi^{(j)}</span>s such that the crossentropy loss <span class="math inline">(\mathrm{CE})</span> is adapted to the crowdsourcing setting into <span class="math inline">\mathcal{L}_{CE}^{\text{CrowdLayer}}</span> and computed as: <span class="math display">
\mathcal{L}_{CE}^{\text{CrowdLayer}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(\sigma\left(\pi^{(j)}\sigma\big(z_i\big)\right), y_i^{(j)}) \enspace.
</span></p>
<p>The confusion matrices are incorporated as is into the network architecture as a new layer to transform the output probabilities to match each worker’s answer. However, for some datasets, it was noticed that global confusion occurs between the proposed classes. It is the case for example in the LabelMe dataset <span class="citation" data-cites="rodrigues2017learning">(<a href="#ref-rodrigues2017learning" role="doc-biblioref">Rodrigues et al. 2017</a>)</span> where classes overlap. In this case, <span class="citation" data-cites="chu2021learning">Chu, Ma, and Wang (<a href="#ref-chu2021learning" role="doc-biblioref">2021</a>)</span> proposed to extend the CrowdLayer model by not only modeling the worker confusion matrices; but also a global confusion matrix <span class="math inline">\pi^g\in\mathbb{R}^{K\times K}</span>.</p>
<div id="fig-conal" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="./figures/schema_bayesien_conal.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;2: Bayesian <a href="https://en.wikipedia.org/wiki/Plate_notation">plate notation</a> for CoNAL model. Each worker is assigned a confusion matrix <span class="math inline">\pi^{(j)}</span>. A global confusion matrix <span class="math inline">\pi^g</span> is shared between workers. A tradeoff between the global confusion and the local one is applied.</figcaption><p></p>
</figure>
</div>
<p>Given the output <span class="math inline">z_i=\mathcal{C}(x_i)\in\mathbb{R}^K</span> of a given classifier and task, CoNAL interpolates between the local confusion <span class="math inline">\pi^{(j)}\sigma(z_i)</span> and the global one <span class="math inline">\pi^g\sigma(z_i)</span>. The loss function is computed as follows: <span class="math display">
\begin{aligned}
&amp;\mathcal{L}_{CE}^{\text{CoNAL}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(h_i^{(j)}, y_i^{(j)}) \enspace, \\
&amp;\text{with } h_i^{(j)} = \sigma\left(\big(\omega_i^{(j)} \pi^g + (1-\omega_i^{(j)})\pi^{(j)}\big)z_i\right) \enspace.
\end{aligned} \
</span></p>
<p>The interpolation weight is defined as <span class="math inline">s_i^{(j)}\sim\mathcal{B}(w_i^{(j)})</span> and is unobservable in practice. So, to compute <span class="math inline">h_i^{(j)}</span>, the weight is obtained through an auxiliary network that projects the task <span class="math inline">x_i</span> onto <span class="math inline">v_i</span> and the worker <span class="math inline">w_j</span> onto <span class="math inline">u_j</span>, two vectors in an embedding space of dimension <span class="math inline">d\geq 1</span>. Finally, <span class="math inline">w_i^{(j)}=(1+\exp(- u_j^\top v_i))^{-1}</span>.</p>
<p>Both CrowdLayer and CoNAL model worker confusions directly in the classifier’s weights to learn from the noisy collected labels and are available in <code>peerannot</code> as we will see in the following.</p>
</section>
<section id="prediction-error-when-learning-from-crowdsourced-tasks" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="prediction-error-when-learning-from-crowdsourced-tasks"><span class="header-section-number">4.2</span> Prediction error when learning from crowdsourced tasks</h2>
<p>The <span class="math inline">\mathrm{AccTrain}</span> metric presented in <a href="#sec-evaluation-aggregation">Section&nbsp;3.2</a> might no longer be of interest when training a classifier. Classical error measurements involve a test dataset to estimate the generalization error. To do so, we present hereafter two error metrics. Assuming we trained our classifier <span class="math inline">f_\theta</span> on a training set:</p>
<ul>
<li>the test accuracy is computed as <span class="math inline">\frac{1}{n_{\text{test}}}\sum_{i=1}^{n_{\text{test}}}1_{\{y_i^\star = \widehat{f_\theta(x_i)}\}}</span></li>
<li>the expected calibration error <span class="citation" data-cites="guo_calibration_2017">(<a href="#ref-guo_calibration_2017" role="doc-biblioref">Guo et al. 2017</a>)</span> over <span class="math inline">M</span> equally spaced bins <span class="math inline">I_1,\dots,I_M</span>, computed as:</li>
</ul>
<p><span class="math display">
\mathrm{ECE} = \sum_{m=1}^M \frac{|B_m|}{n_{\text{task}}}|\mathrm{acc}(B_m)
- \mathrm{conf}(B_m)|\enspace,
</span></p>
<p>with <span class="math inline">B_m=\{x_i| \mathcal{C}(x_i)_{[1]}\in I_m\}</span> the tasks with predicted probability in the <span class="math inline">m</span>-th bin, <span class="math inline">\mathrm{acc}(B_m)</span> the accuracy of the network for the samples in <span class="math inline">B_m</span> and <span class="math inline">\mathrm{conf}(B_m)</span> the associated empirical confidence.</p>
<p>The accuracy represents how well the classifier generalizes, the expected calibration error (ECE) quantifies the deviation between the accuracy and the confidence of the classifier. Modern neural networks are known to often be overconfident in their predictions <span class="citation" data-cites="guo_calibration_2017">(<a href="#ref-guo_calibration_2017" role="doc-biblioref">Guo et al. 2017</a>)</span>. However, it has also been remarked that training on crowdsourced data, depending on the strategy, mitigates this confidence issue. That is why we propose to compare them both in our coming experiments. Note that the ECE error estimator is known to be biased <span class="citation" data-cites="gruber2022better">(<a href="#ref-gruber2022better" role="doc-biblioref">Gruber and Buettner 2022</a>)</span>. Smaller training sets are known to have a higher ECE estimation error. And in the crowdsourcing setting, openly available datasets are often quite small.</p>
</section>
<section id="use-case-with-peerannot-on-real-datasets" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="use-case-with-peerannot-on-real-datasets"><span class="header-section-number">4.3</span> Use case with <code>peerannot</code> on real datasets</h2>
<p>Few real crowdsourcing experiments have been released publicly. Among the available ones, CIFAR-10H <span class="citation" data-cites="peterson_human_2019">(<a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>)</span> is one of the largest with <span class="math inline">10 000</span> tasks labeled by workers (the testing set of CIFAR-10). The issue with CIFAR-10H is that there are little to no disagreements and a simple majority voting leads to a near-perfect <span class="math inline">\mathrm{AccTrain}</span> error. While with this dataset, because of the lack of disagreements and data curation <span class="citation" data-cites="peterson_human_2019 aitchison2020statistical">(<a href="#ref-peterson_human_2019" role="doc-biblioref">Peterson et al. 2019</a>; <a href="#ref-aitchison2020statistical" role="doc-biblioref">Aitchison 2021</a>)</span> comparing the impact of aggregation and end-to-end strategies might not be relevant, it is however a good benchmark for task difficulty identification and worker evaluation scoring</p>
<p>The LabelMe dataset was extracted from crowdsourcing segmentation experimentation and a subset of <span class="math inline">K=8</span> classes was released in <span class="citation" data-cites="rodrigues2017learning">Rodrigues et al. (<a href="#ref-rodrigues2017learning" role="doc-biblioref">2017</a>)</span>.</p>
<p>To install these datasets, we run the <code>install</code> command from <code>peerannot</code>:</p>
<div class="cell" data-execution_count="12">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>labelme.py</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>cifar10h.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let us use <code>peerannot</code> to train a Resnet34 on the LabelMe dataset for:</p>
<ul>
<li>aggregation strategies: MV, NS, DS, GLAD,</li>
<li>end-to-end strategies: CrowdLayer and CoNAL.</li>
</ul>
<p>As we can see, CoNAL strategy performs best. In this case, it is expected behavior as CoNAL was created for the LabelMe dataset. However, using <code>peerannot</code> we can look into <strong>why modeling common confusion returns better results with this dataset</strong>. To do so, we can explore the datasets from two points of view: worker-wise or task-wise.</p>
</section>
</section>
<section id="exploring-crowdsourced-datasets" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Exploring crowdsourced datasets</h1>
<p>If a dataset requires citizen knowledge to be labeled, it is because expert knowledge is long and costly to obtain. In the era of big data, where datasets are built using web scraping (or using a platform like <a href="https://www.mturk.com/">Amazon Mechanical Turk</a>), citizen science is popular as it is an easy way to produce many labels.</p>
<p>However, mistakes and confusions happen during these experiments. Sometimes involuntarily (<em>e.g.</em> because the task is too hard or the worker is unable to differentiate between two classes) and sometimes not (<em>e.g.</em> the worker is a spammer).</p>
<p>Underlying all the learning models and aggregation strategies, the cornerstone of crowdsourcing is evaluating the trust we put in each worker depending on the presented task. And with the gamification of crowdsourcing <span class="citation" data-cites="plantgame2016 tinati2017investigation">(<a href="#ref-plantgame2016" role="doc-biblioref">Servajean et al. 2016</a>; <a href="#ref-tinati2017investigation" role="doc-biblioref">Tinati et al. 2017</a>)</span>, it has become essential to find scoring metrics both for workers and tasks to keep citizens in the loop so to speak. This is the purpose of the identification module in <code>peerannot</code></p>
<p>Our test cases are both the CIFAR-10H dataset and the LabelMe dataset to compare the worker and task evaluation depending on the number of votes collected. Indeed, the LabelMe dataset has only up to three votes per task whereas CIFAR-10H accounts for nearly fifty votes per task.</p>
<section id="exploring-tasks-difficulty" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="exploring-tasks-difficulty"><span class="header-section-number">5.1</span> Exploring tasks’ difficulty</h2>
<p>To explore the tasks’ intrinsic difficulty, we propose to compare three scoring metrics:</p>
<ul>
<li>the entropy of the NS distribution: reliable with a big enough and not adversarial crowd, the entropy measures the inherent uncertainty of the distribution to the possible outcomes.</li>
<li>GLAD’s scoring: by construction, <span class="citation" data-cites="whitehill_whose_2009">Whitehill et al. (<a href="#ref-whitehill_whose_2009" role="doc-biblioref">2009</a>)</span> introduced a scalar coefficient to score the difficulty of a task <span class="math inline">\beta_i&gt;0</span>.</li>
<li>the WAUM: introduced in <span class="citation" data-cites="lefort2022improve">(<a href="#ref-lefort2022improve" role="doc-biblioref">Lefort et al. 2022</a>)</span>, this weighted area under the margins indicates how difficult it is for a model to classify the task given the crowdsourced labels and the trust we have in each worker.</li>
</ul>
<p>Note that each of these statistics is useful in its context. The entropy can not be used in a setting with <span class="math inline">|\mathcal{A}(x_i)|</span> low (few labels per task), in particular for the LabelMe dataset it is not informative. The WAUM can work with any number of labels, but the larger the better. However, as it uses a deep learning classifier, the WAUM needs the tasks <span class="math inline">(x_i)_i</span> in addition to the proposed labels while the other strategies are feature-blind.</p>
<section id="cifar-1oh-dataset" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="cifar-1oh-dataset"><span class="header-section-number">5.1.1</span> CIFAR-1OH dataset</h3>
<p>First, let us consider a dataset with a large number of tasks, annotations and workers: the CIFAR-10H dataset by <span class="citation" data-cites="peterson_human_2019">Peterson et al. (<a href="#ref-peterson_human_2019" role="doc-biblioref">2019</a>)</span>.</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"bird"</span>, <span class="dv">1</span>: <span class="st">"car"</span>, <span class="dv">2</span>: <span class="st">"cat"</span>, <span class="dv">3</span>: <span class="st">"deer"</span>, <span class="dv">4</span>: <span class="st">"dog"</span>, <span class="dv">5</span>: <span class="st">"frog"</span>, <span class="dv">6</span>: <span class="st">"horse"</span>, <span class="dv">7</span>: <span class="st">"plane"</span>, <span class="dv">8</span>: <span class="st">"ship"</span>, <span class="dv">9</span>: <span class="st">"truck"</span>}</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.95</span>, wspace<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="content_files/figure-html/cell-14-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Example of images to label from the CIFAR-10H dataset with label <code>bird</code>, <code>car</code>, <code>cat</code>, <code>deer</code>and <code>dog</code> (top to bottom) by row.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<div class="cell" data-execution_count="14">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="15">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> pearsonr</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> corrfunc(x, y, ax<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kws):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    r, _ <span class="op">=</span> pearsonr(x, y)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="kw">or</span> plt.gca()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">rf'$\rho$ = </span><span class="sc">{</span>r<span class="sc">:.2f}</span><span class="vs">'</span>, xy<span class="op">=</span>(<span class="fl">.1</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span>ax.transAxes)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">'glad'</span>: [], <span class="st">"entropy"</span>: []}</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"identification"</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"entropy"</span>] <span class="op">=</span> np.load(path <span class="op">/</span> <span class="st">'entropies.npy'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"glad"</span>] <span class="op">=</span> np.exp(np.load(path <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"difficulties.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co"># results["waum"] = pd.read_csv(path / "resnet34" / "waum_0.01_yang" / 'waum.csv')["waum"].values</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co"># axes = g.axes.flatten()</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co"># for i, ax in enumerate(axes):</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">#   if i % len(results) == 0:</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-difficulty-c10h" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-difficulty-c10h-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;3: Comparison of metrics scoring the task’s intrinsic difficulty in CIFAR-10H dataset.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
<section id="labelme-dataset" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="labelme-dataset"><span class="header-section-number">5.1.2</span> LabelMe dataset</h3>
<p>As for the LabelMe dataset, one difficulty in evaluating tasks’ intrinsic difficulty is that there are up to three votes given per task. Hence, the entropy in the distribution of the votes is no longer a reliable metric, and we need to rely on other models.</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"coast"</span>, <span class="dv">1</span>: <span class="st">"forest"</span>, <span class="dv">2</span>: <span class="st">"highway"</span>, <span class="dv">3</span>: <span class="st">"insidecity"</span>, <span class="dv">4</span>: <span class="st">"mountain"</span>, <span class="dv">5</span>: <span class="st">"opencountry"</span>, <span class="dv">6</span>: <span class="st">"street"</span>, <span class="dv">7</span>: <span class="st">"tallbuilding"</span>}</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.95</span>, wspace<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="content_files/figure-html/cell-17-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Example of images to label from the LabelMe dataset with label <code>coast</code>, <code>forest</code>, <code>highway</code>, <code>insidecity</code>and <code>mountain</code> (top to bottom) by row.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Now, let us compare the tasks’s difficulty distribution depending on the strategy considered using <code>peerannot</code>.</p>
<div class="cell" data-execution_count="17">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can see in <a href="#fig-difficulty-labelme">Figure&nbsp;4</a> that because the number of labels given per task is in <span class="math inline">\{1,2,3\}</span>, the entropy only takes four values and thus does not help to dissociate the tasks. In particular, tasks with only one label all have a null entropy, so not just consensual tasks.</p>
<div class="cell" data-execution_count="18">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> pearsonr</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> corrfunc(x, y, ax<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kws):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    r, _ <span class="op">=</span> pearsonr(x, y)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="kw">or</span> plt.gca()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">rf'$\rho$ = </span><span class="sc">{</span>r<span class="sc">:.2f}</span><span class="vs">'</span>, xy<span class="op">=</span>(<span class="fl">.1</span>, <span class="fl">.1</span>), xycoords<span class="op">=</span>ax.transAxes)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">'glad'</span>: [], <span class="st">"entropy"</span>: []}</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"identification"</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"entropy"</span>] <span class="op">=</span> np.load(path <span class="op">/</span> <span class="st">'entropies.npy'</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"glad"</span>] <span class="op">=</span> np.exp(np.load(path <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"difficulties.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-difficulty-labelme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-difficulty-labelme-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4: Comparison of metrics scoring the task’s intrinsic difficulty.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="exploring-workers-reliability" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="exploring-workers-reliability"><span class="header-section-number">5.2</span> Exploring workers’ reliability</h2>
<p>From the labels, we can explore different worker evaluation scores. GLAD’s strategy estimates a reliability scalar coefficient <span class="math inline">\alpha_j</span> per worker. With strategies looking to estimate confusion matrices, we investigate two scoring rules for workers:</p>
<ul>
<li>the trace of the confusion matrix: the closer to K the better the worker,</li>
<li>the spammer score <span class="citation" data-cites="raykar_ranking_2011">(<a href="#ref-raykar_ranking_2011" role="doc-biblioref">Raykar and Yu 2011</a>)</span> that is the Frobenius norm between the estimated confusion matrix <span class="math inline">\hat\pi^{(j)}</span> and the closest rank-<span class="math inline">1</span> matrix. The further to zero the better the worker.</li>
</ul>
<p>When the tasks are available, confusion-matrix-based deep learning models can also be of use. We thus add to the comparison the trace of the confusion matrices with CrowdLayer and CoNAL on the datasets. For CoNAL, we only consider the trace of the confusion matrix <span class="math inline">\pi^{(j)}</span> in the pairwise comparison, and provide the common confusion matrix <span class="math inline">\pi^g</span> as separate.</p>
<section id="cifar-10h" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="cifar-10h"><span class="header-section-number">5.2.1</span> CIFAR-10H</h3>
<p>The Cifar-10H dataset has few disagreements among workers. From <strong>?@fig-abilities-cifar10H</strong>, we can see that in this dataset, different methods easily separate the worse workers from the rest of the crowd (workers in the tail of the distribution). However, these strategies disagree on the ranking of good against best workers as they do not measure the same properties.</p>
<div class="cell" data-execution_count="19">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="20">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"trace_confusion"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"trace_confusion"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-abilities-cifar10h" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-abilities-cifar10h-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;5: Comparison of ability scores by workers for the CIFAR-10H dataset.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
<section id="labelme" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="labelme"><span class="header-section-number">5.2.2</span> LabelMe</h3>
<p>Finally, let us evaluate workers for the LabelMe dataset. Because of the lack of data,</p>
<div class="cell" data-execution_count="21">
<details open="">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="22">
<details>
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"trace_confusion"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"trace_confusion"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-abilities-labelme" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="content_files/figure-html/fig-abilities-labelme-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6: Comparison of ability scores by workers for the labelme dataset.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="conclusion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusion</h1>
<p>We introduced <code>peerannot</code>, a library to handle crowdsourced datasets. This library enables both easy label aggregation and direct training strategies with classical state-of-the-art classifiers. The identification module of the library allows exploring the collected data from both the tasks and the workers’ point of view for better scorings and data cleaning procedures. Our library also comes with templated datasets to better share crowdsourced datasets and have strategies more uniform to test on.</p>
<p>We hope that this library helps reproducibility in the crowdsourcing community and also standardizes training from crowdsourced datasets. New strategies can easily be incorporated into the open-source code <a href="https://github.com/peerannot/peerannot">available on github</a>. Finally, as <code>peerannot</code> is mostly directed to handle classification datasets, one of our future works would be to consider other <code>peerannot</code> modules to handle crowdsourcing for object detection, segmentation and even worker evaluation in other contexts like peer-grading.</p>
<!-- -->

</section>
<section id="bibliography" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliography</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-aitchison2020statistical" class="csl-entry" role="listitem">
Aitchison, Laurence. 2021. <span>“A Statistical Theory of Cold Posteriors in Deep Neural Networks.”</span> In <em>ICLR</em>.
</div>
<div id="ref-chagneux2023" class="csl-entry" role="listitem">
Chagneux, Mathis, Sylvain LeCorff, Pierre Gloaguen, Charles Ollion, Océane Lepâtre, and Antoine Bruge. 2023. <span>“Macrolitter Video Counting on Riverbanks Using State Space Models and Moving Cameras.”</span> <em>Computo</em>, February. <a href="https://doi.org/10.57750/845m-f805">https://doi.org/10.57750/845m-f805</a>.
</div>
<div id="ref-chu2021learning" class="csl-entry" role="listitem">
Chu, Zhendong, Jing Ma, and Hongning Wang. 2021. <span>“Learning from Crowds by Modeling Common Confusions.”</span> In <em>AAAI</em>, 5832–40.
</div>
<div id="ref-dawid_maximum_1979" class="csl-entry" role="listitem">
Dawid, AP, and AM Skene. 1979. <span>“Maximum Likelihood Estimation of Observer Error-Rates Using the <span>EM</span> Algorithm.”</span> <em>J. R. Stat. Soc. Ser. C. Appl. Stat.</em> 28 (1): 20–28.
</div>
<div id="ref-imagenet_cvpr09" class="csl-entry" role="listitem">
Deng, J., W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. 2009. <span>“ImageNet: A Large-Scale Hierarchical Image Database.”</span> In <em>CVPR</em>.
</div>
<div id="ref-gao2013minimax" class="csl-entry" role="listitem">
Gao, Chao, and Dengyong Zhou. 2013. <span>“Minimax Optimal Convergence Rates for Estimating Ground Truth from Crowdsourced Labels.”</span> <em>arXiv Preprint arXiv:1310.5764</em>.
</div>
<div id="ref-Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021" class="csl-entry" role="listitem">
Garcin, C., A. Joly, P. Bonnet, A. Affouard, J.-C. Lombardo, M. Chouet, M. Servajean, T. Lorieul, and J. Salmon. 2021. <span>“Pl@ntNet-300K: A Plant Image Dataset with High Label Ambiguity and a Long-Tailed Distribution.”</span> In <em>Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks</em>.
</div>
<div id="ref-gruber2022better" class="csl-entry" role="listitem">
Gruber, Sebastian Gregor, and Florian Buettner. 2022. <span>“Better Uncertainty Calibration via Proper Scores for Classification and Beyond.”</span> In <em>Advances in Neural Information Processing Systems</em>.
</div>
<div id="ref-guo_calibration_2017" class="csl-entry" role="listitem">
Guo, C, G Pleiss, Y Sun, and KQ Weinberger. 2017. <span>“On Calibration of Modern Neural Networks.”</span> In <em>ICML</em>, 1321.
</div>
<div id="ref-imamura2018analysis" class="csl-entry" role="listitem">
Imamura, Hideaki, Issei Sato, and Masashi Sugiyama. 2018. <span>“Analysis of Minimax Error Rate for Crowdsourcing and Its Application to Worker Clustering Model.”</span> In <em>ICML</em>, 2147–56.
</div>
<div id="ref-james1998majority" class="csl-entry" role="listitem">
James, Gareth Michael. 1998. <span>“Majority Vote Classifiers: Theory and Applications.”</span> PhD thesis, Stanford University.
</div>
<div id="ref-kasmi2023crowdsourced" class="csl-entry" role="listitem">
Kasmi, Gabriel, Yves-Marie Saint-Drenan, David Trebosc, Raphaël Jolivet, Jonathan Leloux, Babacar Sarr, and Laurent Dubus. 2023. <span>“A Crowdsourced Dataset of Aerial Images with Annotated Solar Photovoltaic Arrays and Installation Metadata.”</span> <em>Scientific Data</em> 10 (1): 59.
</div>
<div id="ref-khattak_toward_2017" class="csl-entry" role="listitem">
Khattak, Faiza Khan. 2017. <span>“Toward a Robust and Universal Crowd Labeling Framework.”</span> PhD thesis, Columbia University.
</div>
<div id="ref-krizhevsky2009learning" class="csl-entry" role="listitem">
Krizhevsky, Alex, and Geoffrey Hinton. 2009. <span>“Learning Multiple Layers of Features from Tiny Images.”</span> University of Toronto.
</div>
<div id="ref-lefort2022improve" class="csl-entry" role="listitem">
Lefort, Tanguy, Benjamin Charlier, Alexis Joly, and Joseph Salmon. 2022. <span>“Identify Ambiguous Tasks Combining Crowdsourced Labels by Weighting Areas Under the Margin.”</span> <em>arXiv Preprint arXiv:2209.15380</em>.
</div>
<div id="ref-cocodataset" class="csl-entry" role="listitem">
Lin, Tsung-Yi, Michael Maire, Serge J. Belongie, Lubomir D. Bourdev, Ross B. Girshick, James Hays, Pietro Perona, Deva Ramanan, Piotr Doll’a r, and C. Lawrence Zitnick. 2014. <span>“Microsoft <span>COCO:</span> Common Objects in Context.”</span> <em>CoRR</em> abs/1405.0312. <a href="http://arxiv.org/abs/1405.0312">http://arxiv.org/abs/1405.0312</a>.
</div>
<div id="ref-torchvision" class="csl-entry" role="listitem">
Marcel, Sébastien, and Yann Rodriguez. 2010. <span>“Torchvision the Machine-Vision Package of Torch.”</span> In <em>Proceedings of the 18th ACM International Conference on Multimedia</em>, 1485–88. MM ’10. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/1873951.1874254">https://doi.org/10.1145/1873951.1874254</a>.
</div>
<div id="ref-park2022calibration" class="csl-entry" role="listitem">
Park, Seo Yeon, and Cornelia Caragea. 2022. <span>“On the Calibration of Pre-Trained Language Models Using Mixup Guided by Area Under the Margin and Saliency.”</span> In <em>ACML</em>, 5364–74.
</div>
<div id="ref-passonneau-carpenter-2014-benefits" class="csl-entry" role="listitem">
Passonneau, Rebecca J., and Bob Carpenter. 2014. <span>“The Benefits of a Model of Annotation.”</span> <em>Transactions of the Association for Computational Linguistics</em> 2: 311–26.
</div>
<div id="ref-pytorch" class="csl-entry" role="listitem">
Paszke, Adam, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, et al. 2019. <span>“PyTorch: An Imperative Style, High-Performance Deep Learning Library.”</span> In <em>NeurIPS</em>, 8024–35.
</div>
<div id="ref-peterson_human_2019" class="csl-entry" role="listitem">
Peterson, Joshua C., Ruairidh M. Battleday, Thomas L. Griffiths, and Olga Russakovsky. 2019. <span>“Human Uncertainty Makes Classification More Robust.”</span> In <em>ICCV</em>, 9617–26.
</div>
<div id="ref-pleiss_identifying_2020" class="csl-entry" role="listitem">
Pleiss, Geoff, Tianyi Zhang, Ethan R Elenberg, and Kilian Q Weinberger. 2020. <span>“Identifying Mislabeled Data Using the Area Under the Margin Ranking.”</span> In <em>NeurIPS</em>.
</div>
<div id="ref-raykar_ranking_2011" class="csl-entry" role="listitem">
Raykar, Vikas C, and Shipeng Yu. 2011. <span>“Ranking Annotators for Crowdsourced Labeling Tasks.”</span> In <em>NeurIPS</em>, 1809–17.
</div>
<div id="ref-rodrigues2017learning" class="csl-entry" role="listitem">
Rodrigues, Filipe, Mariana Lourenco, Bernardete Ribeiro, and Francisco C Pereira. 2017. <span>“Learning Supervised Topic Models for Classification and Regression from Crowds.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 39 (12): 2409–22.
</div>
<div id="ref-rodrigues2018deep" class="csl-entry" role="listitem">
Rodrigues, Filipe, and Francisco Pereira. 2018. <span>“Deep Learning from Crowds.”</span> In <em>AAAI</em>. Vol. 32.
</div>
<div id="ref-plantgame2016" class="csl-entry" role="listitem">
Servajean, Maximilien, Alexis Joly, Dennis Shasha, Julien Champ, and Esther Pacitti. 2016. <span>“ThePlantGame: Actively Training Human Annotators for Domain-Specific Crowdsourcing.”</span> In <em>Proceedings of the 24th ACM International Conference on Multimedia</em>, 720–21. MM ’16. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2964284.2973820">https://doi.org/10.1145/2964284.2973820</a>.
</div>
<div id="ref-servajean2017crowdsourcing" class="csl-entry" role="listitem">
———. 2017. <span>“Crowdsourcing Thousands of Specialized Labels: A <span>Bayesian</span> Active Training Approach.”</span> <em>IEEE Transactions on Multimedia</em> 19 (6): 1376–91.
</div>
<div id="ref-sinha2018fast" class="csl-entry" role="listitem">
Sinha, Vaibhav B, Sukrut Rao, and Vineeth N Balasubramanian. 2018. <span>“Fast <span>Dawid-Skene</span>: A Fast Vote Aggregation Scheme for Sentiment Classification.”</span> <em>arXiv Preprint arXiv:1803.02781</em>.
</div>
<div id="ref-tinati2017investigation" class="csl-entry" role="listitem">
Tinati, Ramine, Markus Luczak-Roesch, Elena Simperl, and Wendy Hall. 2017. <span>“An Investigation of Player Motivations in Eyewire, a Gamified Citizen Science Project.”</span> <em>Computers in Human Behavior</em> 73: 527–40.
</div>
<div id="ref-whitehill_whose_2009" class="csl-entry" role="listitem">
Whitehill, J, T Wu, J Bergsma, J Movellan, and P Ruvolo. 2009. <span>“Whose Vote Should Count More: Optimal Integration of Labels from Labelers of Unknown Expertise.”</span> In <em>NeurIPS</em>. Vol. 22.
</div>
<div id="ref-YasminRomena2022ICIC" class="csl-entry" role="listitem">
Yasmin, Romena, Md Mahmudulla Hassan, Joshua T Grassel, Harika Bhogaraju, Adolfo R Escobedo, and Olac Fuentes. 2022. <span>“Improving Crowdsourcing-Based Image Classification Through Expanded Input Elicitation and Machine Learning.”</span> <em>Frontiers in Artificial Intelligence</em> 5: 848056.
</div>
<div id="ref-zhang2017mixup" class="csl-entry" role="listitem">
Zhang, Hongyi, Moustapha Cissé, Yann N. Dauphin, and David Lopez-Paz. 2018. <span>“Mixup: Beyond Empirical Risk Minimization.”</span> In <em>ICLR</em>.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{lefort2023,
  author = {Lefort, Tanguy and Charlier, Benjamin and Joly, Alexis and
    Salmon, Joseph},
  publisher = {Société Française de Statistique},
  title = {Peerannot: Learning from Crowdsourced Image Datasets with
    {Python}},
  journal = {Computo},
  date = {2023-04-19},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {Crowdsourcing is a quick and easy way to collect labels
    for large datasets, involving many workers. However, workers often
    disagree with each other. Sources of error can arise from the
    workers’ skills, but also from the intrinsic difficulty of the task.
    We present `peerannot`: a `Python` library for managing and learning
    from crowdsourced labels. Our library allows users to aggregate
    labels from common noise models or train a deep learning-based
    classifier directly from crowdsourced labels. In addition, we
    provide an identification module to easily explore the task
    difficulty of datasets and worker capabilities.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-lefort2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Lefort, Tanguy, Benjamin Charlier, Alexis Joly, and Joseph Salmon. 2023.
<span>“Peerannot: Learning from Crowdsourced Image Datasets with
Python.”</span> <em>Computo</em>, April. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb25" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Peerannot: learning from crowdsourced image datasets with Python"</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> ""</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Tanguy Lefort</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: tanguy.lefort@umontpellier.fr</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://tanglef.github.io</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0009-0000-6710-3221</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Name of Affiliation one</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Statistics</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://someplace.themoon.org</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Benjamin Charlier</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co">    email: benjamin.charlier@umontpellier.fr</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://imag.umontpellier.fr/~charlier/index.php?page=index&amp;lang=en</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Name of Afficiliation two</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Computer Science</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://someplace.themoon.org</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Alexis Joly</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a><span class="co">    email: alexis.joly@inria.fr</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://www-sop.inria.fr/members/Alexis.Joly/wiki/pmwiki.php</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-2161-9940</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Name of Afficiliation two</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Computer Science</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://someplace.themoon.org</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Joseph Salmon</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="co">    email: joseph.salmon@umontpellier.fr</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://josephsalmon.eu/</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-3181-0634</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Name of Afficiliation two</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Computer Science</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://someplace.themoon.org</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="co">  Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers.</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="co">  However, it is common for workers to disagree with each other.</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a><span class="co">  Sources of error can arise from the workers' skills, but also from the intrinsic difficulty of the task.</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a><span class="co">  We introduce peerannot, a Python library for managing and learning from crowdsourced labels.</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a><span class="co">  Crowdsourcing is a quick and easy way to collect labels for large datasets, involving many workers. However, workers often disagree with each other. Sources of error can arise from the workers' skills, but also from the intrinsic difficulty of the task. We present `peerannot`: a `Python` library for managing and learning from crowdsourced labels. Our library allows users to aggregate labels from common noise models or train a deep learning-based classifier directly from crowdsourced labels. In addition, we provide an identification module to easily explore the task difficulty of datasets and worker capabilities.</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [crowdsourcing, label noise, task difficulty, worker ability]</span></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-python"</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span><span class="co">  # to remove at the end</span></span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a><span class="co">  cache: false</span></span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction: crowdsourcing in image classification</span></span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>Image datasets widely use crowdsourcing to collect labels, involving many workers that can annotate images for a small cost (or even free for instance in citizen science) and faster than using expert labeling.</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>Many classical datasets considered in machine learning have been created with human intervention to create labels, such as CIFAR-$10$, <span class="co">[</span><span class="ot">@krizhevsky2009learning</span><span class="co">]</span>,</span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>ImageNet <span class="co">[</span><span class="ot">@imagenet_cvpr09</span><span class="co">]</span> or <span class="co">[</span><span class="ot">@Garcin_Joly_Bonnet_Affouard_Lombardo_Chouet_Servajean_Lorieul_Salmon2021</span><span class="co">]</span> in image classification, but also COCO <span class="co">[</span><span class="ot">@cocodataset</span><span class="co">]</span>, solar photovoltaic arrays <span class="co">[</span><span class="ot">@kasmi2023crowdsourced</span><span class="co">]</span> or even macro litter <span class="co">[</span><span class="ot">@chagneux2023</span><span class="co">]</span> in image segmentation and object counting.</span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>Crowdsourced datasets induce at least three major challenges to which we contribute with <span class="in">`peerannot`</span>:</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>*How to identify good workers in the crowd?* When multiple answers are given to a single task, looking for who to trust for which type of task becomes necessary to estimate the ground truth or later train a model with as few noise sources as possible. The module <span class="in">`identify`</span> uses different scoring metrics to create a worker and/or task evaluation.</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>  This is particularly relevant considering the gamification of crowdsourcing experiments <span class="co">[</span><span class="ot">@plantgame2016</span><span class="co">]</span></span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>*How to aggregate multiple labels into a single label from crowdsourced tasks?* This occurs for example when dealing with a single dataset that has been labeled by multiple workers with disagreements. This is also encountered with other scoring issues such as polls, reviews, peer-grading, *etc.* In our framework this is treated with the <span class="in">`aggregate`</span> command, that given multiple labels, infers a ground truth label.</span>
<span id="cb25-79"><a href="#cb25-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-80"><a href="#cb25-80" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>*How to learn a classifier from crowdsourced datasets?* Where the first question is bound by aggregating multiple labels into a single one, this considers the case where we do not need a single label to train on, but instead train a classifier on the crowdsourced data, with the motivation to perform well on a testing set. This end-to-end vision, is common in machine learning, however, it requires the actual tasks (the images, texts, videos, *etc.*) to train on -- and in crowdsourced datasets publicly available, they are not always available. This is treated with the <span class="in">`aggregate-deep`</span> command.</span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a>The library <span class="in">`peerannot`</span> addresses these practical questions within a reproducible setting. Indeed, the complexity of experiments often leads to a lack of transparency and reproducible results for simulations and real datasets.</span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a>We propose standard simulation settings with explicit implementation parameters that can be shared.</span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>For real datasets, <span class="in">`peerannot`</span> is compatible with standard neural networks architectures from the <span class="in">`Torchvision`</span> <span class="co">[</span><span class="ot">@torchvision</span><span class="co">]</span> library and <span class="in">`Pytorch`</span> <span class="co">[</span><span class="ot">@pytorch</span><span class="co">]</span>, allowing a flexible framework with easy-to-share scripts to reproduce experiments.</span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a><span class="al">![From crowdsourced labels to training a classifier neural network, the learning pipeline using the `peerannot` library.](./figures/strategiesbis.png)</span></span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-88"><a href="#cb25-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-89"><a href="#cb25-89" aria-hidden="true" tabindex="-1"></a><span class="fu"># Notation and package structure</span></span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a><span class="fu">## Crowdsourcing notation</span></span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a>Let us consider the classical supervised learning classification framework. A training set $\mathcal{D}=<span class="sc">\{</span>(x_i, y_i^\star)<span class="sc">\}</span>_{i=1}^{n_{\text{task}}}$ is composed of $n_{\text{task}}$ tasks $x_i\in\mathcal{X}$ (the feature space) with ground truth label $y_i^\star \in\mathcal <span class="co">[</span><span class="ot">K</span><span class="co">]</span>={1,\dots,K}$ one of the $K$ possible classes.</span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a>In the following, the tasks considered are generally RGB images. We use the notation $\sigma$ for the softmax function.</span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>With crowdsourced data the ground truth $y_i^\star$ is unknown, and there is no single label that can be trusted as in standard supervised learning (even on the train set!).</span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a>Instead, for a given task $x_i$, a worker $w_j$ proposes a label $y_i^{(j)}$.</span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a>The set of workers answering the task $x_i$ is denoted by $\mathcal{A}(x_i)=<span class="sc">\{</span>j\in<span class="co">[</span><span class="ot">n_\text{worker}</span><span class="co">]</span>: w_j \text{ answered }x_i<span class="sc">\}</span>$.</span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>The cardinal $\vert \mathcal{A}(x_i)\vert$ is called the feedback effort on the task $x_i$.</span>
<span id="cb25-100"><a href="#cb25-100" aria-hidden="true" tabindex="-1"></a>Note that the feedback effort can not exceed the total number of workers $n_{\text{worker}}$.</span>
<span id="cb25-101"><a href="#cb25-101" aria-hidden="true" tabindex="-1"></a>Similarly, one can adopt a worker point of view: the set of tasks answered by a worker $w_j$ is denoted $\mathcal{T}(w_j)=<span class="sc">\{</span>i\in<span class="co">[</span><span class="ot">n_\text{task}</span><span class="co">]</span>: w_j \text{ answered } x_i<span class="sc">\}</span>$.</span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a>The cardinal $\vert \mathcal{T}(w_j)\vert$ is called the workerload of $w_j$.</span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>The final dataset can then be decomposed as:</span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>\mathcal{D}_{\text{train}} := \bigcup_{i\in[n_\text{task}]} \{(x_i, (y_i^{(j)}) \text{ for }j\in\mathcal{A}(x_i))\} = \bigcup_{j\in[n_\text{worker}]} <span class="sc">\{</span>(x_i, (y_i^{(j)})) \text{ for }i \in\mathcal{T}(w_j)<span class="sc">\}</span> \enspace.</span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>In this article, we do not address the setting where workers report their self-confidence <span class="co">[</span><span class="ot">@YasminRomena2022ICIC</span><span class="co">]</span>, nor settings where workers are presented a trapping set -- *i.e* a subset of tasks where the ground truth is known to evaluate them with known labels <span class="co">[</span><span class="ot">@khattak_toward_2017</span><span class="co">]</span>.</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a><span class="fu">## Storing crowdsourced datasets in `peerannot`</span></span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a>To store crowdsourcing datasets efficiently and in a standardized way, <span class="in">`peerannot`</span> proposes the following structure, where each dataset equals a folder:</span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a><span class="ex">datasetname</span></span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a>      <span class="ex">├──</span> train</span>
<span id="cb25-119"><a href="#cb25-119" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     ├── class0</span>
<span id="cb25-120"><a href="#cb25-120" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     │     ├─ task0-<span class="op">&lt;</span>vote_index_0<span class="op">&gt;</span>.png</span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     │     ├─ task1-<span class="op">&lt;</span>vote_index_1<span class="op">&gt;</span>.png</span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     │     ├─ ...</span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     │     └─ taskn0-<span class="op">&lt;</span>vote_index_n0<span class="op">&gt;</span>.png</span>
<span id="cb25-124"><a href="#cb25-124" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     ├── class1</span>
<span id="cb25-125"><a href="#cb25-125" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     ├── ...</span>
<span id="cb25-126"><a href="#cb25-126" aria-hidden="true" tabindex="-1"></a>      <span class="ex">│</span>     └── classK</span>
<span id="cb25-127"><a href="#cb25-127" aria-hidden="true" tabindex="-1"></a>      <span class="ex">├──</span> val</span>
<span id="cb25-128"><a href="#cb25-128" aria-hidden="true" tabindex="-1"></a>      <span class="ex">├──</span> test</span>
<span id="cb25-129"><a href="#cb25-129" aria-hidden="true" tabindex="-1"></a>      <span class="ex">├──</span> metadata.json</span>
<span id="cb25-130"><a href="#cb25-130" aria-hidden="true" tabindex="-1"></a>      <span class="ex">└──</span> answers.json</span>
<span id="cb25-131"><a href="#cb25-131" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-132"><a href="#cb25-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-133"><a href="#cb25-133" aria-hidden="true" tabindex="-1"></a>If the tasks (images) are available, they must be stored as it is usual to store <span class="in">`ImageFolder`</span> datasets with <span class="in">`pytorch`</span> into a <span class="in">`train`</span>, <span class="in">`val`</span> and <span class="in">`test`</span> folder.</span>
<span id="cb25-134"><a href="#cb25-134" aria-hidden="true" tabindex="-1"></a>Each image can have its name followed by its index in the <span class="in">`answers.json`</span> file.</span>
<span id="cb25-135"><a href="#cb25-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-136"><a href="#cb25-136" aria-hidden="true" tabindex="-1"></a>The <span class="in">`answers.json`</span> file stores the different votes for each task as described in @fig-answers.</span>
<span id="cb25-137"><a href="#cb25-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-138"><a href="#cb25-138" aria-hidden="true" tabindex="-1"></a><span class="al">![From collected labels to data storage in the `answers.json` file for a binary classification task on recognizing smiling faces. (left: data stored in `peerannot`, right: table of data collected)](./figures/json_answers.png)</span>{#fig-answers fig-align="center"}</span>
<span id="cb25-139"><a href="#cb25-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-140"><a href="#cb25-140" aria-hidden="true" tabindex="-1"></a>In this example, there are three tasks, $n_{worker}=4$ workers and $K=2$ classes.</span>
<span id="cb25-141"><a href="#cb25-141" aria-hidden="true" tabindex="-1"></a>For the first task, the feedback effort is $\vert\mathcal{A}(x_1)\vert=4$.</span>
<span id="cb25-142"><a href="#cb25-142" aria-hidden="true" tabindex="-1"></a>The workerload of $w_2$ is $\vert\mathcal{T}(w_2)\vert=2$.</span>
<span id="cb25-143"><a href="#cb25-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-144"><a href="#cb25-144" aria-hidden="true" tabindex="-1"></a>Finally, a <span class="in">`metadata.json`</span> file includes relevant information related to the crowdsourcing experiment such as the number of workers, the number of tasks, *etc.*</span>
<span id="cb25-145"><a href="#cb25-145" aria-hidden="true" tabindex="-1"></a>For example, a minimal <span class="in">`metadata.json`</span> file for the toy dataset presented in @fig-answers is:</span>
<span id="cb25-146"><a href="#cb25-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-149"><a href="#cb25-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{json}</span></span>
<span id="cb25-150"><a href="#cb25-150" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb25-151"><a href="#cb25-151" aria-hidden="true" tabindex="-1"></a>    <span class="st">"name"</span><span class="op">:</span> <span class="st">"toy-data"</span><span class="op">,</span></span>
<span id="cb25-152"><a href="#cb25-152" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_classes"</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb25-153"><a href="#cb25-153" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_workers"</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb25-154"><a href="#cb25-154" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_tasks"</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb25-155"><a href="#cb25-155" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb25-156"><a href="#cb25-156" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-157"><a href="#cb25-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-158"><a href="#cb25-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-159"><a href="#cb25-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-160"><a href="#cb25-160" aria-hidden="true" tabindex="-1"></a><span class="fu"># Aggregation strategies in crowdsourcing</span></span>
<span id="cb25-161"><a href="#cb25-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-162"><a href="#cb25-162" aria-hidden="true" tabindex="-1"></a>The first question we address with <span class="in">`peerannot`</span> is: *How to aggregate multiple labels into a single label from crowdsourced tasks?*</span>
<span id="cb25-163"><a href="#cb25-163" aria-hidden="true" tabindex="-1"></a>The aggregation step can lead to two types of learnable labels $\hat y_i\in\Delta_{K}$ defined on the simplex of dimension $K-1$ depending on the use case:</span>
<span id="cb25-164"><a href="#cb25-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-165"><a href="#cb25-165" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a **hard** label: $\hat y_i$ is a Dirac distribution, this can be encoded as a classical label in $<span class="co">[</span><span class="ot">K</span><span class="co">]</span>$,</span>
<span id="cb25-166"><a href="#cb25-166" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a **soft** label: $\hat y_i\in\Delta_{K}$ can be a probability distribution other than Dirac distribution, in that case, each coefficient in $\hat y_i$ represents the probability to belong to the given class.</span>
<span id="cb25-167"><a href="#cb25-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-168"><a href="#cb25-168" aria-hidden="true" tabindex="-1"></a>Learning from soft labels has been shown to improve learning performance and make the classifier learn the task ambiguity <span class="co">[</span><span class="ot">@zhang2017mixup;@peterson_human_2019;@park2022calibration</span><span class="co">]</span>.</span>
<span id="cb25-169"><a href="#cb25-169" aria-hidden="true" tabindex="-1"></a>However, crowdsourcing is often used as a stepping stone to creating a new dataset and we usually expect a classification dataset to associate a task $x_i$ to a single label and not a full probability distribution.</span>
<span id="cb25-170"><a href="#cb25-170" aria-hidden="true" tabindex="-1"></a>In this case, we recommend in practice releasing the anonymous answered labels and the aggregation strategy used to reach a consensus on a single label.</span>
<span id="cb25-171"><a href="#cb25-171" aria-hidden="true" tabindex="-1"></a>With <span class="in">`peerannot`</span>, both soft and hard labels can be produced.</span>
<span id="cb25-172"><a href="#cb25-172" aria-hidden="true" tabindex="-1"></a>Note that when a strategy produces a soft label, a hard label can be induced by taking the class with the maximum probability.</span>
<span id="cb25-173"><a href="#cb25-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-174"><a href="#cb25-174" aria-hidden="true" tabindex="-1"></a><span class="fu">## Classical models</span></span>
<span id="cb25-175"><a href="#cb25-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-176"><a href="#cb25-176" aria-hidden="true" tabindex="-1"></a>While the most intuitive way to create a label from multiple answers for any type of crowdsourced task would be to take the majority vote (MV), this strategy has many shortcomings <span class="co">[</span><span class="ot">@james1998majority</span><span class="co">]</span> -- there is no noise model, no worker reliability estimated, no task difficulty involved and especially no way to remove poorly performing workers. This baseline aggregation can be expressed as:</span>
<span id="cb25-177"><a href="#cb25-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-178"><a href="#cb25-178" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-179"><a href="#cb25-179" aria-hidden="true" tabindex="-1"></a>\hat y_i^{\text{MV}} = \operatornamewithlimits{argmax}_{k\in[K]} \sum_{j\in\mathcal{A}(x_i)} 1_{<span class="sc">\{</span>y_i^{(j)}=k<span class="sc">\}</span>} \enspace.</span>
<span id="cb25-180"><a href="#cb25-180" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-181"><a href="#cb25-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-182"><a href="#cb25-182" aria-hidden="true" tabindex="-1"></a>One pitfall with the MV is that the label produced is hard, hence the ambiguity is discarded by construction. To remedy this, the Naive Soft (NS) labeling consists in using the empirical frequency distribution as the task label:</span>
<span id="cb25-183"><a href="#cb25-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-184"><a href="#cb25-184" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-185"><a href="#cb25-185" aria-hidden="true" tabindex="-1"></a>\hat y_i^{\text{NS}} = \bigg(\frac{1}{\vert\mathcal{A}(x_i)\vert}\sum_{j\in\mathcal{A}(x_i)} 1_{<span class="sc">\{</span>y_i^{(j)}=k<span class="sc">\}</span>} \bigg)_{j\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>} \enspace.</span>
<span id="cb25-186"><a href="#cb25-186" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-187"><a href="#cb25-187" aria-hidden="true" tabindex="-1"></a>With the NS label, we keep the ambiguity, but all workers and all tasks are put on the same level. In practice, it is known that each worker comes with their abilities, thus modeling this knowledge can produce better results.</span>
<span id="cb25-188"><a href="#cb25-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-189"><a href="#cb25-189" aria-hidden="true" tabindex="-1"></a>Going further into the aggregation, researchers began creating a noise model to take into account the workers' abilities in the aggregation.</span>
<span id="cb25-190"><a href="#cb25-190" aria-hidden="true" tabindex="-1"></a>These types of models are most often EM-based and one of the most studied <span class="co">[</span><span class="ot">@gao2013minimax</span><span class="co">]</span> and applied <span class="co">[</span><span class="ot">@servajean2017crowdsourcing;@rodrigues2018deep</span><span class="co">]</span> is the Dawid and Skene's (DS) model <span class="co">[</span><span class="ot">@dawid_maximum_1979</span><span class="co">]</span>.</span>
<span id="cb25-191"><a href="#cb25-191" aria-hidden="true" tabindex="-1"></a>Assuming the workers are answering tasks independently, this model boils down to model pairwise confusions between each possible class.</span>
<span id="cb25-192"><a href="#cb25-192" aria-hidden="true" tabindex="-1"></a>Each worker $w_j$ is assigned a confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$ such that $\pi^{(j)}_{k\ell} = \mathbb{P}(y_i^{(j)}=\ell\vert y_i^\star=k)$.</span>
<span id="cb25-193"><a href="#cb25-193" aria-hidden="true" tabindex="-1"></a>The model assumes that the probability for a task $x_i$ to have true label $y_i^\star=k$ follows a multinomial distribution with probabilities $\pi^{(j)}_{k,\bullet}$ for each worker.</span>
<span id="cb25-194"><a href="#cb25-194" aria-hidden="true" tabindex="-1"></a>Each class has a prevalence $\rho_k=\mathbb{P}(y_i^\star=k)$ to appear in the dataset.</span>
<span id="cb25-195"><a href="#cb25-195" aria-hidden="true" tabindex="-1"></a>Using the independence between workers, we obtain the following likelihood to maximize (using the EM algorithm):</span>
<span id="cb25-196"><a href="#cb25-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-197"><a href="#cb25-197" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-198"><a href="#cb25-198" aria-hidden="true" tabindex="-1"></a>\displaystyle\prod_{i\in <span class="co">[</span><span class="ot">n_{\texttt{task}}</span><span class="co">]</span>}\prod_{k \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\bigg<span class="co">[</span><span class="ot">\rho_k\prod_{j\in [n_{\texttt{worker}}</span><span class="co">]</span>}</span>
<span id="cb25-199"><a href="#cb25-199" aria-hidden="true" tabindex="-1"></a>    \prod_{k\in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\big(\pi^{(j)}_{k, k}\big)^{1_{<span class="sc">\{</span>y_i^{(j)}=k<span class="sc">\}</span>}}</span>
<span id="cb25-200"><a href="#cb25-200" aria-hidden="true" tabindex="-1"></a>    \bigg]^{T_{ik}},</span>
<span id="cb25-201"><a href="#cb25-201" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-202"><a href="#cb25-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-203"><a href="#cb25-203" aria-hidden="true" tabindex="-1"></a>with $T_{i,k}=1_{<span class="sc">\{</span>y_i^{\star}=k <span class="sc">\}</span>}$. The final aggregated soft label is $\hat y_i^{\text{DS}} = T_{i,\cdot}$.</span>
<span id="cb25-204"><a href="#cb25-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-205"><a href="#cb25-205" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for the DS model</span><span class="co">](./figures/bayesien_plaque_ds.png)</span>{fig-align="center"}</span>
<span id="cb25-206"><a href="#cb25-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-207"><a href="#cb25-207" aria-hidden="true" tabindex="-1"></a>Many variants of the DS model have been proposed in the literature, using Dirichlet priors on the confusion matrices <span class="co">[</span><span class="ot">@passonneau-carpenter-2014-benefits</span><span class="co">]</span>, using $L$ clusters of workers <span class="co">[</span><span class="ot">@imamura2018analysis</span><span class="co">]</span> with $1\leq L\leq n_{\text{worker}}$ (DSWC) or even faster implementation that produces only hard labels <span class="co">[</span><span class="ot">@sinha2018fast</span><span class="co">]</span>.</span>
<span id="cb25-208"><a href="#cb25-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-209"><a href="#cb25-209" aria-hidden="true" tabindex="-1"></a>Finally, we present the GLAD model <span class="co">[</span><span class="ot">@whitehill_whose_2009</span><span class="co">]</span> that not only takes into account the worker's ability, but also the task difficulty in the noise model.</span>
<span id="cb25-210"><a href="#cb25-210" aria-hidden="true" tabindex="-1"></a>Denoting $\alpha_j\in\mathbb{R}$ the worker ability (the higher the better) and $\beta_i\in\mathbb{R}^+_\star$ the task's difficulty (the higher the easier), the model noise is:</span>
<span id="cb25-211"><a href="#cb25-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-212"><a href="#cb25-212" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-213"><a href="#cb25-213" aria-hidden="true" tabindex="-1"></a>\mathbb{P}(y_i^{(j)}=y_i^\star\vert \alpha_j,\beta_i) = \frac{1}{1+\exp(-\alpha_j\beta_i)} \enspace.</span>
<span id="cb25-214"><a href="#cb25-214" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-215"><a href="#cb25-215" aria-hidden="true" tabindex="-1"></a>GLAD's model also assumes that the errors are uniform across wrong labels, thus:</span>
<span id="cb25-216"><a href="#cb25-216" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-217"><a href="#cb25-217" aria-hidden="true" tabindex="-1"></a>\forall k \in <span class="co">[</span><span class="ot">K</span><span class="co">]</span>,\ \mathbb{P}(y_i^{(j)}=k\vert y_i^\star\neq k,\alpha_j,\beta_i) = \frac{1}{K-1}\left(1-\frac{1}{1+\exp(-\alpha_j\beta_i)}\right)\enspace.</span>
<span id="cb25-218"><a href="#cb25-218" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-219"><a href="#cb25-219" aria-hidden="true" tabindex="-1"></a>The likelihood can then be optimized using an EM algorithm to recover the soft label $\hat y_i^{\text{GLAD}}$.</span>
<span id="cb25-220"><a href="#cb25-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-221"><a href="#cb25-221" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for the GLAD model</span><span class="co">](./figures/schema_bayesien_glad.png)</span>{fig-align="center"}</span>
<span id="cb25-222"><a href="#cb25-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-223"><a href="#cb25-223" aria-hidden="true" tabindex="-1"></a>All of these aggregation strategies -- and more -- are available in the <span class="in">`peerannot`</span> library from the <span class="in">`peerannot.models`</span> module.</span>
<span id="cb25-224"><a href="#cb25-224" aria-hidden="true" tabindex="-1"></a>Each model is a class object in its own <span class="in">`Python`</span> file. It inherits from the <span class="in">`CrowdModel`</span> template class and is defined with at least two methods:</span>
<span id="cb25-225"><a href="#cb25-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-226"><a href="#cb25-226" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`run`</span>: includes the optimization procedure to obtain needed weights (*e.g.* the EM algorithm for the DS model),</span>
<span id="cb25-227"><a href="#cb25-227" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`get_probas`</span>: returns the soft labels output for each task.</span>
<span id="cb25-228"><a href="#cb25-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-229"><a href="#cb25-229" aria-hidden="true" tabindex="-1"></a><span class="fu">## Experiments and evaluation of label aggregation strategies {#sec-evaluation-aggregation}</span></span>
<span id="cb25-230"><a href="#cb25-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-231"><a href="#cb25-231" aria-hidden="true" tabindex="-1"></a>One way to evaluate the label aggregation strategies is to measure their accuracy.</span>
<span id="cb25-232"><a href="#cb25-232" aria-hidden="true" tabindex="-1"></a>This means that the underlying ground truth must be known -- or at least for a representative subset.</span>
<span id="cb25-233"><a href="#cb25-233" aria-hidden="true" tabindex="-1"></a>As the set of $n_{\text{task}}$ can be seen as a training set for a future classifier, we denote this metric $\operatornamewithlimits{AccTrain}$ on a dataset $\mathcal{D}$ for a given aggregated label $(\hat y_i)_i$ as:</span>
<span id="cb25-234"><a href="#cb25-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-235"><a href="#cb25-235" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-236"><a href="#cb25-236" aria-hidden="true" tabindex="-1"></a>\operatornamewithlimits{AccTrain}(\mathcal{D}) = \frac{1}{\vert \mathcal{D}\vert}\sum_{i=1}^{\vert\mathcal{D}\vert} 1_{<span class="sc">\{</span>y_i^\star=\operatornamewithlimits{argmax}_{k\in<span class="co">[</span><span class="ot">K</span><span class="co">]</span>}\hat y_i<span class="sc">\}</span>} \enspace.</span>
<span id="cb25-237"><a href="#cb25-237" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-238"><a href="#cb25-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-239"><a href="#cb25-239" aria-hidden="true" tabindex="-1"></a>In the following, we write $\operatornamewithlimits{AccTrain}$ for $\operatornamewithlimits{AccTrain}(\mathcal{D}_{\text{train}})$ as we only consider the full training set so there is no ambiguity.</span>
<span id="cb25-240"><a href="#cb25-240" aria-hidden="true" tabindex="-1"></a>While this metric is useful, in practice there are a few arguable issues:</span>
<span id="cb25-241"><a href="#cb25-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-242"><a href="#cb25-242" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the $\operatornamewithlimits{AccTrain}$ does not consider the ambiguity of the soft label, only the most probable class, whereas in some contexts ambiguity can be informative,</span>
<span id="cb25-243"><a href="#cb25-243" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>in supervised learning one objective is to identify difficult or mislabeled tasks <span class="co">[</span><span class="ot">@pleiss_identifying_2020;@lefort2022improve</span><span class="co">]</span>, pruning those tasks can easily artificially improve the $\operatornamewithlimits{AccTrain}$, but there is no guarantee over the predictive performance of a model based on the newly pruned dataset.</span>
<span id="cb25-244"><a href="#cb25-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-245"><a href="#cb25-245" aria-hidden="true" tabindex="-1"></a>We first consider classical simulation settings in the literature that can easily be created and reproduced using <span class="in">`peerannot`</span>.</span>
<span id="cb25-246"><a href="#cb25-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-247"><a href="#cb25-247" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated independent mistakes</span></span>
<span id="cb25-248"><a href="#cb25-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-249"><a href="#cb25-249" aria-hidden="true" tabindex="-1"></a>The independent mistakes consider that each worker $w_j$ answers following a multinomial distribution with weights given at the row $y_i^\star$ of their confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$. Each confusion matrix is generated diagonally dominant.</span>
<span id="cb25-250"><a href="#cb25-250" aria-hidden="true" tabindex="-1"></a>Answers are independent of one another as each matrix is generated independently and each worker answers independently of other workers.</span>
<span id="cb25-251"><a href="#cb25-251" aria-hidden="true" tabindex="-1"></a>In this setting, the DS model is expected to perform the best with enough data as we are simulating data from its assumed noise model.</span>
<span id="cb25-252"><a href="#cb25-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-253"><a href="#cb25-253" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=200$ tasks and $n_{\text{worker}}=30$ workers with $K=5$ possible classes. Each task receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb25-254"><a href="#cb25-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-257"><a href="#cb25-257" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-258"><a href="#cb25-258" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-259"><a href="#cb25-259" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb25-260"><a href="#cb25-260" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy independent<span class="op">-</span>confusion <span class="op">\</span></span>
<span id="cb25-261"><a href="#cb25-261" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb25-262"><a href="#cb25-262" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>independent</span>
<span id="cb25-263"><a href="#cb25-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-264"><a href="#cb25-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-265"><a href="#cb25-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-268"><a href="#cb25-268" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-269"><a href="#cb25-269" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-270"><a href="#cb25-270" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> peerannot.helpers.helpers_visu <span class="im">import</span> feedback_effort, working_load</span>
<span id="cb25-271"><a href="#cb25-271" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb25-272"><a href="#cb25-272" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-273"><a href="#cb25-273" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> MaxNLocator</span>
<span id="cb25-274"><a href="#cb25-274" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb25-275"><a href="#cb25-275" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mtick</span>
<span id="cb25-276"><a href="#cb25-276" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">"whitegrid"</span>)</span>
<span id="cb25-277"><a href="#cb25-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-278"><a href="#cb25-278" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb25-279"><a href="#cb25-279" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"independent"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb25-280"><a href="#cb25-280" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-281"><a href="#cb25-281" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb25-282"><a href="#cb25-282" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-283"><a href="#cb25-283" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb25-284"><a href="#cb25-284" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb25-285"><a href="#cb25-285" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb25-286"><a href="#cb25-286" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-287"><a href="#cb25-287" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb25-288"><a href="#cb25-288" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb25-289"><a href="#cb25-289" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-290"><a href="#cb25-290" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb25-291"><a href="#cb25-291" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb25-292"><a href="#cb25-292" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb25-293"><a href="#cb25-293" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb25-294"><a href="#cb25-294" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-295"><a href="#cb25-295" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-296"><a href="#cb25-296" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-297"><a href="#cb25-297" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-298"><a href="#cb25-298" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb25-299"><a href="#cb25-299" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb25-300"><a href="#cb25-300" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-301"><a href="#cb25-301" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-302"><a href="#cb25-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-303"><a href="#cb25-303" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb25-304"><a href="#cb25-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-307"><a href="#cb25-307" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-308"><a href="#cb25-308" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-309"><a href="#cb25-309" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb25-310"><a href="#cb25-310" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>independent<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb25-311"><a href="#cb25-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-312"><a href="#cb25-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-315"><a href="#cb25-315" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-316"><a href="#cb25-316" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-independent</span></span>
<span id="cb25-317"><a href="#cb25-317" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated independent mistakes considering classical feature-blind label aggregation strategies</span></span>
<span id="cb25-318"><a href="#cb25-318" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-319"><a href="#cb25-319" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb25-320"><a href="#cb25-320" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-321"><a href="#cb25-321" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display</span>
<span id="cb25-322"><a href="#cb25-322" aria-hidden="true" tabindex="-1"></a>simu_indep <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"independent"</span></span>
<span id="cb25-323"><a href="#cb25-323" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb25-324"><a href="#cb25-324" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb25-325"><a href="#cb25-325" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_indep <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_independent-confusion_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb25-326"><a href="#cb25-326" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_indep <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb25-327"><a href="#cb25-327" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb25-328"><a href="#cb25-328" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb25-329"><a href="#cb25-329" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb25-330"><a href="#cb25-330" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb25-331"><a href="#cb25-331" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb25-332"><a href="#cb25-332" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-333"><a href="#cb25-333" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb25-334"><a href="#cb25-334" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb25-335"><a href="#cb25-335" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-336"><a href="#cb25-336" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb25-337"><a href="#cb25-337" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb25-338"><a href="#cb25-338" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb25-339"><a href="#cb25-339" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb25-340"><a href="#cb25-340" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb25-341"><a href="#cb25-341" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb25-342"><a href="#cb25-342" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb25-343"><a href="#cb25-343" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-344"><a href="#cb25-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-345"><a href="#cb25-345" aria-hidden="true" tabindex="-1"></a>As expected by the simulation framework, @tbl-simu-independent fits the DS model, thus leading to a better accuracy on the retrieval of the simulated label for the DS model. The MV aggregation doesn't consider any worker-ability scoring or the task's difficulty and performs the worse.</span>
<span id="cb25-346"><a href="#cb25-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-347"><a href="#cb25-347" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated correlated mistakes</span></span>
<span id="cb25-348"><a href="#cb25-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-349"><a href="#cb25-349" aria-hidden="true" tabindex="-1"></a>The correlated mistakes are also known as the student-teacher setting. Consider that the crowd of workers is divided into two categories: teachers and students such that $n_{\text{teacher}} + n_{\text{student}}=n_{\text{worker}}$. Each student is randomly assigned to one teacher at the beginning of the experiment. We generate the (diagonally dominant) confusion matrices of each teacher and the students are associated with their's teacher confusion matrix. Then, they all answer independently, following a multinomial distribution with weights given at the row $y_i^\star$ of their confusion matrix $\pi^{(j)}\in\mathbb{R}^{K\times K}$.</span>
<span id="cb25-350"><a href="#cb25-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-351"><a href="#cb25-351" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=200$ tasks and $n_{\text{worker}}=30$ with $80\%$ of students in the crowd. There are $K=5$ possible classes. Each task receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb25-352"><a href="#cb25-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-355"><a href="#cb25-355" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-356"><a href="#cb25-356" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-357"><a href="#cb25-357" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">30</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb25-358"><a href="#cb25-358" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy student<span class="op">-</span>teacher <span class="op">\</span></span>
<span id="cb25-359"><a href="#cb25-359" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.8</span> <span class="op">\</span></span>
<span id="cb25-360"><a href="#cb25-360" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback<span class="op">=</span><span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb25-361"><a href="#cb25-361" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>student_teacher</span>
<span id="cb25-362"><a href="#cb25-362" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-363"><a href="#cb25-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-364"><a href="#cb25-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-367"><a href="#cb25-367" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-368"><a href="#cb25-368" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-369"><a href="#cb25-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-370"><a href="#cb25-370" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb25-371"><a href="#cb25-371" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"student_teacher"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb25-372"><a href="#cb25-372" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-373"><a href="#cb25-373" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb25-374"><a href="#cb25-374" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-375"><a href="#cb25-375" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb25-376"><a href="#cb25-376" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb25-377"><a href="#cb25-377" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb25-378"><a href="#cb25-378" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-379"><a href="#cb25-379" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb25-380"><a href="#cb25-380" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb25-381"><a href="#cb25-381" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-382"><a href="#cb25-382" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb25-383"><a href="#cb25-383" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb25-384"><a href="#cb25-384" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb25-385"><a href="#cb25-385" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb25-386"><a href="#cb25-386" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-387"><a href="#cb25-387" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-388"><a href="#cb25-388" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-389"><a href="#cb25-389" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-390"><a href="#cb25-390" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb25-391"><a href="#cb25-391" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb25-392"><a href="#cb25-392" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-393"><a href="#cb25-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-394"><a href="#cb25-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-395"><a href="#cb25-395" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb25-396"><a href="#cb25-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-399"><a href="#cb25-399" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-400"><a href="#cb25-400" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-401"><a href="#cb25-401" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=5]"</span>, <span class="st">"DSWC[L=10]"</span>]:</span>
<span id="cb25-402"><a href="#cb25-402" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>student_teacher<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb25-403"><a href="#cb25-403" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-404"><a href="#cb25-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-407"><a href="#cb25-407" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-408"><a href="#cb25-408" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-corr</span></span>
<span id="cb25-409"><a href="#cb25-409" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated correlated mistakes considering classical feature-blind label aggregation strategies</span></span>
<span id="cb25-410"><a href="#cb25-410" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-411"><a href="#cb25-411" aria-hidden="true" tabindex="-1"></a>simu_corr <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">'simus'</span> <span class="op">/</span> <span class="st">"student_teacher"</span></span>
<span id="cb25-412"><a href="#cb25-412" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">"mv"</span>: [], <span class="st">"naivesoft"</span>: [], <span class="st">"glad"</span>: [], <span class="st">"ds"</span>: [], <span class="st">"dswc[l=5]"</span>: [], <span class="st">"dswc[l=10]"</span>: []}</span>
<span id="cb25-413"><a href="#cb25-413" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strategy <span class="kw">in</span> results.keys():</span>
<span id="cb25-414"><a href="#cb25-414" aria-hidden="true" tabindex="-1"></a>  path_labels <span class="op">=</span> simu_corr <span class="op">/</span> <span class="st">"labels"</span> <span class="op">/</span> <span class="ss">f"labels_student-teacher_</span><span class="sc">{</span>strategy<span class="sc">}</span><span class="ss">.npy"</span></span>
<span id="cb25-415"><a href="#cb25-415" aria-hidden="true" tabindex="-1"></a>  ground_truth <span class="op">=</span> np.load(simu_corr <span class="op">/</span> <span class="st">"ground_truth.npy"</span>)</span>
<span id="cb25-416"><a href="#cb25-416" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> np.load(path_labels)</span>
<span id="cb25-417"><a href="#cb25-417" aria-hidden="true" tabindex="-1"></a>  acc <span class="op">=</span> (</span>
<span id="cb25-418"><a href="#cb25-418" aria-hidden="true" tabindex="-1"></a>          np.mean(labels <span class="op">==</span> ground_truth)</span>
<span id="cb25-419"><a href="#cb25-419" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> labels.ndim <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb25-420"><a href="#cb25-420" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> np.mean(</span>
<span id="cb25-421"><a href="#cb25-421" aria-hidden="true" tabindex="-1"></a>              np.argmax(labels, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-422"><a href="#cb25-422" aria-hidden="true" tabindex="-1"></a>              <span class="op">==</span> ground_truth</span>
<span id="cb25-423"><a href="#cb25-423" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb25-424"><a href="#cb25-424" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-425"><a href="#cb25-425" aria-hidden="true" tabindex="-1"></a>  results[strategy].append(acc)</span>
<span id="cb25-426"><a href="#cb25-426" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results, index<span class="op">=</span>[<span class="st">'AccTrain'</span>])</span>
<span id="cb25-427"><a href="#cb25-427" aria-hidden="true" tabindex="-1"></a>results.columns <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, results.columns)</span>
<span id="cb25-428"><a href="#cb25-428" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.style.set_table_styles([<span class="bu">dict</span>(selector<span class="op">=</span><span class="st">'th'</span>, props<span class="op">=</span>[(<span class="st">'text-align'</span>, <span class="st">'center'</span>)])])</span>
<span id="cb25-429"><a href="#cb25-429" aria-hidden="true" tabindex="-1"></a>results.set_properties(<span class="op">**</span>{<span class="st">'text-align'</span>: <span class="st">'center'</span>})</span>
<span id="cb25-430"><a href="#cb25-430" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> results.<span class="bu">format</span>(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb25-431"><a href="#cb25-431" aria-hidden="true" tabindex="-1"></a>display(results)</span>
<span id="cb25-432"><a href="#cb25-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-433"><a href="#cb25-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-434"><a href="#cb25-434" aria-hidden="true" tabindex="-1"></a>With @tbl-simu-corr, we see that with correlated data ($24$ students and $6$ teachers), using $5$ confusion matrices with DSWC<span class="co">[</span><span class="ot">L=5</span><span class="co">]</span> outperforms the vanilla DS strategy that does not consider the correlations. And the best performing method here estimates $10$ different confusion matrices (insted of $30$ for the vanilla DS model).</span>
<span id="cb25-435"><a href="#cb25-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-436"><a href="#cb25-436" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated mistakes with discrete difficulty levels on tasks</span></span>
<span id="cb25-437"><a href="#cb25-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-438"><a href="#cb25-438" aria-hidden="true" tabindex="-1"></a>For the final simulation setting, we consider the discrete difficulty presented in @whitehill_whose_2009. Contrary to other simulations, we here consider that each worker is either good or bad and each task is either easy or hard. Easy tasks are answered without mistakes by involved workers. However, hard tasks are answered following the worker's confusion matrix. The confusion matrix $\pi^{(j)}$ is diagonally dominant for good workers while each row is drawn uniformly in the simplex $\Delta_K$ for bad workers.</span>
<span id="cb25-439"><a href="#cb25-439" aria-hidden="true" tabindex="-1"></a>Each worker then answers independently to the presented tasks.</span>
<span id="cb25-440"><a href="#cb25-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-441"><a href="#cb25-441" aria-hidden="true" tabindex="-1"></a>We simulate $n_{\text{task}}=500$ tasks and $n_{\text{worker}}=100$ with $35\%$ of good workers in the crowd and $50\%$ of easy tasks. There are $K=5$ possible classes. Each task receives $\vert\mathcal{A}(x_i)\vert=10$ labels.</span>
<span id="cb25-442"><a href="#cb25-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-445"><a href="#cb25-445" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-446"><a href="#cb25-446" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-447"><a href="#cb25-447" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot simulate <span class="op">--</span>n<span class="op">-</span>worker<span class="op">=</span><span class="dv">100</span> <span class="op">--</span>n<span class="op">-</span>task<span class="op">=</span><span class="dv">200</span>  <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">5</span> <span class="op">\</span></span>
<span id="cb25-448"><a href="#cb25-448" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>strategy discrete<span class="op">-</span>difficulty <span class="op">\</span></span>
<span id="cb25-449"><a href="#cb25-449" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>ratio <span class="fl">0.35</span> <span class="op">--</span>ratio<span class="op">-</span>diff <span class="dv">1</span> <span class="op">\</span></span>
<span id="cb25-450"><a href="#cb25-450" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>feedback <span class="dv">10</span> <span class="op">--</span>seed <span class="dv">0</span> <span class="op">\</span></span>
<span id="cb25-451"><a href="#cb25-451" aria-hidden="true" tabindex="-1"></a>                     <span class="op">--</span>folder .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty</span>
<span id="cb25-452"><a href="#cb25-452" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-453"><a href="#cb25-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-454"><a href="#cb25-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-457"><a href="#cb25-457" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-458"><a href="#cb25-458" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-459"><a href="#cb25-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-460"><a href="#cb25-460" aria-hidden="true" tabindex="-1"></a>votes_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"answers.json"</span></span>
<span id="cb25-461"><a href="#cb25-461" aria-hidden="true" tabindex="-1"></a>metadata_path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"simus"</span> <span class="op">/</span> <span class="st">"discrete_difficulty"</span> <span class="op">/</span> <span class="st">"metadata.json"</span></span>
<span id="cb25-462"><a href="#cb25-462" aria-hidden="true" tabindex="-1"></a>efforts <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-463"><a href="#cb25-463" aria-hidden="true" tabindex="-1"></a>workerload <span class="op">=</span> working_load(votes_path, metadata_path)</span>
<span id="cb25-464"><a href="#cb25-464" aria-hidden="true" tabindex="-1"></a>feedback <span class="op">=</span> feedback_effort(votes_path)</span>
<span id="cb25-465"><a href="#cb25-465" aria-hidden="true" tabindex="-1"></a>nbins <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb25-466"><a href="#cb25-466" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">4</span>))</span>
<span id="cb25-467"><a href="#cb25-467" aria-hidden="true" tabindex="-1"></a>sns.histplot(workerload, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb25-468"><a href="#cb25-468" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-469"><a href="#cb25-469" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{T}</span><span class="vs">(w_j)\vert$"</span>)</span>
<span id="cb25-470"><a href="#cb25-470" aria-hidden="true" tabindex="-1"></a>sns.histplot(feedback, stat<span class="op">=</span><span class="st">"percent"</span>, bins<span class="op">=</span>nbins, shrink<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb25-471"><a href="#cb25-471" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_major_formatter(mtick.PercentFormatter(decimals<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb25-472"><a href="#cb25-472" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\vert\mathcal</span><span class="sc">{A}</span><span class="vs">(x_i)\vert$"</span>)</span>
<span id="cb25-473"><a href="#cb25-473" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb25-474"><a href="#cb25-474" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_major_locator(MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb25-475"><a href="#cb25-475" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-476"><a href="#cb25-476" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.label.set_size(<span class="dv">15</span>)</span>
<span id="cb25-477"><a href="#cb25-477" aria-hidden="true" tabindex="-1"></a>  ax[i].xaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-478"><a href="#cb25-478" aria-hidden="true" tabindex="-1"></a>  ax[i].yaxis.set_tick_params(labelsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb25-479"><a href="#cb25-479" aria-hidden="true" tabindex="-1"></a>  ax[i].title.set_size(<span class="dv">18</span>)</span>
<span id="cb25-480"><a href="#cb25-480" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb25-481"><a href="#cb25-481" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-482"><a href="#cb25-482" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-483"><a href="#cb25-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-484"><a href="#cb25-484" aria-hidden="true" tabindex="-1"></a>With the obtained answers, we can look at the aforementioned aggregation strategies performance:</span>
<span id="cb25-485"><a href="#cb25-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-488"><a href="#cb25-488" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-489"><a href="#cb25-489" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-490"><a href="#cb25-490" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> strat <span class="kw">in</span> [<span class="st">"MV"</span>, <span class="st">"NaiveSoft"</span>, <span class="st">"DS"</span>, <span class="st">"GLAD"</span>, <span class="st">"DSWC[L=2]"</span>, <span class="st">"DSWC[L=5]"</span>]:</span>
<span id="cb25-491"><a href="#cb25-491" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot aggregate .<span class="op">/</span>simus<span class="op">/</span>discrete_difficulty<span class="op">/</span> <span class="op">-</span>s {strat}</span>
<span id="cb25-492"><a href="#cb25-492" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-493"><a href="#cb25-493" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- ```{python}</span></span>
<span id="cb25-494"><a href="#cb25-494" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-simu-discrete-diff</span></span>
<span id="cb25-495"><a href="#cb25-495" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: AccTrain metric on simulated mistakes when tasks are associated a difficulty level considering classical feature-blind label aggregation strategies</span></span>
<span id="cb25-496"><a href="#cb25-496" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-497"><a href="#cb25-497" aria-hidden="true" tabindex="-1"></a><span class="co">simu_corr = Path.cwd() / 'simus' / "discrete_difficulty"</span></span>
<span id="cb25-498"><a href="#cb25-498" aria-hidden="true" tabindex="-1"></a><span class="co">results = {"mv": [], "naivesoft": [], "glad": [], "ds": [], "dswc[l=2]": [], "dswc[l=5]": []}</span></span>
<span id="cb25-499"><a href="#cb25-499" aria-hidden="true" tabindex="-1"></a><span class="co">for strategy in results.keys():</span></span>
<span id="cb25-500"><a href="#cb25-500" aria-hidden="true" tabindex="-1"></a><span class="co">  path_labels = simu_corr / "labels" / f"labels_discrete-difficulty_{strategy}.npy"</span></span>
<span id="cb25-501"><a href="#cb25-501" aria-hidden="true" tabindex="-1"></a><span class="co">  ground_truth = np.load(simu_corr / "ground_truth.npy")</span></span>
<span id="cb25-502"><a href="#cb25-502" aria-hidden="true" tabindex="-1"></a><span class="co">  labels = np.load(path_labels)</span></span>
<span id="cb25-503"><a href="#cb25-503" aria-hidden="true" tabindex="-1"></a><span class="co">  acc = (</span></span>
<span id="cb25-504"><a href="#cb25-504" aria-hidden="true" tabindex="-1"></a><span class="co">          np.mean(labels == ground_truth)</span></span>
<span id="cb25-505"><a href="#cb25-505" aria-hidden="true" tabindex="-1"></a><span class="co">          if labels.ndim == 1</span></span>
<span id="cb25-506"><a href="#cb25-506" aria-hidden="true" tabindex="-1"></a><span class="co">          else np.mean(</span></span>
<span id="cb25-507"><a href="#cb25-507" aria-hidden="true" tabindex="-1"></a><span class="co">              np.argmax(labels, axis=1)</span></span>
<span id="cb25-508"><a href="#cb25-508" aria-hidden="true" tabindex="-1"></a><span class="co">              == ground_truth</span></span>
<span id="cb25-509"><a href="#cb25-509" aria-hidden="true" tabindex="-1"></a><span class="co">          )</span></span>
<span id="cb25-510"><a href="#cb25-510" aria-hidden="true" tabindex="-1"></a><span class="co">        )</span></span>
<span id="cb25-511"><a href="#cb25-511" aria-hidden="true" tabindex="-1"></a><span class="co">  results[strategy].append(acc)</span></span>
<span id="cb25-512"><a href="#cb25-512" aria-hidden="true" tabindex="-1"></a><span class="co">results = pd.DataFrame(results, index=['AccTrain'])</span></span>
<span id="cb25-513"><a href="#cb25-513" aria-hidden="true" tabindex="-1"></a><span class="co">results.columns = map(str.upper, results.columns)</span></span>
<span id="cb25-514"><a href="#cb25-514" aria-hidden="true" tabindex="-1"></a><span class="co">results = results.style.set_table_styles([dict(selector='th', props=[('text-align', 'center')])])</span></span>
<span id="cb25-515"><a href="#cb25-515" aria-hidden="true" tabindex="-1"></a><span class="co">results.set_properties(**{'text-align': 'center'})</span></span>
<span id="cb25-516"><a href="#cb25-516" aria-hidden="true" tabindex="-1"></a><span class="co">results = results.format(precision=3)</span></span>
<span id="cb25-517"><a href="#cb25-517" aria-hidden="true" tabindex="-1"></a><span class="co">display(results)</span></span>
<span id="cb25-518"><a href="#cb25-518" aria-hidden="true" tabindex="-1"></a><span class="co">``` --&gt;</span></span>
<span id="cb25-519"><a href="#cb25-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-520"><a href="#cb25-520" aria-hidden="true" tabindex="-1"></a>Finally, in this setting involving task diffulty coefficients, the only strategy that involves a latent variable for the task difficulty, knowing GLAD, outperforms the other other strategies (see @tbl-simu-discrete-diff). Note that in this case, creating clusters of answers leads to worse decisions than a MV aggregation.</span>
<span id="cb25-521"><a href="#cb25-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-522"><a href="#cb25-522" aria-hidden="true" tabindex="-1"></a>To summurize our simulations, we see that depending on workers answering strategies, different latent variable models perform best.</span>
<span id="cb25-523"><a href="#cb25-523" aria-hidden="true" tabindex="-1"></a>However, these are unknown outside of a simulation framework, thus if we want to obtain labels from multiple responses, we need to investigate multiple models.</span>
<span id="cb25-524"><a href="#cb25-524" aria-hidden="true" tabindex="-1"></a>This can be done easily with <span class="in">`peerannot`</span> as we demonstrated using the <span class="in">`aggregate`</span> module.</span>
<span id="cb25-525"><a href="#cb25-525" aria-hidden="true" tabindex="-1"></a>However, one might not want to generate a label, simply learn a classifier to predict labels on unseen data. This leads us to another module part of <span class="in">`peerannot`</span>.</span>
<span id="cb25-526"><a href="#cb25-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-527"><a href="#cb25-527" aria-hidden="true" tabindex="-1"></a><span class="fu"># Learning from crowdsourced tasks</span></span>
<span id="cb25-528"><a href="#cb25-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-529"><a href="#cb25-529" aria-hidden="true" tabindex="-1"></a>Most often, tasks are crowdsourced to create a large training set as modern machine learning models require more and more data.</span>
<span id="cb25-530"><a href="#cb25-530" aria-hidden="true" tabindex="-1"></a>The aggregation step then simply becomes the first step in the complete learning pipeline.</span>
<span id="cb25-531"><a href="#cb25-531" aria-hidden="true" tabindex="-1"></a>However, instead of aggregating labels, modern neural networks let us directly train a classifier from multiple noisy labels.</span>
<span id="cb25-532"><a href="#cb25-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-533"><a href="#cb25-533" aria-hidden="true" tabindex="-1"></a><span class="fu">## Classical models</span></span>
<span id="cb25-534"><a href="#cb25-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-535"><a href="#cb25-535" aria-hidden="true" tabindex="-1"></a>In recent years, directly learning a classifier from noisy labels was introduced.</span>
<span id="cb25-536"><a href="#cb25-536" aria-hidden="true" tabindex="-1"></a>Two of the most used models: CrowdLayer <span class="co">[</span><span class="ot">@rodrigues2018deep</span><span class="co">]</span> and CoNAL <span class="co">[</span><span class="ot">@chu2021learning</span><span class="co">]</span>, are directly available in <span class="in">`peerannot`</span>.</span>
<span id="cb25-537"><a href="#cb25-537" aria-hidden="true" tabindex="-1"></a>These two learning strategies directly incorporate a DS-based noise model in the neural network's architecture.</span>
<span id="cb25-538"><a href="#cb25-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-539"><a href="#cb25-539" aria-hidden="true" tabindex="-1"></a>CrowdLayer trains a classifier with noisy labels as follows.</span>
<span id="cb25-540"><a href="#cb25-540" aria-hidden="true" tabindex="-1"></a>Let the scores (logits) output of a given classifier neural network $\mathcal{C}$ be $z_i=\mathcal{C}(x_i)$.</span>
<span id="cb25-541"><a href="#cb25-541" aria-hidden="true" tabindex="-1"></a>Then CrowdLayer adds a new layer $\pi\in\mathbb{R}^{n_{\text{worker}}\times K\times K}$, the tensor of all $\pi^{(j)}$s such that the crossentropy loss $(\mathrm{CE})$ is adapted to the crowdsourcing setting into $\mathcal{L}_{CE}^{\text{CrowdLayer}}$ and computed as:</span>
<span id="cb25-542"><a href="#cb25-542" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-543"><a href="#cb25-543" aria-hidden="true" tabindex="-1"></a>\mathcal{L}_{CE}^{\text{CrowdLayer}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(\sigma\left(\pi^{(j)}\sigma\big(z_i\big)\right), y_i^{(j)}) \enspace.</span>
<span id="cb25-544"><a href="#cb25-544" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-545"><a href="#cb25-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-546"><a href="#cb25-546" aria-hidden="true" tabindex="-1"></a>The confusion matrices are incorporated as is into the network architecture as a new layer to transform the output probabilities to match each worker's answer.</span>
<span id="cb25-547"><a href="#cb25-547" aria-hidden="true" tabindex="-1"></a>However, for some datasets, it was noticed that global confusion occurs between the proposed classes.</span>
<span id="cb25-548"><a href="#cb25-548" aria-hidden="true" tabindex="-1"></a>It is the case for example in the LabelMe dataset <span class="co">[</span><span class="ot">@rodrigues2017learning</span><span class="co">]</span> where classes overlap.</span>
<span id="cb25-549"><a href="#cb25-549" aria-hidden="true" tabindex="-1"></a>In this case, @chu2021learning proposed to extend the CrowdLayer model by not only modeling the worker confusion matrices; but also a global confusion matrix $\pi^g\in\mathbb{R}^{K\times K}$.</span>
<span id="cb25-550"><a href="#cb25-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-551"><a href="#cb25-551" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Bayesian [plate notation](https://en.wikipedia.org/wiki/Plate_notation) for CoNAL model. Each worker is assigned a confusion matrix $\pi^{(j)}$. A global confusion matrix $\pi^g$ is shared between workers. A tradeoff between the global confusion and the local one is applied.</span><span class="co">](./figures/schema_bayesien_conal.png)</span>{#fig-conal fig-align="center"}</span>
<span id="cb25-552"><a href="#cb25-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-553"><a href="#cb25-553" aria-hidden="true" tabindex="-1"></a>Given the output $z_i=\mathcal{C}(x_i)\in\mathbb{R}^K$ of a given classifier and task, CoNAL</span>
<span id="cb25-554"><a href="#cb25-554" aria-hidden="true" tabindex="-1"></a>interpolates between the local confusion $\pi^{(j)}\sigma(z_i)$ and the global one $\pi^g\sigma(z_i)$.</span>
<span id="cb25-555"><a href="#cb25-555" aria-hidden="true" tabindex="-1"></a>The loss function is computed as follows:</span>
<span id="cb25-556"><a href="#cb25-556" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-557"><a href="#cb25-557" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb25-558"><a href="#cb25-558" aria-hidden="true" tabindex="-1"></a>&amp;\mathcal{L}_{CE}^{\text{CoNAL}}(x_i) = \sum_{j\in\mathcal{A}(x_i)} \mathrm{CE}(h_i^{(j)}, y_i^{(j)}) \enspace, <span class="sc">\\</span></span>
<span id="cb25-559"><a href="#cb25-559" aria-hidden="true" tabindex="-1"></a>&amp;\text{with } h_i^{(j)} = \sigma\left(\big(\omega_i^{(j)} \pi^g + (1-\omega_i^{(j)})\pi^{(j)}\big)z_i\right) \enspace.</span>
<span id="cb25-560"><a href="#cb25-560" aria-hidden="true" tabindex="-1"></a>\end{aligned} \</span>
<span id="cb25-561"><a href="#cb25-561" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb25-562"><a href="#cb25-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-563"><a href="#cb25-563" aria-hidden="true" tabindex="-1"></a>The interpolation weight is defined as $s_i^{(j)}\sim\mathcal{B}(w_i^{(j)})$ and is unobservable in practice.</span>
<span id="cb25-564"><a href="#cb25-564" aria-hidden="true" tabindex="-1"></a>So, to compute $h_i^{(j)}$, the weight is obtained through an auxiliary network that projects the task $x_i$ onto $v_i$ and the worker $w_j$ onto $u_j$, two vectors in an embedding space of dimension $d\geq 1$. Finally, $w_i^{(j)}=(1+\exp(- u_j^\top v_i))^{-1}$.</span>
<span id="cb25-565"><a href="#cb25-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-566"><a href="#cb25-566" aria-hidden="true" tabindex="-1"></a>Both CrowdLayer and CoNAL model worker confusions directly in the classifier's weights to learn from the noisy collected labels and are available in <span class="in">`peerannot`</span> as we will see in the following.</span>
<span id="cb25-567"><a href="#cb25-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-568"><a href="#cb25-568" aria-hidden="true" tabindex="-1"></a><span class="fu">## Prediction error when learning from crowdsourced tasks</span></span>
<span id="cb25-569"><a href="#cb25-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-570"><a href="#cb25-570" aria-hidden="true" tabindex="-1"></a>The $\mathrm{AccTrain}$ metric presented in @sec-evaluation-aggregation might no longer be of interest when training a classifier. Classical error measurements involve a test dataset to estimate the generalization error.</span>
<span id="cb25-571"><a href="#cb25-571" aria-hidden="true" tabindex="-1"></a>To do so, we present hereafter two error metrics. Assuming we trained our classifier $f_\theta$ on a training set:</span>
<span id="cb25-572"><a href="#cb25-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-573"><a href="#cb25-573" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the test accuracy is computed as $\frac{1}{n_{\text{test}}}\sum_{i=1}^{n_{\text{test}}}1_{\{y_i^\star = \widehat{f_\theta(x_i)}<span class="sc">\}</span>}$</span>
<span id="cb25-574"><a href="#cb25-574" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the expected calibration error <span class="co">[</span><span class="ot">@guo_calibration_2017</span><span class="co">]</span> over $M$ equally spaced bins $I_1,\dots,I_M$, computed as:</span>
<span id="cb25-575"><a href="#cb25-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-576"><a href="#cb25-576" aria-hidden="true" tabindex="-1"></a>  $$</span>
<span id="cb25-577"><a href="#cb25-577" aria-hidden="true" tabindex="-1"></a>\mathrm{ECE} = \sum_{m=1}^M \frac{|B_m|}{n_{\text{task}}}|\mathrm{acc}(B_m)</span>
<span id="cb25-578"><a href="#cb25-578" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>\mathrm{conf}(B_m)|\enspace,</span>
<span id="cb25-579"><a href="#cb25-579" aria-hidden="true" tabindex="-1"></a> $$</span>
<span id="cb25-580"><a href="#cb25-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-581"><a href="#cb25-581" aria-hidden="true" tabindex="-1"></a>with $B_m=<span class="sc">\{</span>x_i| \mathcal{C}(x_i)_{<span class="co">[</span><span class="ot">1</span><span class="co">]</span>}\in I_m<span class="sc">\}</span>$ the tasks with predicted probability in the $m$-th bin, $\mathrm{acc}(B_m)$ the accuracy of the network for the samples in $B_m$ and $\mathrm{conf}(B_m)$ the associated empirical confidence.</span>
<span id="cb25-582"><a href="#cb25-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-583"><a href="#cb25-583" aria-hidden="true" tabindex="-1"></a>The accuracy represents how well the classifier generalizes, the expected calibration error (ECE) quantifies the deviation between the accuracy and the confidence of the classifier. Modern neural networks are known to often be overconfident in their predictions <span class="co">[</span><span class="ot">@guo_calibration_2017</span><span class="co">]</span>. However, it has also been remarked that training on crowdsourced data, depending on the strategy, mitigates this confidence issue. That is why we propose to compare them both in our coming experiments.</span>
<span id="cb25-584"><a href="#cb25-584" aria-hidden="true" tabindex="-1"></a>Note that the ECE error estimator is known to be biased <span class="co">[</span><span class="ot">@gruber2022better</span><span class="co">]</span>.</span>
<span id="cb25-585"><a href="#cb25-585" aria-hidden="true" tabindex="-1"></a>Smaller training sets are known to have a higher ECE estimation error.</span>
<span id="cb25-586"><a href="#cb25-586" aria-hidden="true" tabindex="-1"></a>And in the crowdsourcing setting, openly available datasets are often quite small.</span>
<span id="cb25-587"><a href="#cb25-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-588"><a href="#cb25-588" aria-hidden="true" tabindex="-1"></a><span class="fu">## Use case with `peerannot` on real datasets</span></span>
<span id="cb25-589"><a href="#cb25-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-590"><a href="#cb25-590" aria-hidden="true" tabindex="-1"></a>Few real crowdsourcing experiments have been released publicly.</span>
<span id="cb25-591"><a href="#cb25-591" aria-hidden="true" tabindex="-1"></a>Among the available ones, CIFAR-10H <span class="co">[</span><span class="ot">@peterson_human_2019</span><span class="co">]</span> is one of the largest with $10 000$ tasks labeled by workers (the testing set of CIFAR-10).</span>
<span id="cb25-592"><a href="#cb25-592" aria-hidden="true" tabindex="-1"></a>The issue with CIFAR-10H is that there are little to no disagreements and a simple majority voting leads to a near-perfect $\mathrm{AccTrain}$ error.</span>
<span id="cb25-593"><a href="#cb25-593" aria-hidden="true" tabindex="-1"></a>While with this dataset, because of the lack of disagreements and data curation <span class="co">[</span><span class="ot">@peterson_human_2019;@aitchison2020statistical</span><span class="co">]</span> comparing the impact of aggregation and end-to-end strategies might not be relevant, it is however a good benchmark for task difficulty identification and worker evaluation scoring</span>
<span id="cb25-594"><a href="#cb25-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-595"><a href="#cb25-595" aria-hidden="true" tabindex="-1"></a>The LabelMe dataset was extracted from crowdsourcing segmentation experimentation and a subset of $K=8$ classes was released in @rodrigues2017learning.</span>
<span id="cb25-596"><a href="#cb25-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-597"><a href="#cb25-597" aria-hidden="true" tabindex="-1"></a>To install these datasets, we run the <span class="in">`install`</span> command from <span class="in">`peerannot`</span>:</span>
<span id="cb25-600"><a href="#cb25-600" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-601"><a href="#cb25-601" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-602"><a href="#cb25-602" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb25-603"><a href="#cb25-603" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>labelme.py</span>
<span id="cb25-604"><a href="#cb25-604" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot install .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>cifar10h.py</span>
<span id="cb25-605"><a href="#cb25-605" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-606"><a href="#cb25-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-607"><a href="#cb25-607" aria-hidden="true" tabindex="-1"></a>Let us use <span class="in">`peerannot`</span> to train a Resnet34 on the LabelMe dataset for:</span>
<span id="cb25-608"><a href="#cb25-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-609"><a href="#cb25-609" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>aggregation strategies: MV, NS, DS, GLAD,</span>
<span id="cb25-610"><a href="#cb25-610" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>end-to-end strategies: CrowdLayer and CoNAL.</span>
<span id="cb25-611"><a href="#cb25-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-612"><a href="#cb25-612" aria-hidden="true" tabindex="-1"></a>As we can see, CoNAL strategy performs best.</span>
<span id="cb25-613"><a href="#cb25-613" aria-hidden="true" tabindex="-1"></a>In this case, it is expected behavior as CoNAL was created for the LabelMe dataset.</span>
<span id="cb25-614"><a href="#cb25-614" aria-hidden="true" tabindex="-1"></a>However, using <span class="in">`peerannot`</span> we can look into **why modeling common confusion returns better results with this dataset**.</span>
<span id="cb25-615"><a href="#cb25-615" aria-hidden="true" tabindex="-1"></a>To do so, we can explore the datasets from two points of view: worker-wise or task-wise.</span>
<span id="cb25-616"><a href="#cb25-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-617"><a href="#cb25-617" aria-hidden="true" tabindex="-1"></a><span class="fu"># Exploring crowdsourced datasets</span></span>
<span id="cb25-618"><a href="#cb25-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-619"><a href="#cb25-619" aria-hidden="true" tabindex="-1"></a>If a dataset requires citizen knowledge to be labeled, it is because expert knowledge is long and costly to obtain. In the era of big data, where datasets are built using web scraping (or using a platform like <span class="co">[</span><span class="ot">Amazon Mechanical Turk</span><span class="co">](https://www.mturk.com/)</span>), citizen science is popular as it is an easy way to produce many labels.</span>
<span id="cb25-620"><a href="#cb25-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-621"><a href="#cb25-621" aria-hidden="true" tabindex="-1"></a>However, mistakes and confusions happen during these experiments.</span>
<span id="cb25-622"><a href="#cb25-622" aria-hidden="true" tabindex="-1"></a>Sometimes involuntarily (*e.g.* because the task is too hard or the worker is unable to differentiate between two classes) and sometimes not (*e.g.* the worker is a spammer).</span>
<span id="cb25-623"><a href="#cb25-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-624"><a href="#cb25-624" aria-hidden="true" tabindex="-1"></a>Underlying all the learning models and aggregation strategies, the cornerstone of crowdsourcing is evaluating the trust we put in each worker depending on the presented task. And with the gamification of crowdsourcing <span class="co">[</span><span class="ot">@plantgame2016;@tinati2017investigation</span><span class="co">]</span>, it has become essential to find scoring metrics both for workers and tasks to keep citizens in the loop so to speak.</span>
<span id="cb25-625"><a href="#cb25-625" aria-hidden="true" tabindex="-1"></a>This is the purpose of the identification module in <span class="in">`peerannot`</span></span>
<span id="cb25-626"><a href="#cb25-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-627"><a href="#cb25-627" aria-hidden="true" tabindex="-1"></a>Our test cases are both the CIFAR-10H dataset and the LabelMe dataset to compare the worker and task evaluation depending on the number of votes collected.</span>
<span id="cb25-628"><a href="#cb25-628" aria-hidden="true" tabindex="-1"></a>Indeed, the LabelMe dataset has only up to three votes per task whereas CIFAR-10H accounts for nearly fifty votes per task.</span>
<span id="cb25-629"><a href="#cb25-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-630"><a href="#cb25-630" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring tasks' difficulty</span></span>
<span id="cb25-631"><a href="#cb25-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-632"><a href="#cb25-632" aria-hidden="true" tabindex="-1"></a>To explore the tasks' intrinsic difficulty, we propose to compare three scoring metrics:</span>
<span id="cb25-633"><a href="#cb25-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-634"><a href="#cb25-634" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the entropy of the NS distribution: reliable with a big enough and not adversarial crowd, the entropy measures the inherent uncertainty of the distribution to the possible outcomes.</span>
<span id="cb25-635"><a href="#cb25-635" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>GLAD's scoring: by construction, @whitehill_whose_2009 introduced a scalar coefficient to score the difficulty of a task $\beta_i&gt;0$.</span>
<span id="cb25-636"><a href="#cb25-636" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>the WAUM: introduced in <span class="co">[</span><span class="ot">@lefort2022improve</span><span class="co">]</span>, this weighted area under the margins indicates how difficult it is for a model to classify the task given the crowdsourced labels and the trust we have in each worker.</span>
<span id="cb25-637"><a href="#cb25-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-638"><a href="#cb25-638" aria-hidden="true" tabindex="-1"></a>Note that each of these statistics is useful in its context. The entropy can not be used in a setting with $|\mathcal{A}(x_i)|$ low (few labels per task), in particular for the LabelMe dataset it is not informative. The WAUM can work with any number of labels, but the larger the better. However, as it uses a deep learning classifier, the WAUM needs the tasks $(x_i)_i$ in addition to the proposed labels while the other strategies are feature-blind.</span>
<span id="cb25-639"><a href="#cb25-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-640"><a href="#cb25-640" aria-hidden="true" tabindex="-1"></a><span class="fu">### CIFAR-1OH dataset</span></span>
<span id="cb25-641"><a href="#cb25-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-642"><a href="#cb25-642" aria-hidden="true" tabindex="-1"></a>First, let us consider a dataset with a large number of tasks, annotations and workers: the CIFAR-10H dataset by @peterson_human_2019.</span>
<span id="cb25-643"><a href="#cb25-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-646"><a href="#cb25-646" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-647"><a href="#cb25-647" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-648"><a href="#cb25-648" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Example of images to label from the CIFAR-10H dataset with label `bird`, `car`, `cat`, `deer `and `dog` (top to bottom) by row.</span></span>
<span id="cb25-649"><a href="#cb25-649" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb25-650"><a href="#cb25-650" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-651"><a href="#cb25-651" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb25-652"><a href="#cb25-652" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb25-653"><a href="#cb25-653" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb25-654"><a href="#cb25-654" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb25-655"><a href="#cb25-655" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb25-656"><a href="#cb25-656" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb25-657"><a href="#cb25-657" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb25-658"><a href="#cb25-658" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb25-659"><a href="#cb25-659" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb25-660"><a href="#cb25-660" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb25-661"><a href="#cb25-661" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-662"><a href="#cb25-662" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"bird"</span>, <span class="dv">1</span>: <span class="st">"car"</span>, <span class="dv">2</span>: <span class="st">"cat"</span>, <span class="dv">3</span>: <span class="st">"deer"</span>, <span class="dv">4</span>: <span class="st">"dog"</span>, <span class="dv">5</span>: <span class="st">"frog"</span>, <span class="dv">6</span>: <span class="st">"horse"</span>, <span class="dv">7</span>: <span class="st">"plane"</span>, <span class="dv">8</span>: <span class="st">"ship"</span>, <span class="dv">9</span>: <span class="st">"truck"</span>}</span>
<span id="cb25-663"><a href="#cb25-663" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb25-664"><a href="#cb25-664" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb25-665"><a href="#cb25-665" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb25-666"><a href="#cb25-666" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb25-667"><a href="#cb25-667" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb25-668"><a href="#cb25-668" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb25-669"><a href="#cb25-669" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb25-670"><a href="#cb25-670" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb25-671"><a href="#cb25-671" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb25-672"><a href="#cb25-672" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.95</span>, wspace<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb25-673"><a href="#cb25-673" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-674"><a href="#cb25-674" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-675"><a href="#cb25-675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-676"><a href="#cb25-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-679"><a href="#cb25-679" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-680"><a href="#cb25-680" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-681"><a href="#cb25-681" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb25-682"><a href="#cb25-682" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb25-683"><a href="#cb25-683" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb25-684"><a href="#cb25-684" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-687"><a href="#cb25-687" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-688"><a href="#cb25-688" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-689"><a href="#cb25-689" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-difficulty-c10H</span></span>
<span id="cb25-690"><a href="#cb25-690" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of metrics scoring the task's intrinsic difficulty in CIFAR-10H dataset.</span></span>
<span id="cb25-691"><a href="#cb25-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-692"><a href="#cb25-692" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> pearsonr</span>
<span id="cb25-693"><a href="#cb25-693" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> corrfunc(x, y, ax<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kws):</span>
<span id="cb25-694"><a href="#cb25-694" aria-hidden="true" tabindex="-1"></a>    r, _ <span class="op">=</span> pearsonr(x, y)</span>
<span id="cb25-695"><a href="#cb25-695" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="kw">or</span> plt.gca()</span>
<span id="cb25-696"><a href="#cb25-696" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">rf'$\rho$ = </span><span class="sc">{</span>r<span class="sc">:.2f}</span><span class="vs">'</span>, xy<span class="op">=</span>(<span class="fl">.1</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span>ax.transAxes)</span>
<span id="cb25-697"><a href="#cb25-697" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">'glad'</span>: [], <span class="st">"entropy"</span>: []}</span>
<span id="cb25-698"><a href="#cb25-698" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span> <span class="op">/</span> <span class="st">"identification"</span></span>
<span id="cb25-699"><a href="#cb25-699" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"entropy"</span>] <span class="op">=</span> np.load(path <span class="op">/</span> <span class="st">'entropies.npy'</span>)</span>
<span id="cb25-700"><a href="#cb25-700" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"glad"</span>] <span class="op">=</span> np.exp(np.load(path <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"difficulties.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb25-701"><a href="#cb25-701" aria-hidden="true" tabindex="-1"></a><span class="co"># results["waum"] = pd.read_csv(path / "resnet34" / "waum_0.01_yang" / 'waum.csv')["waum"].values</span></span>
<span id="cb25-702"><a href="#cb25-702" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results)</span>
<span id="cb25-703"><a href="#cb25-703" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb25-704"><a href="#cb25-704" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb25-705"><a href="#cb25-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-706"><a href="#cb25-706" aria-hidden="true" tabindex="-1"></a><span class="co"># axes = g.axes.flatten()</span></span>
<span id="cb25-707"><a href="#cb25-707" aria-hidden="true" tabindex="-1"></a><span class="co"># for i, ax in enumerate(axes):</span></span>
<span id="cb25-708"><a href="#cb25-708" aria-hidden="true" tabindex="-1"></a><span class="co">#   if i % len(results) == 0:</span></span>
<span id="cb25-709"><a href="#cb25-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-710"><a href="#cb25-710" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-711"><a href="#cb25-711" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-712"><a href="#cb25-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-713"><a href="#cb25-713" aria-hidden="true" tabindex="-1"></a><span class="fu">### LabelMe dataset</span></span>
<span id="cb25-714"><a href="#cb25-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-715"><a href="#cb25-715" aria-hidden="true" tabindex="-1"></a>As for the LabelMe dataset, one difficulty in evaluating tasks' intrinsic difficulty is that there are up to three votes given per task.</span>
<span id="cb25-716"><a href="#cb25-716" aria-hidden="true" tabindex="-1"></a>Hence, the entropy in the distribution of the votes is no longer a reliable metric, and we need to rely on other models.</span>
<span id="cb25-717"><a href="#cb25-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-720"><a href="#cb25-720" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-721"><a href="#cb25-721" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-722"><a href="#cb25-722" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Example of images to label from the LabelMe dataset with label `coast`, `forest`, `highway`, `insidecity `and `mountain` (top to bottom) by row.</span></span>
<span id="cb25-723"><a href="#cb25-723" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb25-724"><a href="#cb25-724" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb25-725"><a href="#cb25-725" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb25-726"><a href="#cb25-726" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb25-727"><a href="#cb25-727" aria-hidden="true" tabindex="-1"></a>nrow <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb25-728"><a href="#cb25-728" aria-hidden="true" tabindex="-1"></a>ncol <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb25-729"><a href="#cb25-729" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(</span>
<span id="cb25-730"><a href="#cb25-730" aria-hidden="true" tabindex="-1"></a>        nrow,</span>
<span id="cb25-731"><a href="#cb25-731" aria-hidden="true" tabindex="-1"></a>        ncol,</span>
<span id="cb25-732"><a href="#cb25-732" aria-hidden="true" tabindex="-1"></a>        sharey<span class="op">=</span><span class="st">"row"</span>,</span>
<span id="cb25-733"><a href="#cb25-733" aria-hidden="true" tabindex="-1"></a>        sharex<span class="op">=</span><span class="st">"col"</span>,</span>
<span id="cb25-734"><a href="#cb25-734" aria-hidden="true" tabindex="-1"></a>        figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">8</span>)</span>
<span id="cb25-735"><a href="#cb25-735" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-736"><a href="#cb25-736" aria-hidden="true" tabindex="-1"></a>match_ <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"coast"</span>, <span class="dv">1</span>: <span class="st">"forest"</span>, <span class="dv">2</span>: <span class="st">"highway"</span>, <span class="dv">3</span>: <span class="st">"insidecity"</span>, <span class="dv">4</span>: <span class="st">"mountain"</span>, <span class="dv">5</span>: <span class="st">"opencountry"</span>, <span class="dv">6</span>: <span class="st">"street"</span>, <span class="dv">7</span>: <span class="st">"tallbuilding"</span>}</span>
<span id="cb25-737"><a href="#cb25-737" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"train"</span></span>
<span id="cb25-738"><a href="#cb25-738" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nrow):</span>
<span id="cb25-739"><a href="#cb25-739" aria-hidden="true" tabindex="-1"></a>  img_folder <span class="op">=</span> path <span class="op">/</span> <span class="ss">f"</span><span class="sc">{</span>match_[i]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb25-740"><a href="#cb25-740" aria-hidden="true" tabindex="-1"></a>  all_imgs <span class="op">=</span> <span class="bu">list</span>(img_folder.glob(<span class="st">"*"</span>))[:ncol]</span>
<span id="cb25-741"><a href="#cb25-741" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ncol):</span>
<span id="cb25-742"><a href="#cb25-742" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.asarray(Image.<span class="bu">open</span>(path <span class="op">/</span> all_imgs[j]))</span>
<span id="cb25-743"><a href="#cb25-743" aria-hidden="true" tabindex="-1"></a>    axs[i,j].imshow(image, aspect<span class="op">=</span><span class="st">"equal"</span>)</span>
<span id="cb25-744"><a href="#cb25-744" aria-hidden="true" tabindex="-1"></a>    axs[i,j].axis(<span class="st">"off"</span>)</span>
<span id="cb25-745"><a href="#cb25-745" aria-hidden="true" tabindex="-1"></a>    axs[i,j].set_yticklabels([])</span>
<span id="cb25-746"><a href="#cb25-746" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(left<span class="op">=</span><span class="fl">0.05</span>, bottom<span class="op">=</span><span class="fl">0.05</span>, right<span class="op">=</span><span class="fl">0.95</span>, top<span class="op">=</span><span class="fl">0.95</span>, wspace<span class="op">=</span><span class="fl">0.05</span>, hspace<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb25-747"><a href="#cb25-747" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-748"><a href="#cb25-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-749"><a href="#cb25-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-750"><a href="#cb25-750" aria-hidden="true" tabindex="-1"></a>Now, let us compare the tasks's difficulty distribution depending on the strategy considered using <span class="in">`peerannot`</span>.</span>
<span id="cb25-751"><a href="#cb25-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-754"><a href="#cb25-754" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-755"><a href="#cb25-755" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-756"><a href="#cb25-756" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb25-757"><a href="#cb25-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-758"><a href="#cb25-758" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s entropy <span class="op">-</span>K <span class="dv">10</span> <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb25-759"><a href="#cb25-759" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb25-760"><a href="#cb25-760" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-761"><a href="#cb25-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-762"><a href="#cb25-762" aria-hidden="true" tabindex="-1"></a>We can see in @fig-difficulty-labelme that because the number of labels given per task is in $<span class="sc">\{</span>1,2,3<span class="sc">\}</span>$, the entropy only takes four values and thus does not help to dissociate the tasks.</span>
<span id="cb25-763"><a href="#cb25-763" aria-hidden="true" tabindex="-1"></a>In particular, tasks with only one label all have a null entropy, so not just consensual tasks.</span>
<span id="cb25-764"><a href="#cb25-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-767"><a href="#cb25-767" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-768"><a href="#cb25-768" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-769"><a href="#cb25-769" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-difficulty-labelme</span></span>
<span id="cb25-770"><a href="#cb25-770" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of metrics scoring the task's intrinsic difficulty.</span></span>
<span id="cb25-771"><a href="#cb25-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-772"><a href="#cb25-772" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> pearsonr</span>
<span id="cb25-773"><a href="#cb25-773" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> corrfunc(x, y, ax<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kws):</span>
<span id="cb25-774"><a href="#cb25-774" aria-hidden="true" tabindex="-1"></a>    r, _ <span class="op">=</span> pearsonr(x, y)</span>
<span id="cb25-775"><a href="#cb25-775" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax <span class="kw">or</span> plt.gca()</span>
<span id="cb25-776"><a href="#cb25-776" aria-hidden="true" tabindex="-1"></a>    ax.annotate(<span class="vs">rf'$\rho$ = </span><span class="sc">{</span>r<span class="sc">:.2f}</span><span class="vs">'</span>, xy<span class="op">=</span>(<span class="fl">.1</span>, <span class="fl">.1</span>), xycoords<span class="op">=</span>ax.transAxes)</span>
<span id="cb25-777"><a href="#cb25-777" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">'glad'</span>: [], <span class="st">"entropy"</span>: []}</span>
<span id="cb25-778"><a href="#cb25-778" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span> <span class="op">/</span> <span class="st">"identification"</span></span>
<span id="cb25-779"><a href="#cb25-779" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"entropy"</span>] <span class="op">=</span> np.load(path <span class="op">/</span> <span class="st">'entropies.npy'</span>)</span>
<span id="cb25-780"><a href="#cb25-780" aria-hidden="true" tabindex="-1"></a>results[<span class="st">"glad"</span>] <span class="op">=</span> np.exp(np.load(path <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"difficulties.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb25-781"><a href="#cb25-781" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> pd.DataFrame(results)</span>
<span id="cb25-782"><a href="#cb25-782" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb25-783"><a href="#cb25-783" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb25-784"><a href="#cb25-784" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-785"><a href="#cb25-785" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-786"><a href="#cb25-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-787"><a href="#cb25-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-788"><a href="#cb25-788" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring workers' reliability</span></span>
<span id="cb25-789"><a href="#cb25-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-790"><a href="#cb25-790" aria-hidden="true" tabindex="-1"></a>From the labels, we can explore different worker evaluation scores.</span>
<span id="cb25-791"><a href="#cb25-791" aria-hidden="true" tabindex="-1"></a>GLAD's strategy estimates a reliability scalar coefficient $\alpha_j$ per worker.</span>
<span id="cb25-792"><a href="#cb25-792" aria-hidden="true" tabindex="-1"></a>With strategies looking to estimate confusion matrices, we investigate two scoring rules for workers:</span>
<span id="cb25-793"><a href="#cb25-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-794"><a href="#cb25-794" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the trace of the confusion matrix: the closer to K the better the worker,</span>
<span id="cb25-795"><a href="#cb25-795" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>the spammer score <span class="co">[</span><span class="ot">@raykar_ranking_2011</span><span class="co">]</span> that is the Frobenius norm between the estimated confusion matrix $\hat\pi^{(j)}$ and the closest rank-$1$ matrix. The further to zero the better the worker.</span>
<span id="cb25-796"><a href="#cb25-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-797"><a href="#cb25-797" aria-hidden="true" tabindex="-1"></a>When the tasks are available, confusion-matrix-based deep learning models can also be of use.</span>
<span id="cb25-798"><a href="#cb25-798" aria-hidden="true" tabindex="-1"></a>We thus add to the comparison the trace of the confusion matrices with CrowdLayer and CoNAL on the datasets.</span>
<span id="cb25-799"><a href="#cb25-799" aria-hidden="true" tabindex="-1"></a>For CoNAL, we only consider the trace of the confusion matrix $\pi^{(j)}$ in the pairwise comparison, and provide the common confusion matrix $\pi^g$ as separate.</span>
<span id="cb25-800"><a href="#cb25-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-801"><a href="#cb25-801" aria-hidden="true" tabindex="-1"></a><span class="fu">### CIFAR-10H</span></span>
<span id="cb25-802"><a href="#cb25-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-803"><a href="#cb25-803" aria-hidden="true" tabindex="-1"></a>The Cifar-10H dataset has few disagreements among workers.</span>
<span id="cb25-804"><a href="#cb25-804" aria-hidden="true" tabindex="-1"></a>From @fig-abilities-cifar10H, we can see that in this dataset, different methods easily separate the worse workers from the rest of the crowd (workers in the tail of the distribution).</span>
<span id="cb25-805"><a href="#cb25-805" aria-hidden="true" tabindex="-1"></a>However, these strategies disagree on the ranking of good against best workers as they do not measure the same properties.</span>
<span id="cb25-806"><a href="#cb25-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-809"><a href="#cb25-809" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-810"><a href="#cb25-810" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-811"><a href="#cb25-811" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb25-812"><a href="#cb25-812" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb25-813"><a href="#cb25-813" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb25-814"><a href="#cb25-814" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb25-815"><a href="#cb25-815" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>cifar10H<span class="op">/</span>answers.json</span>
<span id="cb25-816"><a href="#cb25-816" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-817"><a href="#cb25-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-820"><a href="#cb25-820" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-821"><a href="#cb25-821" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-abilities-cifar10H</span></span>
<span id="cb25-822"><a href="#cb25-822" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-823"><a href="#cb25-823" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of ability scores by workers for the CIFAR-10H dataset.</span></span>
<span id="cb25-824"><a href="#cb25-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-825"><a href="#cb25-825" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"cifar10H"</span></span>
<span id="cb25-826"><a href="#cb25-826" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"trace_confusion"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb25-827"><a href="#cb25-827" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"trace_confusion"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb25-828"><a href="#cb25-828" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb25-829"><a href="#cb25-829" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb25-830"><a href="#cb25-830" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb25-831"><a href="#cb25-831" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb25-832"><a href="#cb25-832" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb25-833"><a href="#cb25-833" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-834"><a href="#cb25-834" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-835"><a href="#cb25-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-836"><a href="#cb25-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-837"><a href="#cb25-837" aria-hidden="true" tabindex="-1"></a><span class="fu">### LabelMe</span></span>
<span id="cb25-838"><a href="#cb25-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-839"><a href="#cb25-839" aria-hidden="true" tabindex="-1"></a>Finally, let us evaluate workers for the LabelMe dataset.</span>
<span id="cb25-840"><a href="#cb25-840" aria-hidden="true" tabindex="-1"></a>Because of the lack of data,</span>
<span id="cb25-841"><a href="#cb25-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-844"><a href="#cb25-844" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-845"><a href="#cb25-845" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb25-846"><a href="#cb25-846" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb25-847"><a href="#cb25-847" aria-hidden="true" tabindex="-1"></a><span class="op">!</span> peerannot aggregate .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">-</span>s GLAD</span>
<span id="cb25-848"><a href="#cb25-848" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> method <span class="kw">in</span> [<span class="st">"trace_confusion"</span>, <span class="st">"spam_score"</span>]:</span>
<span id="cb25-849"><a href="#cb25-849" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span> peerannot identify .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span> <span class="op">--</span>n<span class="op">-</span>classes<span class="op">=</span><span class="dv">10</span> <span class="op">\</span></span>
<span id="cb25-850"><a href="#cb25-850" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span>s {method} <span class="op">--</span>labels .<span class="op">/</span>datasets<span class="op">/</span>labelme<span class="op">/</span>answers.json</span>
<span id="cb25-851"><a href="#cb25-851" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-852"><a href="#cb25-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-855"><a href="#cb25-855" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb25-856"><a href="#cb25-856" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb25-857"><a href="#cb25-857" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-abilities-labelme</span></span>
<span id="cb25-858"><a href="#cb25-858" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Comparison of ability scores by workers for the labelme dataset.</span></span>
<span id="cb25-859"><a href="#cb25-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-860"><a href="#cb25-860" aria-hidden="true" tabindex="-1"></a>path_ <span class="op">=</span> Path.cwd() <span class="op">/</span> <span class="st">"datasets"</span> <span class="op">/</span> <span class="st">"labelme"</span></span>
<span id="cb25-861"><a href="#cb25-861" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> {<span class="st">"trace_confusion"</span>: [], <span class="st">"spam_score"</span>: [], <span class="st">"glad"</span>: []}</span>
<span id="cb25-862"><a href="#cb25-862" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"trace_confusion"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"traces_confusion.npy"</span>))</span>
<span id="cb25-863"><a href="#cb25-863" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"spam_score"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"spam_score.npy"</span>))</span>
<span id="cb25-864"><a href="#cb25-864" aria-hidden="true" tabindex="-1"></a>results_identif[<span class="st">"glad"</span>].extend(np.load(path_ <span class="op">/</span> <span class="st">'identification'</span> <span class="op">/</span> <span class="st">"glad"</span> <span class="op">/</span> <span class="st">"abilities.npy"</span>)[:, <span class="dv">1</span>])</span>
<span id="cb25-865"><a href="#cb25-865" aria-hidden="true" tabindex="-1"></a>results_identif <span class="op">=</span> pd.DataFrame(results_identif)</span>
<span id="cb25-866"><a href="#cb25-866" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> sns.pairplot(results_identif, corner<span class="op">=</span><span class="va">True</span>, diag_kind<span class="op">=</span><span class="st">"kde"</span>)</span>
<span id="cb25-867"><a href="#cb25-867" aria-hidden="true" tabindex="-1"></a>g.map_lower(corrfunc)</span>
<span id="cb25-868"><a href="#cb25-868" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-869"><a href="#cb25-869" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb25-870"><a href="#cb25-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-871"><a href="#cb25-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-872"><a href="#cb25-872" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion</span></span>
<span id="cb25-873"><a href="#cb25-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-874"><a href="#cb25-874" aria-hidden="true" tabindex="-1"></a>We introduced <span class="in">`peerannot`</span>, a library to handle crowdsourced datasets. This library enables both easy label aggregation and direct training strategies with classical state-of-the-art classifiers. The identification module of the library allows exploring the collected data from both the tasks and the workers' point of view for better scorings and data cleaning procedures.</span>
<span id="cb25-875"><a href="#cb25-875" aria-hidden="true" tabindex="-1"></a>Our library also comes with templated datasets to better share crowdsourced datasets and have strategies more uniform to test on.</span>
<span id="cb25-876"><a href="#cb25-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-877"><a href="#cb25-877" aria-hidden="true" tabindex="-1"></a>We hope that this library helps reproducibility in the crowdsourcing community and also standardizes training from crowdsourced datasets. New strategies can easily be incorporated into the open-source code <span class="co">[</span><span class="ot">available on github</span><span class="co">](https://github.com/peerannot/peerannot)</span>. Finally, as <span class="in">`peerannot`</span> is mostly directed to handle classification datasets, one of our future works would be to consider other <span class="in">`peerannot`</span> modules to handle crowdsourcing for object detection, segmentation and even worker evaluation in other contexts like peer-grading.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>